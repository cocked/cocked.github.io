{"meta":{"title":"Francis的个人博客","subtitle":"sharing technology or share music","description":"银河街角，时光路口","author":"Francis的个人博客","url":"https://www.qiezi.com"},"pages":[],"posts":[{"title":"01JavaSE入门基础总结","slug":"01JavaSE入门基础总结","date":"2018-08-20T13:00:18.000Z","updated":"2018-08-20T13:01:00.825Z","comments":true,"path":"2018/08/20/01JavaSE入门基础总结/","link":"","permalink":"https://www.qiezi.com/2018/08/20/01JavaSE入门基础总结/","excerpt":"","text":"一、String介绍(引用类型) 123456789101112131415161718192021222324252627282930313233343536373839404142434445461.java.lang.String字符串. 用&quot;&quot;括住的时字符串,都可以看做是实现此类的实例 类String中也有许多简单方法2.特点 1).字符串不变:字符串的值在创建后不能被更改 2).因为String对象不可改变.所有他们可以被共享 3).(底层是这么实现的)对String s1 赋值 &quot;abc&quot; 等效于char[] data = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]3.构造举例(面试可能会问，)// 无参构造String str = new String();// 通过字符数组构造char chars[] = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;String str2 = new String(chars);// 通过字节数组构造byte b[] = &#123;97,98,99&#125;;String str3 = new String(b);4.字符串的比较（面试的时候会问，结合String进行理解） 1. == 比较 1.对基本类型 这个东西 可以 比较基本类型 四类八种 （比较的是值是否相等） 2.对引用类型进行比较时， 则比较地址值 2.equals(String str) 内容相同 ，返回true 5.String 方法（1）获取equalsIgnoreCase(String str) 忽略大小写比较内容int length() 返回字符串长度String concat 将指定的字符串连接到该字符串的末尾char charAt(int index) 返回指定索引处的char值int indexOf(String str) 返回指定字符串第一次出现该字符串的位置(索引) 找到了就是对应的首次出现的索引，找不到就返回-1String substring (int beginIndex) 返回一个字符串，从beginIndex开始截取字符串到最后String substring (int beginIndex, int endIndex) 返回一个字符串，从beginIndex开始截取字符串到endIndex截取字符串。 含beg 不含 end 12345678910111213141516171819（2）转换1.String replace()ex: String str = &quot;abbccd&quot; String newstr = str.replace(&apos;b&apos;,&apos;*&apos;) System.out.println(newstr) a**ccd 此处将含有b的全部替换成*了 String newstr = str.replace(&quot;bb&quot;,&quot;*&quot;) 运行结果为a*ccd2.char [] chars = toCharArray()转成字符数组 3. byte[] getByte();使用平台默认的字符集将该String编码新的字节数组.4. String[] split(String regex) &quot;&quot;\\\\.&quot;表示.转义一下 以 regex对字符串进行分割 二、StringBuffer 123456789101.类介绍 ①线程安全的可变字符串序列，一个类似于String的字符串缓冲区，但是不能修改（就是不能通过加号+连接，String就可以） ②StringBuffer和String类的区别 String是一个可改变的字符序列 StringBuffer是一个可变的字符序列2.构造方法 StringBuffer() 构造一个没有字符的字符串缓冲区，初始容量为16个字符 StringBuffer(int capacity) 构造一个没有字符的字符串缓冲区和指定初始容量 StringBuffer(CharSequence seq) 构造一个字符串缓冲区,其中包含与指定的 CharSequence相同的字符。 StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 notes: 从jdk5开始,为该类补充了一个单个线程使用的等价类,即StringBuilder类,通常优先使用StringBuilder类,因为他支持所有相同操作,但是由于它不执行同步,所有速度更快3.增删,替换翻转,截取() StringBuffer sb = new StringBuffer(&quot;abcd&quot;); ①添加 sb.append(&quot;str12&quot;); //在末尾添加一个字符串 sb.insert(3,&quot;hhh&quot;); //在指定位置添加指定字符串 ②删除 sb.deleteCharAt(3); //删除指定1位置的字符 并返回本身 sb.delete(1,3); //左闭右开 ③清空缓冲区 sb.delete(0,sb.length()); ④替换 sb.replace(0,3,&quot;bai&quot;) // 包含头不包含尾 ⑤翻转 sb.reverse(); ⑥截取 sb.substring(int start) //从指定位置截取到末尾 sb.substring(int start,int end) //从指定位置开始到结束位置，包括开始位置，不包括结束位置 // 截取 返回值不再是StringBuffer而是String4.StringBuffer --&gt; String String --》 StringBuffer a.通过构造方法 StringBuffer stringBuffer = new StringBuffer(&quot;woai&quot;); System.out.println(stringBuffer); // 通过构造方法完成转换成String b.通过append()方法 StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;woai&quot;); System.out.println(stringBuffer); // 通过append()方法完成转换成String StringBuffer --》 String StringBuffer sb = new StringBuffer(&quot;woai1&quot;); a.通过构造方法 String s = new String(sb); // 通过构造方法 System.out.println(s); b.通过toString()方法 String string = sb.toString(); //通过toString()方法 System.out.println(&quot;string = &quot; + string); c.通过subString(0,length); String substring = sb.substring(0, sb.length()); System.out.println(substring); 5.数组 --&gt; 字符串 举例： int [] arr = &#123;1,2,3,&#125;; 输出结果: &quot;[1,2,3]&quot; 用StringBuff的功能实现： int[] arr = &#123;1, 2, 3&#125;; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; stringBuffer.append(arr[i]).append(&quot;]&quot;); // 使用这样的添加方式会减少垃圾的存在 &#125;else &#123; stringBuffer.append(arr[i]).append(&quot;,&quot;); &#125; &#125; System.out.println(stringBuffer);6.字符串翻转 通过StringBuffer进行翻转 7.StringBuffer和StringBuilder区别 StringBuffer是jdk1.0版本的，是线程安全的，效率低的 (对于用户访问量大的bat 保证其稳定性，对于金融要求，保证其稳定，其他都不存在) StringBuilder是jdk1.5版本的，是线程不安全的，效率高的 String和StringBuffer，StringBuilder的区别 String是一个不可变的字符序列 StringBuffer，StringBuilder是可变的字符序列8.String和StringBuffer作为参数传递 基本数据类型的值传递，不改变其值 引用数据类型的值传递，改变其值 // 因为传递的是内存地址， String s = &quot;heihei&quot;; System.out.println(s); change(s); System.out.println(s); // heihei 1System.out.println(&quot;------------------&quot;); 1234StringBuffer sb = new StringBuffer();sb.append(&quot;hhhhhh&quot;);change(sb);System.out.println(&quot;sb = &quot; + sb); // heiheihhhhhh 123456789109.数组-冒泡,选择,二分排序 (1)冒泡 // 数据元素：&#123;24,69,80,57,13&#125; 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处 (2)选择 (3)二分排序10.Arrays类11.Interger类12.String --&gt; int13.Interger面试题 ​三、StringBuffer的构造方法： 123456789101112131415161718192021222324252627282930* public StringBuffer():无参构造方法* public StringBuffer(int capacity) 指定容量的字符串缓冲区对象* public StringBuffer(String str) 指定字符串内容的字符串缓冲区对象StringBuffer sb = new StringBuffer()sb.append(&quot;&quot;)sb.insert(int offset , String str)// // 在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串本身// 在new的时候是在堆内存中创建了一个对象，底层是一个长度为16的字符数组，当调用添加方法时，不会再重新创建对象，在不断向原缓冲区添加zifusb.deleteCharAt(4) // 根据索引删除索引位置上对应的字符sb.detel(0,2) // 删除的时候包含头不包含尾sb.detel(0,sb.length()) // 情况缓冲区sb.replace(0,3,&quot;bai&quot;) // 替换 替换指定区域的字符sb.reverse() // 翻转sb.substring() // 截取sb.reverse() // 翻转String --&gt; StringBuffer //通过构造方法 //和 append 将 字符串 转换为 StringBuffer对象 StringBuffer sb = new StringBuffer(&quot;heima&quot;) StringBuffer --&gt; String // 通过构造方法 // 通过toString()方法 // 通过subString(0,length)StringBuffer和StrinBuilder的区别： 四、Arrays 1java.util.Arrays(操作数组的各种方法,如排序和搜索) 121.sort 排序 直接打印 无返回值2. 五、Math 1234java.lang.Math 类包含用于基本数学运算方法,如初等指数,对数,平方根和三角函数其所有方法为静态方法，并且不会创建对象，调用起来非常简单。1.abs 12345Math.sqrt()//计算平方根Math.cbrt()//计算立方根Math.pow(a, b)//计算a的b次方Math.max( , );//计算最大值Math.min( , );//计算最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364System.out.println(Math.sqrt(16)); //4.0 System.out.println(Math.cbrt(8)); //2.0System.out.println(Math.pow(3,2)); //9.0System.out.println(Math.max(2.3,4.5));//4.5System.out.println(Math.min(2.3,4.5));//2.3/** * abs求绝对值 */ System.out.println(Math.abs(-10.4)); //10.4 System.out.println(Math.abs(10.1)); //10.1 /** * ceil天花板的意思，就是返回大的值 */ System.out.println(Math.ceil(-10.1)); //-10.0 System.out.println(Math.ceil(10.7)); //11.0 System.out.println(Math.ceil(-0.7)); //-0.0 System.out.println(Math.ceil(0.0)); //0.0 System.out.println(Math.ceil(-0.0)); //-0.0 System.out.println(Math.ceil(-1.7)); //-1.0/** * floor地板的意思，就是返回小的值 */ System.out.println(Math.floor(-10.1)); //-11.0 System.out.println(Math.floor(10.7)); //10.0 System.out.println(Math.floor(-0.7)); //-1.0 System.out.println(Math.floor(0.0)); //0.0 System.out.println(Math.floor(-0.0)); //-0.0 /** * random 取得一个大于或者等于0.0小于不等于1.0的随机数 */ System.out.println(Math.random()); //小于1大于0的double类型的数System.out.println(Math.random()*2);//大于0小于1的double类型的数System.out.println(Math.random()*2+1);//大于1小于2的double类型的数/** * rint 四舍五入，返回double值 * 注意.5的时候会取偶数 异常的尴尬=。= */ System.out.println(Math.rint(10.1)); //10.0 System.out.println(Math.rint(10.7)); //11.0 System.out.println(Math.rint(11.5)); //12.0 System.out.println(Math.rint(10.5)); //10.0 System.out.println(Math.rint(10.51)); //11.0 System.out.println(Math.rint(-10.5)); //-10.0 System.out.println(Math.rint(-11.5)); //-12.0 System.out.println(Math.rint(-10.51)); //-11.0 System.out.println(Math.rint(-10.6)); //-11.0 System.out.println(Math.rint(-10.2)); //-10.0 /** * round 四舍五入，float时返回int值，double时返回long值 */ System.out.println(Math.round(10.1)); //10 System.out.println(Math.round(10.7)); //11 System.out.println(Math.round(10.5)); //11 System.out.println(Math.round(10.51)); //11 System.out.println(Math.round(-10.5)); //-10 System.out.println(Math.round(-10.51)); //-11 System.out.println(Math.round(-10.6)); //-11 System.out.println(Math.round(-10.2)); //-10 六、static(在方法区有一块固定的存储区域,由于优先于对象存在,所以可以被所有对象共享)​ 1234567891011121314在定义方法的时候你写main方法的类加static,写普通类的写方法的时候就不要加static1.static可以用来修饰成员变量和成员方法，被修饰的成员属于类，而不是单单属于某个对象，也就是说，既然属于类，就可以不靠创建对象来调用了进一步介绍： 修饰成员变量 当static修饰成员变量时，该变量称为类变量，该类的每个对象都共享同一个类变量的值，任何对象都可以更改 该变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作 类名.类变量 类名.静态方法名(参数); 1修饰成员方法 (静态方法可以访问静态变量,不能访问普通的变量) 12345类名.方法() 推荐对象名.方法名() 麻烦特点静态方法只能访问静态内容(成员变量,静态成员方法) ​​ 1234notes: 静态方法 可以直接访问 静态变量和 静态方法. 静态方法 不能直接访问 普通成员变量 或 成员方法,反之成员方法可以直接访问静态变量或静态方法 静态方法 不能使用this关键字 ​七、静态代码块(想在main方法之前执行,可以给静态成员变量赋值) 12345678910静态代码块：定义成员位置，使用static修饰代码块()位置:类方法外执行:随着类的加载而执行且执行一次,优先于main方法构造和构造方法执行格式: public class ClassName&#123; static&#123; // &#125; &#125; ​ JAVA中分为基本数据类型和引用数据类型区别一、基本数据类型： byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0 char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0 boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false 二、引用数据类型： 类、接口类型、数组类型、枚举类型、注解类型。 区别： 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 例如，有一个类Person,有属性name,age,带有参的构造方法， Person p = new Person(“zhangsan”,20); 在内存中的具体创建过程是： 1.首先在栈内存中位其p分配一块空间; 2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值””，0； 3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作； 4.调用构造方法，为两个属性赋值为”Tom”,20；（注意这个时候p与Person对象之间还没有建立联系）； 5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。 相关知识： 静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。 堆区： 一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错 栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限 文字常量区： 常量字符串就是放在这里的。 程序结束后由系统释放。","categories":[],"tags":[]},{"title":"Jquery初探","slug":"Jquery初探","date":"2018-08-20T02:15:18.000Z","updated":"2018-08-20T11:43:39.713Z","comments":true,"path":"2018/08/20/Jquery初探/","link":"","permalink":"https://www.qiezi.com/2018/08/20/Jquery初探/","excerpt":"","text":"#一、jQuery1.jQery核心语法​ jq的核心语法： jQuery(“选择器”)， jQuery(callback)， jQuery(html)。其中jQuery可以使用$代替。 2.js和jQery对象比较 JS对象（DOM） DOM：是文档对象模型；DOM对象指的是这个文档（html）中的某一个具体的节点对象； jQuery对象 jQuery对象是一个类数组的对象这个对象里面其实是包含了DOM对象的信息的然后封装了很多操作方法，调用自己的方法html与css处理，得到的效果与标准的JavaScript处理结果是一致的。 ​ jQuery ——–&gt; js &gt;jQuery对象[0]； &gt; &gt;jQuery对象.get(0)； ​ js ———&gt; jQuery &gt;只需要使用`$`将JS对象包裹即可：`$(dom)` 3.两者方法不通用 ​ jQuery对象不能使用JS对象的方法； ​ JS对象不能使用jQuery对象的方法； 4.事件注册 ​ js的事件的写法：js对象.onclick = function(){ … … }​ jquery的事件的写法：jquery对象.click( function(){ … … } )​ JS可以使用事件绑定和事件派发两种事件注册方式； ​ jQuery只能使用事件派发的方式来绑定事 5.onload事件 ​ js的页面加载完毕： 1window.onload = function()&#123; ...... &#125; ​ jquery的页面加载完毕： 12$(function()&#123;&#125;)$(document).ready(function()&#123;... ... &#125;) 6.jQuery常用事件 事件 使用方法 说明 click() jq对象.click( function(){ //方法体 } ) 鼠标单击事件 blur() jq对象.blur( function(){ //方法体 } ) 失去焦点事件 change() jq对象.change( function(){ //方法体 } ) 内容改变事件 submit() jq对象.submit( function(){ //方法体 } ) 表单提交事件 #二、选择器1.jQuery选择器 选择器 示例 说明 基本选择器 $(element),$(&quot;#id&quot;),$(&quot;.class&quot;),$(element,element) 元素，id，class，组合选择器 层级选择器 $(&quot;A B &quot;),$(&quot;A &gt; B&quot;),$(&quot;A + B&quot;),$(&quot;A ~ B&quot;) 根据标签之间的层级关系进行选择 属性过滤选择器 $(&quot;A[属性名]&quot;),$(&quot;A[属性名!=值]&quot;) 根据标签的属性对选中的标签进行过滤 基本过滤选择器 $(&quot;div:first&quot;),$(&quot;div:even&quot;) 根据标签所处的位置及特性进行过滤 表单对象属性过滤选择器 $(&quot;:selected&quot;),$(&quot;input:disabled&quot;) 根据表单对象的属性对选中的标签进行过滤 可见性过滤选择器 $(&quot;input:visible&quot;),$(&quot;input:hidden&quot;) 根据表单是否可见进行过滤。不可见的元素包括：1.隐藏域；2.style=”display:none” 内容过滤选择器 $(&quot;div:has(&#39;selector&#39;)&quot;) 根据元素中包含的内容过滤 表单过滤选择器 $(&quot;:input&quot;)$(&quot;:radio&quot;) 根据表单的特性进行过滤 2.基本选择器​ 基本选择器主要有：标签名（元素）选择器，id选择器，class选择器和组合选择器；如下： 选择器 使用示例 说明 标签名（元素）选择器 $(p),$(div) 根据标签名选择具有相同标签名的标签 id选择器 $(#idVal) 根据标签的id属性值选择 class选择器 $(.classVal) 根据标签的class属性值，选择具有相同class属性值的元素 组合选择器 $(div,p) 将多个选择器选中的标签合并返回 * $(*) 选择页面上的所有标签 3.层级选择器根据元素之间的层级关系进行选择。 选择器 名称 描述 $(“A空格B”) 后代选择器 后代选择器:选择给定祖先A元素的所有后代B元素，包括子元素，孙子元素等全部后代元素 $(“parent &gt; child”) 直接子元素 子选择器:选择所有指定”parent”元素中指定的”child”的直接子元素 $(“A+ B”) 相邻兄弟 相邻兄弟选择器:选择所有紧接在A元素后的第一个B元素 $(“A~ B”) 后面的兄弟元素 后面兄弟选择器：匹配“A”元素之后的所有兄弟B元素。 $(“A”).siblings(“B”); 一般兄弟元素 兄弟元素选择器 ：匹配所有的（之前+之后）兄弟元素 4.属性过滤选择器属性过滤选择器的作用：1.先选中；2.再根据属性过滤出想要的元素； 过滤器 使用示例 说明 [attribute] $(“input[name]”) 过滤拥有指定属性的元素 [attribute=value] $(“input[name=userName]”) 过滤出属性值=value的元素 [attribute!=value] $(“input[name!=password]”) 过滤出属性值！=value的元素 [attribute^=value] $(“input[name^=myClass]”) 过滤出属性值以value开始的元素 [attribute$=value] $(&quot;input[name$=myClass]&quot;) 过滤出属性值以value结束的元素 [attribute*=value] $(“input[class*=myClass]”) 过滤出属性值含有value的元素 [attr1][attr2][attr3]... $(&quot;input[name=username][value!=张三]...&quot;&quot;) 过滤指定的多个属性同时满足条件的元素，以上属性过滤的任意组合 5.基本过滤选择器 过滤方法 使用示例 说明 :first $(&quot;tr:first&quot;)：第一个tr，相当于$(&quot;tr:eq(0)&quot;) 第一个位置 :last $(&quot;tr:last&quot;):tr中的最后一个，相当于$(&quot;tr:eq(-1)&quot;) 最后一个位置 :odd $(&quot;tr:odd&quot;):tr中的奇数行（1,3,5,7……） 奇数位置 :even $(&quot;tr:even&quot;):tr中的偶数行(2,4,6,8……) 偶数位置 :eq(index) $(“tr:eq(0)”)：第一个tr 选取指定索引的元素 :gt(index) $(“tr:gt(1)”)：索引大于1的tr，即第2个tr之后的tr 选取索引大于指定索引的元素 :lt(index) $(“tr:lt(3)”)：索引小于3的tr，即前3个tr(0,1,2) 选取索引小于指定索引的元素 :not(selector) $(&quot;tr:not(tr:eq(2))&quot;):tr中除第2行外的行 去除与给定选择器匹配的元素（排除） :header $(&quot;:header&quot;)：获取h1到h6 匹配所有标题元素 :animated $(&quot;:animated&quot;):匹配所有正在执行动画效果的元素 匹配所有正在执行动画效果的元素 :focus $(&quot;input:focus&quot;):获取input中获取焦点的 匹配所有获取焦点的元素 6.表单对象属性过滤选择器表单对象属性过滤选择器是根据表单元素的某些属性来进行过滤选择的。 过滤器 使用示例 说明 :enabled $(“input:enabled”) 过滤可用的元素 :disabled $(“input:disabled” 过滤不可用的元素 :checked $(&quot;input[type=checkbox]:checked&quot;)或$(&quot;:checkbox:checked&quot;) 过滤被选中元素(复选框、单选框等，不包括select中的option) :selected $(&quot;select option:selected&quot;) 过滤被选中的元素（select的option） 7.可见性过滤选择器​ 可见性过滤选择器是根据标签是否可见进行过滤的，页面上能够看见的标签都是可见的。不可见的标签主要包括以下两种： 隐藏域：&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;520&quot;&gt; ； diaplay属性隐藏：&lt;div style=&quot;display:none&quot;&gt;&lt;/div&gt; ; 123456789101112$(function() &#123; //&lt;input type=\"button\" value=\" 选取所有可见的div元素\" id=\"b1\" /&gt; $(\"#b1\").click(function()&#123; $(\"div:visible\").css(\"background-color\",\"yellow\"); &#125;) //&lt;input type=\"button\" value=\" 选取所有不可见的div元素, 利用 jQuery 中的 show() 方法将它们显示出来\" id=\"b2\" /&gt; $(\"#b2\").click(function()&#123; $(\"div:hidden\").show(); &#125;)&#125;); 8.内容过滤选择器内容过滤选择器是根据标签中时候包含有某些内容，来对选择的标签进行过滤的。语法格式：$(&quot;div:has(selector)&quot;) 。 1234567$(function() &#123; //&lt;input type=\"button\" value=\"选取含有class为mini元素 的div元素.\" id=\"btn1\" /&gt; $(\"#btn1\").click(function()&#123; $(\"div:has('.mini')\").css(\"background-color\",\"yellow\"); &#125;)&#125;); 9.表单选择器​ 根据表单子标签的type属性进行过滤。目前只需要大家知道:input选择器选中的标签有哪些。其余的都可以使用属性过滤选择器来代替。 选择器 使用方法 说明 :input $(&quot;:input&quot;) 过滤出所有的表单子标签，包括：input，select，textarea，button :text $(&quot;:text&quot;) 过滤出表单子标签中type=”text”的标签 :password $(&quot;:password&quot;) 过滤出表单子标签中type=”password”的标签 :radio $(&quot;:radio&quot;) 过滤出表单子标签中type=”radio”的标签 :checkbox $(&quot;:checkbox&quot;) 过滤出表单子标签中type=”checkbox”的标签 :file $(&quot;:file&quot;) 过滤出表单子标签中type=”file”的标签 :hidden $(&quot;:hidden&quot;) 过滤出表单子标签中type=”hidden”的标签 :button $(&quot;:button&quot;) 过滤出表单子标签中type=”button”的标签，和&lt;button&gt;&lt;/button&gt;标签 :reset $(&quot;:reset&quot;) 过滤出表单子标签中type=”reset”的标签 :submit $(&quot;:submit&quot;) 过滤出表单子标签中type=”submit”的标签 :image $(&quot;:image&quot;) 过滤出表单子标签中type=”image”的标签 #三、jQuery操作方法1.jQuery的dom操作 方法 作用 说明 html()/text()/val() 设置或者获取：html代码/文本/值 方法不传参数为取值；方法传入参数为设置值 attr()/prop() 设置或者获取标签的属性 方法不传入参数为获取属性值，方法传入参数为设置属性值 addClass()/ removeClass() 添加或者移除标签的class属性 addClass()为添加class属性；removeClass()为移除class属性； css() 设置或者获取css样式 方法传入一个参数（样式名）为获取指定样式；方法传入两个参数为设置样式 $(&quot;&lt;p&gt;茄子创意&lt;/p&gt;&quot;) 创建新的标签 参数为完整的html标签 append()/prepend() 给父标签添加子标签 append（）：在父标签的子节点后面追加；prepend（）：在父标签的子节点前面追加； remove()/empty() 移除标签（文本和子标签）/清空标签体（文本和子标签） remove()：移除标签（当前标签及其子标签）；empty()：清空当前标签中的内容（保留原标签）； (1)、html代码/文本/值操作 html()方法与dom中的innerHTML操作结果一样，获取的是标签中的html内容； text()方法与dom中的innerText操作的结果一样，获取的是标签中的文本内容； val()方法与dom中的value操作的结果一样，获取的是标签的vlaue属性值； html(),text()和val()方法如果不传入参数则为取值，如果传入参数则为赋值操作； (2)、属性操作：attr()和prop() 对标签的普通属性的操作使用attr()方法更准确； 在获取checked或者selected属性值的时候建议使用prop()方法，其余都使用attr()方法； (3)、class属性操作和css样式操作 class属性操作： addClass()：给元素添加class属性； removeClass()：给元素移除class属性； css属性操作： css(cssName)：获取标签的css样式； css(cssName,cssValue)：给标签添加css样式； (4)、html元素创建与插入 html元素创建：$(html代码)； html元素插入：（注：a和b都是jq对象） 【内部插入】父子关系 方法 使用示例 说明 append() a.append(b) a把b插入到自己内部的后面（追加） appendTo() a.appendTo(b) a把自己插入到b的内部的后面 prepend() a.prepend(b) a把b插入到自己内部的前面 prependTo() a.prependTo(b) a把自己插入到b的内部的前面 【外部插入】兄弟关系 方法 使用示例 说明 after() a.after(b) a把b插入到自己的后面 insertAfter() a.insertAfter(b) a把自己插入到b的后面 before() a.before(b) a把b插入到自己的前面 insertBefore() a.insertBefore(b) a把自己插入到b的前面 (5)、html元素的删除操作 删除元素主要用到以下两个方法：remove() 和empty()方法，两者的区别： remove()方法：移除当前元素及其所有子元素； empty()方法：将当前元素的所有子元素清空，保留当前元素； 【应用场景】 remove()方法适用于完全删除元素及其子元素； empty()方法适用于将元素中的文本及其子元素清空，保留当前元素；如：清空select中的option。 2.jQuery效果（1）元素的显示与隐藏 元素的显示与隐藏主要用到以下3个方法： 方法 使用示例 说明 show(speed,fn) $(&quot;#_div&quot;).show(3000,function(){ alert(&quot;Hello World&quot;) }) 参数speed：元素显示的速度；参数fn：元素显示后执行的方法； hide(speed,fn) $(&quot;#_div&quot;).hide(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 toggle(speed,fn) $(“#_div”).toggle(3000,function(){ alert(“Hello World”) }) 同上 （2）元素的滑动显示与隐藏 元素的滑动显示与隐藏主要用到以下3个方法： 方法 使用示例 说明 slideUp(speed,fn) $(&quot;#_div&quot;).slideUp(3000,function(){ alert(&quot;Hello World&quot;) }) 通过高度变化（向上减少）参数speed：元素显示的速度；参数fn：元素显示后执行的方法； slideDown(speed,fn) $(&quot;#_div&quot;).slideDown(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 slideToggle(speed,fn) $(“#_div”).slideToggle(3000,function(){ alert(“Hello World”) }) 同上 (3)元素的淡入淡出显示效果 元素的淡入淡出显示效果主要使用到以下3个方法： 方法 使用示例 说明 fadeIn(speed,fn) $(&quot;#_div&quot;).fadeIn(3000,function(){ alert(&quot;Hello World&quot;) }) 参数speed：元素显示的速度；参数fn：元素显示后执行的方法； fadeOut(speed,fn) $(&quot;#_div&quot;).fadeOut(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 fadeToggle(speed,fn) $(“#_div”).fadeToggle(3000,function(){ alert(“Hello World”) }) 同上","categories":[],"tags":[]},{"title":"2Redis","slug":"2Redis","date":"2018-08-19T00:34:12.000Z","updated":"2018-08-19T07:39:50.805Z","comments":true,"path":"2018/08/19/2Redis/","link":"","permalink":"https://www.qiezi.com/2018/08/19/2Redis/","excerpt":"","text":"#一、NoSQL1.什么是nosql​ NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。适合存储不经常改变的从mysql中获取的数据，经常使用又不经常改变的数据存储在缓存数据库中 2.为什么需要nosql​ High performance - 对数据库高并发读写的需求 Huge Storage - 对海量数据的**高效率存储和访问**的需求 ​ High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求 3.nosql的特点​ 1.易扩展 ​ 2.大数据量，高性能 ​ 3.灵活的数据模型 ​ 4.高可用 4.nosql支持的数据类型​ 1.字符串类型 string（常用：json/xml） ​ 2.散列类型 hash(key value key–value(map) ) ​ 3.列表类型 list linkedlist 用户列表 ​ 4.集合类型 set ​ 5.有序集合类型 sortedset 5.Redis目录 目录或文件 作用 redis-benchmark 性能测试工具 redis-check-aof AOF文件修复工具 redis-check-dump RDB文件检查工具（快照持久化文件） redis-cli 命令行客户端 redis-server redis服务器启动命令 redis.windows.conf redis核心配置文件 Windows下安装6379(nosql)服务： ​ redis-server –service-install redis.windows.conf–loglevel verbose #二、Redis的5种数据类型​ 1.字符串类型 string（常用：json/xml） ​ 2.散列类型 hash(key value key–value(map) ) ​ 3.列表类型 list linkedlist 用户列表 ​ 4.集合类型 set ​ 5.有序集合类型 sortedset ​ ​ 在日常开发中主要使用比较多的有字符串、哈希、字符串列表、字符串集合四种类型，其中最为常用的是字符串类型。 1.关于key的定义，注意如下几点：​ 1.key不要太长，最好不要超过1024个字节，这不仅会消耗内存还会降低查找效率. ​ 2.key不要太短，如果太短会降低key的可读性 ​ 3.在项目中，key最好有一个统一的命名规范 2.字符串类型String ​ 1.字符串类型是在Redis中字符串类型的Value最多可以容纳的数据长度是512M。 ​ 2.Redis中最为基础的数据存储类型，字符串在Redis中是二进制保存，因此是安全的，这便意味着该类型存入和获取的数据相同。 ​ ​ ##3.常用命令 ​ (1)设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK” ​ #设置key-value ​ set company “qiezicy” ​ 获取value ​ get company ​ 删除 key ​ del company ​ (2)当存储的key对应的值是一个整数时，让当前的key对应的值进行递增。并返回递增后的值。 ​ INCR key：给key的值递增1 ​ INCRBY key increment：给key的值增加指定的整数（increment） ​ DECR key：给key的值递减1 ​ DECRBY key decrement：给key的值递减指定的整数（decrement） ​ ​ 用途：数据存储于一个库的一张表可以达到id的自增长，但当数据量非常庞大，不得不存储于多个表甚至于多个库时，如果使用数据库的id自增长就存在问题，多个表或者多个库中的不同数据的id会重复，因为每个表的id都是从1自增长的。这就需要借助于其他手段或者机制来实现，比如：借助于redis的INCR自增长的机制，维护共同的id ​ (3)APPEND ​ 1） 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 ​ 2） 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。 ​ 语法：APPEND key value ​ 返回值：追加指定值之后， key 中字符串的长度。 ​ (4) STRLEN ​ Strlen 命令用于获取指定 key 所储存的字符串值的长度。 ​ 语法：STRLEN key ​ 返回值：追加指定值之后， key 中字符串的长度。 ​ (5)MGET MSET ​ Mset命令用于同时设置一个或多个 k-v对 ​ 语法：MSET key1 value1 key2 value2 … keyN valueN ​ Mget 命令返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。 ​ 语法：MGET KEY1 KEY2 .. KEYN 3.哈希类型hash 12Key是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题 使用场景： ​ 存储部分变更数据，如用户信息等 语法： ​ 1.为指定的key设定field/value对（键值对） ​ hset key field value———&gt;&gt;hset myhash username haha ​ 2.返回指定的key中的field的值 ​ hget key field—————–&gt;&gt;hget myhash username ​ 3.可以删除一个或多个字段，返回值是被删除的字段个数 ​ hdel key field /field…———&gt;&gt;hdel myhash username ​ 4. HGETALL、HKEYS、HVALS 批量查询 ​ #HGETALL获取在哈希表中指定 key 的所有字段和值 ​ 语法：HGETALL key ​ 返回值： ​ 以列表形式返回哈希表的域和域的值。若 key 不存在，返回空列表。在返回值里，紧跟每个域名(field name)之后是域的值(value) ​ #HKEYS获取所有哈希表中的字段 ​ 语法：HKEYS key ​ 返回值： ​ 一个包含哈希表中所有字段的表。当 key 不存在时，返回一个空表。 ​ #HVALS获取哈希表中所有值 ​ 语法：HVALS key ​ 返回值： ​ 一个包含哈希表中所有域(field)值的列表。 当 key 不存在时，返回一个空表 ​ 5. HMSET、HMGET（批量新增） ​ 语法：HMSET key field1 value1 [field2 value2 ] ​ 同时将多个 field-value (域-值)对设置到哈希表 key 中。此命令会覆盖哈希表中已存在的字段。 ​ 返回值：如果命令执行成功，返回 OK 。当 key 不是哈希表(hash)类型时，返回一个错误。 &gt;hmset myhash qq 10001 email 10001@qq.com address china ​ 语法：HMGET key field [field ...] ​ 获取所有给定字段的值 ​ 返回值： ​ 一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。 &gt;hmget myhash username qq email 4.列表类型list应用场景： 12345Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。List 就是链表，使用List结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。 ​ 1，在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。 ​ 2，在插入时，如果该键不存在，Redis将为该键创建一个新的链表。 ​ 3，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。 ​ 4，List中可以包含的最大元素数量是4294967295 lpush key value1 value2 … 在指定的key所关联的list的头部插入所有的values， 如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。 插入成功，返回元素的个数。 ​ rpush key value value value 在指定的key对应的list的尾部插入所有的value， 如果该key不存在，该命令在插入之前创建一个与该key对应的空链表，再从尾部插入数据。 ​ lpop key 先进后出，弹出第一个元素 返回并弹出指定的key关联的链表中的第一个元素，即头部元素。 如果该key不存在，返回nil； 若key存在，则返回链表的头部元素。 ​ rpop key 从尾部弹出元素。 5.集合类型set应用场景： 1234Redis set对外提供的功能与list类似是一个列表的功能， 特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时， set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口， 这个也是list所不能提供的。 简单介绍： 1在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295，和List类型不同的是，Set集合中不允许出现重复的元素。 常用命令 sadd key values[value1**、**value2…] 向set中添加数据，如果该key的值已有则不会重复添加 sadd myset 1 2 4 srem key members[member1、member2…] 获取set中所有的成员 srem key members[member1、member2…] 删除set中指定的成员 6小结 字符串 set get del json格式字符串 hash hset hget hgetall hmset list lpush rpush lpop rpop sadd smemebers srem #三、Redis的通用命令1.keys pattern示例：keys * (查询所有的键) 符号 含义 ? 匹配一个字符 * 匹配任意个(包括0个) 字符 [] 匹配括号间任一字符，可以使用”-“表示范围，如果a[a-d]可以匹配“ab”，“ac”，”ad” \\x 匹配字符x,用于转义符号，如果要匹配“?”就需要使用\\? 获取所有与pattern匹配的key，返回所有与该key匹配的keys。*表示任意一个或多个字符，?表示任意一个字符 2.del key1 key2…删除指定的key 3.exists key判断该key是否存在，1代表存在，0代表不存在 4.type key​ 获取指定key的类型。该命令将以字符串的格式返回。 返回的字符串为string、list、set、hash，如果key不存在返回none #四、Jedis的基本使用1.jedis介绍​ 在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 2.jedis常用API及Jar包 方法 解释 new Jedis(host, port) 创建jedis对象，参数host是redis服务器地址，参数port是redis服务端口 set(key value) 设置字符串类型的数据 get(key) 获得字符串类型的数据 hset(key, field, value) 设置哈希类型的数据 hget(key, field) 获得哈希类型的数据 lpush(key, values) 设置列表类型的数据 lpop(key) 列表左面弹栈 rpop(key) 列表右面弹栈 del(key) 删除指定的key commons-pool2-2.3.jar jedis-2.7.0.jar 3.jedis连接池的使用jedis连接资源的创建与销毁是很消耗程序性能，所以jedis为我们提供了jedis的池化技术** ‘#基本使用 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; //1 获得连接池配置对象，设置配置项 JedisPoolConfig config = new JedisPoolConfig(); // 1.1 最大连接数 config.setMaxTotal(30); // 1.2 最大空闲连接数 config.setMaxIdle(10); //2 获得连接池 JedisPool jedisPool = new JedisPool(config, \"localhost\", 6379); //3 获得核心对象 Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //4 设置数据 jedis.set(\"name\", \"qiezicy\"); //5 获得数据 String name = jedis.get(\"name\"); System.out.println(name); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; if(jedis != null)&#123; jedis.close(); &#125; // 虚拟机关闭时，释放pool资源 if(jedisPool != null)&#123; jedisPool.close(); &#125; &#125; 4.JedisUtils工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.qiezi.jedisPool;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.util.ResourceBundle;/** * Created by IntelliJ IDEA * * @author Eric.Shen * @date 2018/8/19 * @time 14:09 */public final class JedisUtil &#123; public JedisUtil() &#123; &#125; /** * 连接池对象 */ private static JedisPool jedisPool; /** * 最大连接数 */ private static int maxtotal; /** *最大等待时间 */ private static int maxwaitmillis; /** * 主机地址 */ private static String host; /** * 端口：默认6379 */ private static int port; /** * 读取jedis.properties配置文件 */ static &#123; ResourceBundle rb = ResourceBundle.getBundle(\"jedis\"); maxtotal = Integer.parseInt(rb.getString(\"maxtotal\")); maxwaitmillis = Integer.parseInt(rb.getString(\"maxwaitmillis\")); host = rb.getString(\"host\"); port = Integer.parseInt(rb.getString(\"port\")); &#125; /** * 创建连接池 */ static &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxIdle(maxtotal); jedisPoolConfig.setMaxWaitMillis(maxwaitmillis); jedisPool = new JedisPool(jedisPoolConfig, host, port); &#125; /** * 获取Jedis * @return */ public static Jedis getJedis() &#123; return jedisPool.getResource(); &#125; /** * 关闭Jedis * @param jedis */ public static void close(Jedis jedis) &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125;&#125; jedis.properties(src目录下配置文件，编写配置文件) 1234maxtotal=100maxwaitmillis=3000host=127.0.0.1port=6379","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2018-08-18T23:12:27.000Z","updated":"2018-08-18T23:13:23.105Z","comments":true,"path":"2018/08/19/第一篇博客/","link":"","permalink":"https://www.qiezi.com/2018/08/19/第一篇博客/","excerpt":"","text":"#第一篇博客​ ##费尽周折终于将自己的博客上线， ​ 在这里 ，在我对hexo熟悉之后，将会不定期的更新我的博客主要关于Java，以及java中遇到的问题，也有可能分享生活， ​ ##以后补充： ​ ##之前的博客： ​ 博客园：https://www.cnblogs.com/zhengyuan/ ​ CSDN：https://blog.csdn.net/A_Eric ​ GitHub：https://github.com/cocked ​ ##git上的博客页面参照大佬的： ​ 参照大佬的博客:https://github.com/iTimeTraveler/hexo-theme-hiker","categories":[],"tags":[]}]}