{"meta":{"title":"Francis的个人博客","subtitle":"sharing technology or share music","description":"银河街角，时光路口","author":"Francis","url":"htts://cocked.github.io"},"pages":[],"posts":[{"title":"12Java函数式接口、方法引用","slug":"12Java函数式接口、方法引用","date":"2018-08-27T02:31:37.928Z","updated":"2018-08-27T02:56:04.009Z","comments":true,"path":"2018/08/27/12Java函数式接口、方法引用/","link":"","permalink":"htts://cocked.github.io/2018/08/27/12Java函数式接口、方法引用/","excerpt":"","text":"12.1 函数式接口12.1.1 概念1.函数式接口在Java中是指：有且仅有一个抽象方法的接口。 2.函数式接口，即适用于函数式编程场景的接口，而Java中的函数式编程体现就是Lambda，所有函数式接口就是可以适用于Lamnda使用的接口，只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。 3、语法糖的定义：是指使用更加方便，但是原理不变的代码语法，例如在遍历集合时使用的for-each语法，其实底层的实现原理 仍然是迭代器，这就是语法糖，从应用层讲， java中的Lambda可以被当做是匿名内部类的语法糖，但是二者原理上不同的 4.复习之前Lambda的使用要求， 使用条件1：必须拥有函数式接口，（java语言中已经提供了很多函数式接口） 使用条件2：调用的方法必须拥有函数式接口作为方法的参数，（Java语言已经提供了很多方法，这些方法的参数都是函数式接口） 12.1.2 格式只要确保接口中有且仅有一个抽象方法即可 12345修饰符 interface 接口名称 &#123; public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容&#125; 由于接口当中抽象方法的public abstract是可以省略的，所以定义一个函数式接口很简单： 123public interface MyFunctionalInterface &#123; void myMethod();&#125; 12.1.3 @FunctionalInterface注解与@Override注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。该注解可用于一个接口的定义上： 12345678// 函数式接口注解 : 该接口仅能拥有一个抽象方法@FunctionalInterfacepublic interface MyFunctionalInterface &#123; // 抽象方法定义 : void myMethod();&#125; notes：一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样 12.2 函数式编程12.2.1 Lambda 的延时执行有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。 性能浪费的日志案例 一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出： 123456789101112131415161718192021 public static void main(String[] args) &#123; String s1 = \"Hello\"; String s2 = \"World\"; String s3 = \"Java\"; // 调用方法 log(0, s1 + s2 + s3); &#125; // 方法 : public static void log(int level, String msg) &#123; if (level == 1) &#123; System.out.println(msg); &#125; &#125;结果： 说明 : 如果 level 不为 1, 则没有任何输出结果. 说明 : 如果 level 为 1, 输出结果如下 : HelloWorldJava notes：这段代码存在问题：无论级别是否满足要求，作为log方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。 体验Lambda的优化写法 使用Lambda必然需要一个函数式接口： 123456@FunctionalInterfacepublic interface MessageBuilder &#123; // 抽象方法 String buildMsg();&#125; 然后对log方法进行改造 123456789101112131415161718192021 public static void main(String[] args) &#123; String s1 = \"Hello\"; String s2 = \"World\"; String s3 = \"Java\"; // 调用方法 : log(1, () -&gt; s1 + s2 + s3); &#125; // 方法 : public static void log(int level, MessageBuilder messageBuilder) &#123; if (level == 1) &#123; String result = messageBuilder.buildMsg(); System.out.println(\"result = \" + result); &#125; &#125;输出结果 :result = HelloWorldJava noets：这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。 除此之外Lambda还可作为参数和返回值 12.2.2 使用函数式接口作为参数 例子：自定义一个函数是接口MyFunctionalInterface，里面有且仅有一个抽象方法void myMethod()。来说明使用函数式接口作为参数 思路历程： ** Lambda表达式实现 ** **思考1**，接口MyFunctionalInterface中的抽象方法长什么样（有无参数，有无返回值）， **思考2**，Lambda的表达式的各个部分是什么样的 （） -&gt; {} () 其中这里面放的是参数列表，一定要和函数式接口中的抽象放的参数列表保持一致 {} 方法的实现题部分 一定要和函数式接口中的抽象方法的返回值保持一致 开始写代码： 1234567891011121314151617181920public class MyFunctionalInterfaceTest1 &#123; public static void main(String[] args) &#123; // 重点 : 调用方法, 传递 Lambda 表达式作为函数式接口的实际参数 // 思考 : MyFunctionalInterface 函数式接口中的抽象方法长什么样 ??? void myMethod(); // () 小括号 : 函数式接口抽象方法的参数列表. // &#123;&#125; 大括号 : 函数式接口抽象方法的方法实现体. // Lambda 表达式的标准格式 : doSomething(() -&gt; &#123; System.out.println(\"Lambda 表达式被执行 ...\"); &#125;); // Lambda 表达式的省略格式 : doSomething(() -&gt; System.out.println(\"Lambda 表达式被执行 ...\")); &#125; // 定义一个方法, 使用函数式接口作为方法的参数列表 public static void doSomething(MyFunctionalInterface inter) &#123; // 此处为 Lambda 表达式代码的调用 inter.myMethod(); &#125;&#125; 1234567891011121314/*Lambda 表达式书写的前提要求 : (传递 Lambda 表达式作为方法的参数就是重要) 1. 必须要有 `函数式接口`. (自动推导) (Java提供) 2. 必须有方法使用 `函数式接口` 作为方法的参数列表. (Java提供) */// 请问 : 如何让编译器该接口是否为函数式接口@FunctionalInterfacepublic interface MyFunctionalInterface &#123; // 抽象方法 : 无参无返回值 void myMethod();&#125; 12.2.3 使用函数式接口作为返回值例子：自定义一个MySupplier函数式接口，无参有返回值，里面有且仅有一个方法Object getData();来说明函数式接口作为返回值 思路历程： 1.函数式接口中的抽象方法是什么样子的（Object getData()） 其中 抽象方式是没有参数，但是是有返回值的，返回值类型是 Object， 1. Lambda 的格式按照需求应该怎么写 ()中不需要写任何参数列表 {} 中有返回值 加return 书写要实现的方法。 **开始写代码** 12345678910111213141516171819202122232425262728public class MySupplierTest1 &#123; public static void main(String[] args) &#123; // 调用方法 // 思考 : 看一下 MySupplier 的抽象方法长什么样 ??? Object data(); printData(() -&gt; &#123; return \"Hello ShangHai, I Love you.\"; &#125;); // 调用方法 MySupplier mySupplier = getDataFromLambda(); // 请问 : 如何取出数据 ??? 调用函数式接口中的方法, 来获取数据 Object data = mySupplier.getData(); System.out.println(\"data = \" + data); &#125; // 方法 : 将函数式接口作为方法的参数 public static void printData(MySupplier mySupplier) &#123; Object data = mySupplier.getData(); System.out.println(\"data = \" + data); &#125; // 方法 : 将函数式接口作为方法的返回值 public static MySupplier getDataFromLambda() &#123; // 如何实现 : 返回一个 Lambda 表达式 Object getData(); // return () -&gt; &#123; return \"你爱北京长城.\"; &#125;; return () -&gt; \"你爱北京长城.\"; &#125;&#125; 123456@FunctionalInterfacepublic interface MySupplier &#123; // 抽象方法 : 无参, 有返回值 Object getData();&#125; 12.3 方法引用 **概述** : 什么是方法引用呢 ??? 其实就是 Lambda 表达式的孪生兄弟. 也可以理解为引用一个已经实现了 Lambda 表达式相同功能的方法. ** 格式** : 对象::对象方法 System.out::println 12.3.2 冗余的Lambda场景看一个简单的函数式接口以应用Lambda表达式 1234@FunctionalInterfacepublic interface Printable&lt;T&gt; &#123; void print(T t);&#125; ​ 在Printable接口当中唯一的抽象方法print接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单： 12345678910111213 public static void main(String[] args) &#123; // 调用方法 : printString(\"Hello beijing, 你好, 北京.\", s -&gt; System.out.println(s)); &#125; // 方法 : public static void printString(String str, Printable&lt;String&gt; printable) &#123; printable.print(str); &#125;输出结果： Hello beijing, 你好, 北京. 分析：这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是System.out对象中的println(String)方法。既然Lambda希望做的事情就是调用println(String)方法，那何必自己手动调用呢？这时候引入了其孪生兄弟， 方法引用： 改进之后的代码 12345678910111213141516171819202122 public static void main(String[] args) &#123; // 调用方法 : Lambda 表达式 printString(\"Hello beijing, 你好, 北京.\", s -&gt; System.out.println(s)); // 调用方法 : 方法引用 -&gt; 对象引用对象方法 PrintStream ps = System.out; printString(\"Hello beijing, 你好, 北京.\", ps::println); // 调用方法 : 简化格式 printString(\"Hello beijing, 你好, 北京.\", System.out::println); &#125; // 方法 : public static void printString(String str, Printable&lt;String&gt; printable) &#123; printable.print(str); &#125;输出结果 : Hello beijing, 你好, 北京. Hello beijing, 你好, 北京. Hello beijing, 你好, 北京. notes： 注意其中的双冒号::写法，这被称为“方法引用”，而双冒号是一种新的语法。** 12.3.3 方法引用符双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 *语义分析** 例如上例中，System.out对象中有一个重载的println(String)方法恰好就是我们所需要的。那么对于printString方法的函数式接口参数，对比下面两种写法，完全等效： Lambda表达式写法：s -&gt; System.out.println(s); 方法引用写法：System.out::println 第一种语义是指：拿到参数之后经Lambda之手，继而传递给System.out.println方法去处理。 第二种等效写法的语义是指：直接让System.out中的println方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 推导与省略** 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 12.3.4 通过对象名引用成员方法这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法： 思路历程： 1.接口Printable 中的抽象方法 void print(T t) 有参数 未指定类型，无返回值 printString(“Hello World. 你好, 世界!”, s -&gt; System.out.println(s)); 2，上面传递的Lambda 表达式 （s -&gt; System.out,println(s) ）的实现效果与 Sysetm.out 对象的println 方法实现一致 ​ 既然效果一样，那么Lambda表达式可不可以不写了，直接引用别人的方法。 ​ 方法引用的条件：引用的方法必须与函数式中的抽象方法匹配，（参数类型和返回值需要保持一致） ​ // Printable : void print(T t); System.out 对象的 void println(String x); ​ // 引用语法 : 对象名::对象方法名 3. // 简化格式 : System.out::println 对象名::对象方法 // 作用 : 已经有方法完成 Lambda 表达式需要实现的效果. 因此, 在程序中可以使用方法引用替代 Lambda 表达式. 4. // 方法 : 使用函数式接口作为参数 (这是 Lambda 表达式的传递基本) 12345678public class ObjectMethodRef &#123; // 对象方法 : public void printUpperCase(String str) &#123; String s = str.toUpperCase(); System.out.println(s); &#125;&#125; 12345// 函数式接口仍然定义为@FunctionalInterfacepublic interface Printable&lt;T&gt; &#123; void print(T t);&#125; 那么当需要使用这个printUpperCase成员方法来替代Printable接口的Lambda的时候，已经具有了ObjectMethodRef类的对象实例，则可以通过对象名引用成员方法，代码为： 1234567891011121314151617 public static void main(String[] args) &#123; // Lambda 表达式实现 : printString(\"hello\", s -&gt; System.out.println(s.toUpperCase())); // 对象方法引用 : ObjectMethodRef obj = new ObjectMethodRef(); printString(\"hello\", obj::printUpperCase); &#125; public static void printString(String str, Printable&lt;String&gt; printable) &#123; printable.print(str); &#125;输出结果 :HELLOHELLO 12.3.5 通过类名称引用静态方法由于在java.lang.Math类中已经存在了静态方法abs，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口： 123456@FunctionalInterfacepublic interface Calculator &#123; // 抽象方法 : int calc(int num);&#125; 1234567891011121314151617181920public class Test3 &#123; public static void main(String[] args) &#123; // 调用方法 : Lambda 表达式 printCalculator(-88, num -&gt; Math.abs(num)); // 调用方法 : 静态方法引用 printCalculator(-88, Math::abs); &#125; // 方法 : public static void printCalculator(int num, Calculator calculator) &#123; int result = calculator.calc(num); System.out.println(\"result = \" + result); &#125;&#125;输出结果 :result = 88result = 88 notes： 在这个例子中，下面两种写法是等效的： Lambda表达式：n -&gt; Math.abs(n) 方法引用：Math::abs 12.3.6 通过super引用成员方法​ 如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口 notes： 在这个例子中，下面两种写法是等效的： - Lambda表达式：() -&gt; super.sayHello() 方法引用：super::sayHello 12.3.7 通过this引用成员方法​ this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。首先是简单的函数式接口： 1234@FunctionalInterfacepublic interface Richable &#123; void buy();&#125; 123456789101112131415161718192021222324252627public class Husband &#123; // 行为 : 变得快乐 public void beHappy() &#123; // 结婚吧 merry(() -&gt; System.out.println(\"买套房子.\")); merry(() -&gt; this.buyCar()); merry(this::changeWife); &#125; // 行为 : 结婚 (需要变得有钱, 必须要买东西) private void merry(Richable richable) &#123; richable.buy(); &#125; // 行为 : 买套方法 private void buyHouse() &#123; System.out.println(\"买套房子.\"); &#125; // 行为 : 买辆车子 private void buyCar() &#123; System.out.println(\"买辆车子.\"); &#125;&#125; 123456789101112public class Test &#123; public static void main(String[] args) &#123; Husband husband = new Husband(); husband.beHappy(); &#125;&#125;输出结果 :买套房子.买辆车子. 开心方法beHappy调用了结婚方法marry，后者的参数为函数式接口Richable： 在这个例子中，下面两种写法是等效的： - Lambda表达式：() -&gt; this.buyCar() - 方法引用：this::buyCar 12.3.8 类的构造器引用由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用类名称::new的格式表示。首先是一个简单的Person类： 12345678910111213141516171819public class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 在这个例子中，下面两种写法是等效的： - Lambda表达式：name -&gt; new Person(name) - 方法引用：Person::new 12.3.9 数组的构造器引用数组也是Object的子类对象，所以同样具有构造器，只是语法稍有不同。 需要一个函数式接口 12345@FunctionalInterfacepublic interface ArrayBuilder &#123; // 抽象方法 int[] buildArray(int length);&#125; 12345678910111213141516171819public class Test2 &#123; public static void main(String[] args) &#123; int[] arr1 = initIntArray(10, len -&gt; new int[len]); System.out.println(\"arr1.length = \" + arr1.length); int[] arr2 = initIntArray(10, int[]::new); System.out.println(\"arr2.length = \" + arr2.length); &#125; // 初始化一个 int[] 数组 public static int[] initIntArray(int length, ArrayBuilder builder) &#123; return builder.buildArray(length); &#125;&#125;输出结果 :arr1.length = 10arr2.length = 10 在这个例子中，下面两种写法是等效的： - Lambda表达式：length -&gt; new int[length] - 方法引用：int[]::new 12.4 总结之 前瞻 Java语言的4大核心函数式接口12.4.1 总结 第一步：定义函数式接口 第二步： 定义方法，将函数式接口作为方法的参数类型 总结：只要满足前两个步骤，我们就可以书写Lambda表达式了， 问： 在使用Lambda表达式传送传输时，思考哪两个东西？？ 思考1：函数式接口中华抽象方法的参数列表 思考2：函数式接口中抽象方法的返回值类型 核心点：要求程序员对函数式接口中的抽象方法，参数类型和返回值类型，非常清晰的理解。因此没有这一层的理解，Lambda表达式的语法就无从书写了 Lambda表达式的语法格式**：（抽象方法参数） -&gt; { return 抽象方法的实现体 } 12.4.2 4大函数式接口 Java 语言中提供了最重要的 “四大核心函数式接口” 特有的抽象方法 消费型接口： 特点（有去无回）Consumer void accept（T t） 供给型接口 特点 （无中生有）Supplier T get(); 函数型接口 特点（有去有回）Function&lt;T, R&gt; R apply (T t) T -&gt; Type 参数类型 R -&gt; Result 返回值类型 断言型接口 特点（元芳，你怎么看）Predicate boolean test （T t） 说明：使用函数式接口作为方法的参数，这些API大部分都被定义到 StreamAPI 中 StreamAPI 主要操作对象为 “集合” 对象，不是 “读写” 对象 ​ 说明1：读写IO 主要是 “内存与硬盘” 实现数据交互 ​ 说明2：StreamAPI 主要是 ”内存与内存“ 实现数据交互 （变量，数组，集合）","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"Jquery初探","slug":"Jquery初探01","date":"2018-08-20T02:15:18.000Z","updated":"2018-08-27T02:23:31.472Z","comments":true,"path":"2018/08/20/Jquery初探01/","link":"","permalink":"htts://cocked.github.io/2018/08/20/Jquery初探01/","excerpt":"","text":"#一、jQuery1.jQery核心语法​ jq的核心语法： jQuery(“选择器”)， jQuery(callback)， jQuery(html)。其中jQuery可以使用$代替。 2.js和jQery对象比较 JS对象（DOM） DOM：是文档对象模型；DOM对象指的是这个文档（html）中的某一个具体的节点对象； jQuery对象 jQuery对象是一个类数组的对象这个对象里面其实是包含了DOM对象的信息的然后封装了很多操作方法，调用自己的方法html与css处理，得到的效果与标准的JavaScript处理结果是一致的。 ​jQuery ——–&gt; js jQuery对象[0]； jQuery对象.get(0)； ​js ———&gt; jQuery 只需要使用$将JS对象包裹即可：$(dom) 3.两者方法不通用 ​ jQuery对象不能使用JS对象的方法； ​ JS对象不能使用jQuery对象的方法； 4.事件注册 ​ js的事件的写法：js对象.onclick = function(){ … … }​ jquery的事件的写法：jquery对象.click( function(){ … … } )​ JS可以使用事件绑定和事件派发两种事件注册方式； ​ jQuery只能使用事件派发的方式来绑定事 5.onload事件 ​ js的页面加载完毕： 1window.onload = function()&#123; ...... &#125; ​ jquery的页面加载完毕： 12$(function()&#123;&#125;)$(document).ready(function()&#123;... ... &#125;) 6.jQuery常用事件 事件 使用方法 说明 click() jq对象.click( function(){ //方法体 } ) 鼠标单击事件 blur() jq对象.blur( function(){ //方法体 } ) 失去焦点事件 change() jq对象.change( function(){ //方法体 } ) 内容改变事件 submit() jq对象.submit( function(){ //方法体 } ) 表单提交事件 #二、选择器1.jQuery选择器 选择器 示例 说明 基本选择器 $(element),$(&quot;#id&quot;),$(&quot;.class&quot;),$(element,element) 元素，id，class，组合选择器 层级选择器 $(&quot;A B &quot;),$(&quot;A &gt; B&quot;),$(&quot;A + B&quot;),$(&quot;A ~ B&quot;) 根据标签之间的层级关系进行选择 属性过滤选择器 $(&quot;A[属性名]&quot;),$(&quot;A[属性名!=值]&quot;) 根据标签的属性对选中的标签进行过滤 基本过滤选择器 $(&quot;div:first&quot;),$(&quot;div:even&quot;) 根据标签所处的位置及特性进行过滤 表单对象属性过滤选择器 $(&quot;:selected&quot;),$(&quot;input:disabled&quot;) 根据表单对象的属性对选中的标签进行过滤 可见性过滤选择器 $(&quot;input:visible&quot;),$(&quot;input:hidden&quot;) 根据表单是否可见进行过滤。不可见的元素包括：1.隐藏域；2.style=”display:none” 内容过滤选择器 $(&quot;div:has(&#39;selector&#39;)&quot;) 根据元素中包含的内容过滤 表单过滤选择器 $(&quot;:input&quot;)$(&quot;:radio&quot;) 根据表单的特性进行过滤 2.基本选择器​ 基本选择器主要有：标签名（元素）选择器，id选择器，class选择器和组合选择器；如下： 选择器 使用示例 说明 标签名（元素）选择器 $(p),$(div) 根据标签名选择具有相同标签名的标签 id选择器 $(#idVal) 根据标签的id属性值选择 class选择器 $(.classVal) 根据标签的class属性值，选择具有相同class属性值的元素 组合选择器 $(div,p) 将多个选择器选中的标签合并返回 * $(*) 选择页面上的所有标签 3.层级选择器根据元素之间的层级关系进行选择。 选择器 名称 描述 $(“A空格B”) 后代选择器 后代选择器:选择给定祖先A元素的所有后代B元素，包括子元素，孙子元素等全部后代元素 $(“parent &gt; child”) 直接子元素 子选择器:选择所有指定”parent”元素中指定的”child”的直接子元素 $(“A+ B”) 相邻兄弟 相邻兄弟选择器:选择所有紧接在A元素后的第一个B元素 $(“A~ B”) 后面的兄弟元素 后面兄弟选择器：匹配“A”元素之后的所有兄弟B元素。 $(“A”).siblings(“B”); 一般兄弟元素 兄弟元素选择器 ：匹配所有的（之前+之后）兄弟元素 4.属性过滤选择器属性过滤选择器的作用：1.先选中；2.再根据属性过滤出想要的元素； 过滤器 使用示例 说明 [attribute] $(“input[name]”) 过滤拥有指定属性的元素 [attribute=value] $(“input[name=userName]”) 过滤出属性值=value的元素 [attribute!=value] $(“input[name!=password]”) 过滤出属性值！=value的元素 [attribute^=value] $(“input[name^=myClass]”) 过滤出属性值以value开始的元素 [attribute$=value] $(&quot;input[name$=myClass]&quot;) 过滤出属性值以value结束的元素 [attribute*=value] $(“input[class*=myClass]”) 过滤出属性值含有value的元素 [attr1][attr2][attr3]... $(&quot;input[name=username][value!=张三]...&quot;&quot;) 过滤指定的多个属性同时满足条件的元素，以上属性过滤的任意组合 5.基本过滤选择器 过滤方法 使用示例 说明 :first $(&quot;tr:first&quot;)：第一个tr，相当于$(&quot;tr:eq(0)&quot;) 第一个位置 :last $(&quot;tr:last&quot;):tr中的最后一个，相当于$(&quot;tr:eq(-1)&quot;) 最后一个位置 :odd $(&quot;tr:odd&quot;):tr中的奇数行（1,3,5,7……） 奇数位置 :even $(&quot;tr:even&quot;):tr中的偶数行(2,4,6,8……) 偶数位置 :eq(index) $(“tr:eq(0)”)：第一个tr 选取指定索引的元素 :gt(index) $(“tr:gt(1)”)：索引大于1的tr，即第2个tr之后的tr 选取索引大于指定索引的元素 :lt(index) $(“tr:lt(3)”)：索引小于3的tr，即前3个tr(0,1,2) 选取索引小于指定索引的元素 :not(selector) $(&quot;tr:not(tr:eq(2))&quot;):tr中除第2行外的行 去除与给定选择器匹配的元素（排除） :header $(&quot;:header&quot;)：获取h1到h6 匹配所有标题元素 :animated $(&quot;:animated&quot;):匹配所有正在执行动画效果的元素 匹配所有正在执行动画效果的元素 :focus $(&quot;input:focus&quot;):获取input中获取焦点的 匹配所有获取焦点的元素 6.表单对象属性过滤选择器表单对象属性过滤选择器是根据表单元素的某些属性来进行过滤选择的。 过滤器 使用示例 说明 :enabled $(“input:enabled”) 过滤可用的元素 :disabled $(“input:disabled” 过滤不可用的元素 :checked $(&quot;input[type=checkbox]:checked&quot;)或$(&quot;:checkbox:checked&quot;) 过滤被选中元素(复选框、单选框等，不包括select中的option) :selected $(&quot;select option:selected&quot;) 过滤被选中的元素（select的option） 7.可见性过滤选择器​ 可见性过滤选择器是根据标签是否可见进行过滤的，页面上能够看见的标签都是可见的。不可见的标签主要包括以下两种： 隐藏域：&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;520&quot;&gt; ； diaplay属性隐藏：&lt;div style=&quot;display:none&quot;&gt;&lt;/div&gt; ; 123456789101112$(function() &#123; //&lt;input type=\"button\" value=\" 选取所有可见的div元素\" id=\"b1\" /&gt; $(\"#b1\").click(function()&#123; $(\"div:visible\").css(\"background-color\",\"yellow\"); &#125;) //&lt;input type=\"button\" value=\" 选取所有不可见的div元素, 利用 jQuery 中的 show() 方法将它们显示出来\" id=\"b2\" /&gt; $(\"#b2\").click(function()&#123; $(\"div:hidden\").show(); &#125;)&#125;); 8.内容过滤选择器内容过滤选择器是根据标签中时候包含有某些内容，来对选择的标签进行过滤的。语法格式：$(&quot;div:has(selector)&quot;) 。 1234567$(function() &#123; //&lt;input type=\"button\" value=\"选取含有class为mini元素 的div元素.\" id=\"btn1\" /&gt; $(\"#btn1\").click(function()&#123; $(\"div:has('.mini')\").css(\"background-color\",\"yellow\"); &#125;)&#125;); 9.表单选择器​ 根据表单子标签的type属性进行过滤。目前只需要大家知道:input选择器选中的标签有哪些。其余的都可以使用属性过滤选择器来代替。 选择器 使用方法 说明 :input $(&quot;:input&quot;) 过滤出所有的表单子标签，包括：input，select，textarea，button :text $(&quot;:text&quot;) 过滤出表单子标签中type=”text”的标签 :password $(&quot;:password&quot;) 过滤出表单子标签中type=”password”的标签 :radio $(&quot;:radio&quot;) 过滤出表单子标签中type=”radio”的标签 :checkbox $(&quot;:checkbox&quot;) 过滤出表单子标签中type=”checkbox”的标签 :file $(&quot;:file&quot;) 过滤出表单子标签中type=”file”的标签 :hidden $(&quot;:hidden&quot;) 过滤出表单子标签中type=”hidden”的标签 :button $(&quot;:button&quot;) 过滤出表单子标签中type=”button”的标签，和&lt;button&gt;&lt;/button&gt;标签 :reset $(&quot;:reset&quot;) 过滤出表单子标签中type=”reset”的标签 :submit $(&quot;:submit&quot;) 过滤出表单子标签中type=”submit”的标签 :image $(&quot;:image&quot;) 过滤出表单子标签中type=”image”的标签 #三、jQuery操作方法1.jQuery的dom操作 方法 作用 说明 html()/text()/val() 设置或者获取：html代码/文本/值 方法不传参数为取值；方法传入参数为设置值 attr()/prop() 设置或者获取标签的属性 方法不传入参数为获取属性值，方法传入参数为设置属性值 addClass()/ removeClass() 添加或者移除标签的class属性 addClass()为添加class属性；removeClass()为移除class属性； css() 设置或者获取css样式 方法传入一个参数（样式名）为获取指定样式；方法传入两个参数为设置样式 $(&quot;&lt;p&gt;茄子创意&lt;/p&gt;&quot;) 创建新的标签 参数为完整的html标签 append()/prepend() 给父标签添加子标签 append（）：在父标签的子节点后面追加；prepend（）：在父标签的子节点前面追加； remove()/empty() 移除标签（文本和子标签）/清空标签体（文本和子标签） remove()：移除标签（当前标签及其子标签）；empty()：清空当前标签中的内容（保留原标签）； (1)、html代码/文本/值操作 html()方法与dom中的innerHTML操作结果一样，获取的是标签中的html内容； text()方法与dom中的innerText操作的结果一样，获取的是标签中的文本内容； val()方法与dom中的value操作的结果一样，获取的是标签的vlaue属性值； html(),text()和val()方法如果不传入参数则为取值，如果传入参数则为赋值操作； (2)、属性操作：attr()和prop() 对标签的普通属性的操作使用attr()方法更准确； 在获取checked或者selected属性值的时候建议使用prop()方法，其余都使用attr()方法； (3)、class属性操作和css样式操作 class属性操作： addClass()：给元素添加class属性； removeClass()：给元素移除class属性； css属性操作： css(cssName)：获取标签的css样式； css(cssName,cssValue)：给标签添加css样式； (4)、html元素创建与插入 html元素创建：$(html代码)； html元素插入：（注：a和b都是jq对象） 【内部插入】父子关系 方法 使用示例 说明 append() a.append(b) a把b插入到自己内部的后面（追加） appendTo() a.appendTo(b) a把自己插入到b的内部的后面 prepend() a.prepend(b) a把b插入到自己内部的前面 prependTo() a.prependTo(b) a把自己插入到b的内部的前面 【外部插入】兄弟关系 方法 使用示例 说明 after() a.after(b) a把b插入到自己的后面 insertAfter() a.insertAfter(b) a把自己插入到b的后面 before() a.before(b) a把b插入到自己的前面 insertBefore() a.insertBefore(b) a把自己插入到b的前面 (5)、html元素的删除操作 删除元素主要用到以下两个方法：remove() 和empty()方法，两者的区别： remove()方法：移除当前元素及其所有子元素； empty()方法：将当前元素的所有子元素清空，保留当前元素； 【应用场景】 remove()方法适用于完全删除元素及其子元素； empty()方法适用于将元素中的文本及其子元素清空，保留当前元素；如：清空select中的option。 2.jQuery效果（1）元素的显示与隐藏 元素的显示与隐藏主要用到以下3个方法： 方法 使用示例 说明 show(speed,fn) $(&quot;#_div&quot;).show(3000,function(){ alert(&quot;Hello World&quot;) }) 参数speed：元素显示的速度；参数fn：元素显示后执行的方法； hide(speed,fn) $(&quot;#_div&quot;).hide(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 toggle(speed,fn) $(“#_div”).toggle(3000,function(){ alert(“Hello World”) }) 同上 （2）元素的滑动显示与隐藏 元素的滑动显示与隐藏主要用到以下3个方法： 方法 使用示例 说明 slideUp(speed,fn) $(&quot;#_div&quot;).slideUp(3000,function(){ alert(&quot;Hello World&quot;) }) 通过高度变化（向上减少）参数speed：元素显示的速度；参数fn：元素显示后执行的方法； slideDown(speed,fn) $(&quot;#_div&quot;).slideDown(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 slideToggle(speed,fn) $(“#_div”).slideToggle(3000,function(){ alert(“Hello World”) }) 同上 (3)元素的淡入淡出显示效果 元素的淡入淡出显示效果主要使用到以下3个方法： 方法 使用示例 说明 fadeIn(speed,fn) $(&quot;#_div&quot;).fadeIn(3000,function(){ alert(&quot;Hello World&quot;) }) 参数speed：元素显示的速度；参数fn：元素显示后执行的方法； fadeOut(speed,fn) $(&quot;#_div&quot;).fadeOut(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 fadeToggle(speed,fn) $(“#_div”).fadeToggle(3000,function(){ alert(“Hello World”) }) 同上","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"htts://cocked.github.io/tags/jQuery/"}]},{"title":"2Redis","slug":"Redis初探01","date":"2017-02-18T00:34:12.000Z","updated":"2018-08-27T02:29:12.942Z","comments":true,"path":"2017/02/18/Redis初探01/","link":"","permalink":"htts://cocked.github.io/2017/02/18/Redis初探01/","excerpt":"","text":"#一、NoSQL1.什么是nosql​ NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。适合存储不经常改变的从mysql中获取的数据，经常使用又不经常改变的数据存储在缓存数据库中 2.为什么需要nosql​ High performance - 对数据库高并发读写的需求 Huge Storage - 对海量数据的**高效率存储和访问**的需求 ​ High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求 3.nosql的特点​ 1.易扩展 ​ 2.大数据量，高性能 ​ 3.灵活的数据模型 ​ 4.高可用 4.nosql支持的数据类型​ 1.字符串类型 string（常用：json/xml） ​ 2.散列类型 hash(key value key–value(map) ) ​ 3.列表类型 list linkedlist 用户列表 ​ 4.集合类型 set ​ 5.有序集合类型 sortedset 5.Redis目录 目录或文件 作用 redis-benchmark 性能测试工具 redis-check-aof AOF文件修复工具 redis-check-dump RDB文件检查工具（快照持久化文件） redis-cli 命令行客户端 redis-server redis服务器启动命令 redis.windows.conf redis核心配置文件 Windows下安装6379(nosql)服务： ​ redis-server –service-install redis.windows.conf–loglevel verbose #二、Redis的5种数据类型​ 1.字符串类型 string（常用：json/xml） ​ 2.散列类型 hash(key value key–value(map) ) ​ 3.列表类型 list linkedlist 用户列表 ​ 4.集合类型 set ​ 5.有序集合类型 sortedset ​ ​ 在日常开发中主要使用比较多的有字符串、哈希、字符串列表、字符串集合四种类型，其中最为常用的是字符串类型。 1.关于key的定义，注意如下几点：​ 1.key不要太长，最好不要超过1024个字节，这不仅会消耗内存还会降低查找效率. ​ 2.key不要太短，如果太短会降低key的可读性 ​ 3.在项目中，key最好有一个统一的命名规范 2.字符串类型String ​ 1.字符串类型是在Redis中字符串类型的Value最多可以容纳的数据长度是512M。 ​ 2.Redis中最为基础的数据存储类型，字符串在Redis中是二进制保存，因此是安全的，这便意味着该类型存入和获取的数据相同。 ​ ​ ##3.常用命令 ​ (1)设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK” ​ #设置key-value ​ set company “qiezicy” ​ 获取value ​ get company ​ 删除 key ​ del company ​ (2)当存储的key对应的值是一个整数时，让当前的key对应的值进行递增。并返回递增后的值。 ​ INCR key：给key的值递增1 ​ INCRBY key increment：给key的值增加指定的整数（increment） ​ DECR key：给key的值递减1 ​ DECRBY key decrement：给key的值递减指定的整数（decrement） ​ ​ 用途：数据存储于一个库的一张表可以达到id的自增长，但当数据量非常庞大，不得不存储于多个表甚至于多个库时，如果使用数据库的id自增长就存在问题，多个表或者多个库中的不同数据的id会重复，因为每个表的id都是从1自增长的。这就需要借助于其他手段或者机制来实现，比如：借助于redis的INCR自增长的机制，维护共同的id ​ (3)APPEND ​ 1） 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 ​ 2） 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。 ​ 语法：APPEND key value ​ 返回值：追加指定值之后， key 中字符串的长度。 ​ (4) STRLEN ​ Strlen 命令用于获取指定 key 所储存的字符串值的长度。 ​ 语法：STRLEN key ​ 返回值：追加指定值之后， key 中字符串的长度。 ​ (5)MGET MSET ​ Mset命令用于同时设置一个或多个 k-v对 ​ 语法：MSET key1 value1 key2 value2 … keyN valueN ​ Mget 命令返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。 ​ 语法：MGET KEY1 KEY2 .. KEYN 3.哈希类型hash 12Key是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题 使用场景： ​ 存储部分变更数据，如用户信息等 语法： ​ 1.为指定的key设定field/value对（键值对） ​ hset key field value———&gt;&gt;hset myhash username haha ​ 2.返回指定的key中的field的值 ​ hget key field—————–&gt;&gt;hget myhash username ​ 3.可以删除一个或多个字段，返回值是被删除的字段个数 ​ hdel key field /field…———&gt;&gt;hdel myhash username ​ 4. HGETALL、HKEYS、HVALS 批量查询 ​ #HGETALL获取在哈希表中指定 key 的所有字段和值 ​ 语法：HGETALL key ​ 返回值： ​ 以列表形式返回哈希表的域和域的值。若 key 不存在，返回空列表。在返回值里，紧跟每个域名(field name)之后是域的值(value) ​ #HKEYS获取所有哈希表中的字段 ​ 语法：HKEYS key ​ 返回值： ​ 一个包含哈希表中所有字段的表。当 key 不存在时，返回一个空表。 ​ #HVALS获取哈希表中所有值 ​ 语法：HVALS key ​ 返回值： ​ 一个包含哈希表中所有域(field)值的列表。 当 key 不存在时，返回一个空表 ​ 5. HMSET、HMGET（批量新增） ​ 语法：HMSET key field1 value1 [field2 value2 ] ​ 同时将多个 field-value (域-值)对设置到哈希表 key 中。此命令会覆盖哈希表中已存在的字段。 ​ 返回值：如果命令执行成功，返回 OK 。当 key 不是哈希表(hash)类型时，返回一个错误。 &gt;hmset myhash qq 10001 email 10001@qq.com address china ​ 语法：HMGET key field [field ...] ​ 获取所有给定字段的值 ​ 返回值： ​ 一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。 &gt;hmget myhash username qq email 4.列表类型list应用场景： 12345Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。List 就是链表，使用List结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。 ​ 1，在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。 ​ 2，在插入时，如果该键不存在，Redis将为该键创建一个新的链表。 ​ 3，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。 ​ 4，List中可以包含的最大元素数量是4294967295 lpush key value1 value2 … 在指定的key所关联的list的头部插入所有的values， 如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。 插入成功，返回元素的个数。 ​ rpush key value value value 在指定的key对应的list的尾部插入所有的value， 如果该key不存在，该命令在插入之前创建一个与该key对应的空链表，再从尾部插入数据。 ​ lpop key 先进后出，弹出第一个元素 返回并弹出指定的key关联的链表中的第一个元素，即头部元素。 如果该key不存在，返回nil； 若key存在，则返回链表的头部元素。 ​ rpop key 从尾部弹出元素。 5.集合类型set应用场景： 1234Redis set对外提供的功能与list类似是一个列表的功能， 特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时， set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口， 这个也是list所不能提供的。 简单介绍： 1在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295，和List类型不同的是，Set集合中不允许出现重复的元素。 常用命令 sadd key values[value1**、**value2…] 向set中添加数据，如果该key的值已有则不会重复添加 sadd myset 1 2 4 srem key members[member1、member2…] 获取set中所有的成员 srem key members[member1、member2…] 删除set中指定的成员 6小结 字符串 set get del json格式字符串 hash hset hget hgetall hmset list lpush rpush lpop rpop sadd smemebers srem #三、Redis的通用命令1.keys pattern示例：keys * (查询所有的键) 符号 含义 ? 匹配一个字符 * 匹配任意个(包括0个) 字符 [] 匹配括号间任一字符，可以使用”-“表示范围，如果a[a-d]可以匹配“ab”，“ac”，”ad” \\x 匹配字符x,用于转义符号，如果要匹配“?”就需要使用\\? 获取所有与pattern匹配的key，返回所有与该key匹配的keys。*表示任意一个或多个字符，?表示任意一个字符 2.del key1 key2…删除指定的key 3.exists key判断该key是否存在，1代表存在，0代表不存在 4.type key​ 获取指定key的类型。该命令将以字符串的格式返回。 返回的字符串为string、list、set、hash，如果key不存在返回none #四、Jedis的基本使用1.jedis介绍​ 在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 2.jedis常用API及Jar包 方法 解释 new Jedis(host, port) 创建jedis对象，参数host是redis服务器地址，参数port是redis服务端口 set(key value) 设置字符串类型的数据 get(key) 获得字符串类型的数据 hset(key, field, value) 设置哈希类型的数据 hget(key, field) 获得哈希类型的数据 lpush(key, values) 设置列表类型的数据 lpop(key) 列表左面弹栈 rpop(key) 列表右面弹栈 del(key) 删除指定的key commons-pool2-2.3.jar jedis-2.7.0.jar 3.jedis连接池的使用jedis连接资源的创建与销毁是很消耗程序性能，所以jedis为我们提供了jedis的池化技术** ‘#基本使用 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; //1 获得连接池配置对象，设置配置项 JedisPoolConfig config = new JedisPoolConfig(); // 1.1 最大连接数 config.setMaxTotal(30); // 1.2 最大空闲连接数 config.setMaxIdle(10); //2 获得连接池 JedisPool jedisPool = new JedisPool(config, \"localhost\", 6379); //3 获得核心对象 Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //4 设置数据 jedis.set(\"name\", \"qiezicy\"); //5 获得数据 String name = jedis.get(\"name\"); System.out.println(name); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; if(jedis != null)&#123; jedis.close(); &#125; // 虚拟机关闭时，释放pool资源 if(jedisPool != null)&#123; jedisPool.close(); &#125; &#125; 4.JedisUtils工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.qiezi.jedisPool;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.util.ResourceBundle;/** * Created by IntelliJ IDEA * * @author Eric.Shen * @date 2018/8/19 * @time 14:09 */public final class JedisUtil &#123; public JedisUtil() &#123; &#125; /** * 连接池对象 */ private static JedisPool jedisPool; /** * 最大连接数 */ private static int maxtotal; /** *最大等待时间 */ private static int maxwaitmillis; /** * 主机地址 */ private static String host; /** * 端口：默认6379 */ private static int port; /** * 读取jedis.properties配置文件 */ static &#123; ResourceBundle rb = ResourceBundle.getBundle(\"jedis\"); maxtotal = Integer.parseInt(rb.getString(\"maxtotal\")); maxwaitmillis = Integer.parseInt(rb.getString(\"maxwaitmillis\")); host = rb.getString(\"host\"); port = Integer.parseInt(rb.getString(\"port\")); &#125; /** * 创建连接池 */ static &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxIdle(maxtotal); jedisPoolConfig.setMaxWaitMillis(maxwaitmillis); jedisPool = new JedisPool(jedisPoolConfig, host, port); &#125; /** * 获取Jedis * @return */ public static Jedis getJedis() &#123; return jedisPool.getResource(); &#125; /** * 关闭Jedis * @param jedis */ public static void close(Jedis jedis) &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125;&#125; jedis.properties(src目录下配置文件，编写配置文件) 1234maxtotal=100maxwaitmillis=3000host=127.0.0.1port=6379","categories":[],"tags":[{"name":"nosql","slug":"nosql","permalink":"htts://cocked.github.io/tags/nosql/"}]},{"title":"19JavaSE操作数据库总结","slug":"19JavaSE操作数据库总结","date":"2017-02-17T02:58:36.000Z","updated":"2018-08-27T03:20:14.350Z","comments":true,"path":"2017/02/17/19JavaSE操作数据库总结/","link":"","permalink":"htts://cocked.github.io/2017/02/17/19JavaSE操作数据库总结/","excerpt":"","text":"一、JDBC JDBC有关的类：都在java.sql 和 javax.sql 包下. 1.数据准备这里假设已经在数据库中新建立了mydb4数据库，并且也插入了一些数据， 并且还需要导入一个jar包mysql-connector-java-5.1.17jar(可从官网下载) 2.JDBC 编程步骤**步骤1：**装载驱动 DriverManager.registerDriver(new Driver()); tips：在装载驱动的时候推荐使用**Class.forName(“com.mysql.jdbc.Driver”);** ​ 一、查看Driver的源代码可以看到，如果采用此种方式，会导致驱动程序注册两次，也就是在内存中会有两个Driver对象。 二、程序依赖mysql的api，脱离mysql的jar包，程序将无法编译，将来程序切换底层数据库将会非常麻烦。** **步骤2：建**立连接 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb4&quot;, &quot;root&quot;, &quot;111&quot;); 步骤3：操作数据库 1234567891011 Statement statement = conn.createStatement();ResultSet rs = statement.executeQuery(sql);while (rs.next()) &#123; System.out.println(rs.getString(\"username\")); System.out.println(rs.getString(\"email\"));&#125; 步骤4：释放资源 12345rs.close();statement.close();conn.close(); 3.一步到位的操作方式（更加面向对象&amp;&amp;解决SQL注入问题）： 将重复的内容 提取到JDBCUtils工具类中： 提供两种版本分别是硬编码和软编码 硬编码（信息写入到程序中）： JDBCUtils工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class JDBCUtils &#123; private static final String driverClass = \"com.mysql.jdbc.Driver\"; // 当时本地默认3306 可以省略，也可写成 \"jdbc:mysql://localhost:3306/mydb4?\" private static final String url = \"jdbc:mysql:///mydb4?\"; private static final String user = \"root\"; private static final String password = \"111\"; // 加载驱动 public static void loadDriver() &#123; // 1. 加载驱动 try &#123; Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); throw new RuntimeException(\"驱动加载失败!\"); &#125; &#125; // 获取连接 public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829@Testpublic void test_query() &#123; // 1. 加载驱动 JDBCUtils.loadDriver(); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; // 2. 建立连接 conn = JDBCUtils.getConnection(); // 3. 操作数据 String sql = \"select * from user;\"; // 这里有可能引起sql注入问题，换成prepareStatement（sql） stmt = conn.createStatement(); rs = stmt.executeQuery(sql); while (rs.next()) &#123; String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); System.out.println(username + \" = \" + password); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125;&#125; 软编码：从配置文件中读取（配置文件名字jdbc.properties） 1234567#配置文件#jdbc.properties#mysqldriverClass=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:///mydb4?user=rootpasswrod=111 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class JDBCUtils &#123; // 属性 private static String driverClass; private static String url; private static String username; private static String password; // 请问 : 什么时候加载外部配置文件最合适 ??? // 特点1 : 随着类的加载而加载. // 特点2 : 静态代码块只在类加载的被执行一次. 仅一次. static &#123; Properties prop = new Properties(); try &#123; prop.load(new FileReader(\"jdbc.properties\")); // 这里直接放在项目的目录下，具体要切合实际 // 如果程序执行到这里, 说明外部资源文件加载成功, 需要给我们的静态属性赋值 driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); // 直接执行加载驱动 loadDriver(); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(\"文件资源加载失败!\"); &#125; &#125; // 加载驱动 public static void loadDriver() &#123; try &#123; // 1. 加载驱动 Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; // e.printStackTrace(); // 驱动加载失败! throw new RuntimeException(\"驱动加载失败!\"); &#125; &#125; // 建立连接 public static Connection getConnection() throws SQLException &#123; // 2. 建立连接 return DriverManager.getConnection(url, username, password); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; // 4. 释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; // 将 rs 清空 rs = null; &#125; // 直接调用 release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; // 4. 释放资源 if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829303132333435@Test public void test_query() &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"select * from user where username = ? and password = ?;\"; // 预编译sql stmt = conn.prepareStatement(sql); // 设置sql语句的参数 stmt.setString(1, username); stmt.setString(2, password); // 执行sql语句 rs = stmt.executeQuery(); // 判断返回的结果 if (rs.next()) &#123; // 登录成功 int id = rs.getInt(\"id\"); String u_name = rs.getString(\"username\"); String u_pwd = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + u_name + \" : \" + u_pwd + \" : \" + email); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125; &#125; JDBCUtils中避免sql注入问题之后最终版总结： PreparedStatement的CRUD 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 @Test public void test_update() &#123; Connection conn = null; PreparedStatement stmt = null; try &#123; // 2. 建立连接 conn = JDBCUtils.getConnection(); // U 修改 // 3. 操作数据 String sql = \"update user set username = ?, password = ?, email = ? where id = ?;\"; stmt = conn.prepareStatement(sql); // 设置参数 stmt.setString(1, \"张三\"); stmt.setString(2, \"888\"); stmt.setString(3, \"zs@qiezi.cn\"); stmt.setInt(4, 1); // 执行 int affectedRowNum = stmt.executeUpdate(); System.out.println(affectedRowNum);// 删除 // 2. 操作数据 String sql = \"delete from user where id = ?;\"; stmt = conn.prepareStatement(sql); stmt.setInt(1, 4); int affectedRowNum = stmt.executeUpdate(); System.out.println(affectedRowNum); // 增加 // 2. 操作数据 String sql = \"insert into user values(?,?,?,?);\"; stmt = conn.prepareStatement(sql); // 设置参数 stmt.setInt(1, 4); stmt.setString(2, \"赵六\"); stmt.setString(3, \"888\"); stmt.setString(4, \"zl@qiezi.cn\"); int affectedRowNumber = stmt.executeUpdate(); System.out.println(affectedRowNumber); // 查询 // 2. 操作数据 String sql = \"select * from user where username = ? and password = ?;\"; stmt = conn.prepareStatement(sql); // 设置sql语句的参数 stmt.setString(1, username); stmt.setString(2, password); // 执行sql语句 rs = stmt.executeQuery(); // 判断返回的结果 if (rs.next()) &#123; // 登录成功 int id = rs.getInt(\"id\"); String u_name = rs.getString(\"username\"); String u_pwd = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + u_name + \" : \" + u_pwd + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125; 二、JdbcTemplate1.JdbcTemplate 介绍JDBC已经能够满足大部分用户最基本的需求，但是在使用JDBC时，必须自己来管理数据库资源如：获取PreparedStatement，设置SQL语句参数，关闭连接等步骤。JdbcTemplate就是Spring对JDBC的封装，目的是使JDBC更加易于使用。JdbcTemplate是Spring的一部分 JdbcTemplate处理了资源的建立和释放。他帮助我们避免一些常见的错误，比如忘了总要关闭连接。他运行核心的JDBC工作流，如Statement的建立和执行，而我们只需要提供SQL语句和提取结果。 在JdbcTemplate中执行SQL语句的方法大致分为3类： \\1. execute：可以执行所有SQL语句，一般用于执行DDL语句。 \\2. update：用于执行INSERT、UPDATE、DELETE等DML语句。 \\3. queryXxx：用于DQL数据查询语句。 **新增加，新复习 1234567891011121314151617181920212223242526272829303132333435DDL （数据定义语言）数据定义语言 - Data Definition Language用来定义数据库的对象，如数据表、视图、索引等create drop alter truncateDML （数据操纵语言）数据处理语言 - Data Manipulation Language在数据库表中更新，增加和删除记录如 update， insert， delete 不包含查询DCL （数据控制语言）数据控制语言 – Data Control Language指用于设置用户权限和控制事务语句如grant，revoke，if…else，while，begin transactionDQL （数据查询语言）（★★★★★）数据查询语言 – Data Query Language数据表记录的查询。select 2.JDBCTemplate使用：API介绍： 1.org.springframework.jdbc.core.JdbcTemplate类方便执行SQL语句 123456789101112131415161718192021222324252627282930313233public JdbcTemplate(DataSource dataSource)创建JdbcTemplate对象，方便执行SQL语句public void execute(final String sql)execute可以执行所有SQL语句，因为没有返回值，一般用于执行DML语句。public int update(final String sql)用于执行`INSERT`、`UPDATE`、`DELETE`等DML语句。public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args): 传入参数, 执行查询语句，返回一个指定类型的数据。 public Map&lt;String, Object&gt; queryForMap(String sql, Object... args)传入参数，执行查询语句，将一条记录放到一个Map中。public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args)传入参数，执行查询语句，返回一个List集合，List中存放的是Map类型的数据。public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper)执行查询语句，返回一个List集合，List中存放的是RowMapper指定类型的数据。public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper)执行查询语句，返回一个List集合，List中存放的是RowMapper指定类型的数据。public class BeanPropertyRowMapper&lt;T&gt; implements RowMapper&lt;T&gt;BeanPropertyRowMapper类实现了RowMapper接口 1.数据准备： 这里采用c3p0数据流连接池，集成到JDBCUtils 工具类中,需要将c3p0的配置文件放入到src目录下 导入依赖的jar包 2.创建JdbcTemplate对象，传入c3p0连接池 3.调用 execute、update、queryXxx等方法 c3p0-config.xml 配置文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置，c3p0框架默认加载这段默认配置 --&gt; &lt;default-config&gt; &lt;!-- 配置JDBC 四个基本属性 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb4?&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 可以自定义配置，为这段配置起一个名字，c3p0指定名称加载配置 --&gt; &lt;named-config name=\"zidingyimingzi\"&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb4?&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; JDBCUtils 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class JDBCUtils &#123; // 核心连接池类 private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static DataSource getDataSource() &#123; return dataSource; &#125; // 获取连接 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 测试类（实现增改） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class JDBCTemplateExecute &#123; public static void main(String[] args) &#123; // 查询语句 // 1. 创建表的SQL语句 String sql = \"create table product (\" + \"pid int primary key auto_increment,\" + \"pname varchar(20),\" + \"price double\" + \");\"; // 2. 创建 jdbcTemplate 对象, 并将数据库连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 3. 使用 jdbcTemplate 对象调用 execute 方法, 执行 sql 语句, 创建数据库表. jdbcTemplate.execute(sql); // 增加数据 // 2. 编写 sql 语句 String sql = \"insert into product values(null, ?, ?);\"; // 3. 执行 update 方法. jdbcTemplate.update(sql, \"iPhone3GS\", 3333); jdbcTemplate.update(sql, \"iPhone4\", 5000); // 修改数据 // 2. 执行 update 语句 String sql = \"update product set pname = ?, price = ? where pid = ?;\"; int count = jdbcTemplate.update(sql, \"XVIII\", 18888, 10); System.out.println(\"count = \" + count); // 删除数据 // 2. 执行 delete 操作 String sql = \"delete from product where pid = ?;\"; int count = jdbcTemplate.update(sql, 7); System.out.println(\"count = \" + count); &#125;&#125; 总结：JdbcTemplate的update方法用于执行DML语句。同时还可以在SQL语句中使用？占位，在update方法的Object… args可变参数中传入对应的参数。 测试类（实现查询） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 @Test public void test1() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // queryForObject 方法 // 2. 执行 queryForObject 方法 String sql = \"select pname from product where price = 7777\"; String pname = jdbcTemplate.queryForObject(sql, String.class); System.out.println(\"pname = \" + pname); // queryForMap 方法 // 2. 执行 queryForMap 方法 String sql = \"select * from product where pid = ?;\"; Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 6); System.out.println(\"map = \" + map); // objectForList // 2. 执行 objectForList 方法 String sql = \"select * from product where pid &lt; ?;\"; List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql, 8); for (Map&lt;String, Object&gt; map : list) &#123; System.out.println(map); &#125; // 使用RowMapper做映射返回对象 1. 定义Product类2. 创建JdbcTemplate对象3. 编写查询的SQL语句4. 使用JdbcTemplate对象的query方法，并传入RowMapper匿名内部类5. 在匿名内部类中将结果集中的一行记录转成一个Product对象 // 2. 执行 query 方法 String sql = \"select * from product;\"; List&lt;Product&gt; list = jdbcTemplate.query(sql, new RowMapper&lt;Product&gt;() &#123; @Override public Product mapRow(ResultSet rs, int i) throws SQLException &#123; Product product = new Product(); int pid = rs.getInt(\"pid\"); String pname = rs.getString(\"pname\"); double price = rs.getDouble(\"price\"); product.setPid(pid); product.setPname(pname); product.setPrice(price); return product; &#125; &#125;); // 遍历 list 集合 for (Product product : list) &#123; System.out.println(product); &#125;1. 定义Product类2. 创建JdbcTemplate对象3. 编写查询的SQL语句4. 使用JdbcTemplate对象的query方法，并传入BeanPropertyRowMapper对象 // 2. 执行 query 方法 String sql = \"select * from product;\"; List&lt;Product&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Product.class)); // 3. 遍历 list 集合 for (Product product : list) &#123; System.out.println(product); &#125; &#125; 总结： JDBCTemplate的query方法用于执行SQL语句，简化JDBC的代码。同时还可以在SQL语句中使用？占位，在query方法的Object... args可变参数中传入对应的参数。 三、c3p01234567891011121314151617181920212223242526272829303132在Hibernate和Spring 都提供对C3P0连接池支持.导入2个包基本操作 // 核心连接池类 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); // 设置四个JDBC基本连接属性 comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); comboPooledDataSource.setJdbcUrl(\"jdbc:mysql:///mydb4?\"); comboPooledDataSource.setUser(\"root\"); comboPooledDataSource.setPassword(\"111\");常用基本连接池属性acquireIncrement 如果连接池中连接都被使用了，一次性增长3个新的连接initialPoolSize 连接池中初始化连接数量默认:3maxPoolSize 最大连接池中连接数量默认：15连接maxIdleTime 如果连接长时间没有时间，将被回收默认：0 连接永不过期 minPoolSize 连接池中最小连接数量 默认：3 通过c3p0创建数据库连接池对象方式提取到JDBCUtils中 12345678910111213141516171819202122232425262728293031323334353637383940414243public class JDBCUtils &#123; // c3p0 数据库连接池对象属性 // 这里会自动读取 位于src目录下的c3p0-config.xml 数据库连接池配置文件 private static final ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 获取连接 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; c3p0-config.xml 数据库连接池配置文件 位于src 目录下 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置，c3p0框架默认加载这段默认配置 --&gt; &lt;default-config&gt; &lt;!-- 配置JDBC 四个基本属性 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb4&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 可以自定义配置，为这段配置起一个名字，c3p0指定名称加载配置 --&gt; &lt;named-config name=\"zidingyi\"&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb4&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 测试类： @Test public void test_jdbcUtils() { // 需求 : 查询 user 表中的所有数据 Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try { // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = &quot;select * from user;&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) { int id = rs.getInt(&quot;id&quot;); String username = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); String email = rs.getString(&quot;email&quot;); System.out.println(id + &quot; : &quot; + username + &quot; : &quot; + password + &quot; : &quot; + email); } } catch (SQLException e) { e.printStackTrace(); } finally { // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); } } 四、druidDruid (德鲁伊) 是阿里巴巴开发的号称为监控而生的数据库连接池，Druid是目前最好的数据库连接池。在功能、性能、扩展性方面，都超过其他数据库连接池，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况。Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。Druid地址：https://github.com/alibaba/druid DRUID连接池使用的jar包： 参数 说明 url 连接数据库的url：jdbc:mysql://localhost:3306/mydb username 数据库的用户名 password 数据库的密码 driverClassName 驱动类名。根据url自动识别，这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 最大连接池数量 maxIdle 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。 API介绍 com.alibaba.druid.pool.DruidDataSourceFactory类有创建连接池的方法 12public static DataSource createDataSource(Properties properties)创建一个连接池，连接池的参数使用properties中的数据 tips：我们可以看到DRUID连接池在创建的时候需要一个Properties对象来设置参数，所以我们使用properties文件来保存对应的参数。 DRUID连接池的配置文件名称随便，因为该配置文件需要我们手动实现加载。 druid.properties文件内容： 123456789driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/mydbusername=rootpassword=111initialSize=5maxActive=10maxWait=3000maxIdle=6minIdle=3 1.使用步骤:\\1. 在src目录下创建一个properties文件，并设置对应参数 \\2. 加载properties文件的内容到Properties对象中 \\3. 创建DRUID连接池，使用配置文件中的参数 \\4. 从DRUID连接池中取出连接 \\5. 执行SQL语句 \\6. 关闭资源 JDBCUtils 工具类集成 Druid 数据库连接池 public class JDBCUtils { 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 属性private static final DataSource dataSource;static &#123; Properties prop = new Properties(); try &#123; // 加载配置文件 // 配置文件的位置无所谓，这里放的是项目的目录下，因为Druid数据库连接池需要手动加载配置文件 prop.load(new FileReader(\"druid.properties\")); // 创建数据库连接池 dataSource = DruidDataSourceFactory.createDataSource(prop); &#125; catch (Exception e) &#123; throw new RuntimeException(\"连接池初始化失败!\"); &#125;&#125;public static DataSource getDataSource() &#123; return dataSource;&#125;// 建立连接public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection();&#125;// 释放资源public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt);&#125;public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // e.printStackTrace(); ignore 忽略. &#125; conn = null; // 目的: 让 conn 对象尽早被回收. &#125;&#125;&#125; 测试类 1234567891011121314151617181920212223242526272829 @Test public void test3() &#123; Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"select * from user;\"; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"18JavaSEJDBC_事务&JDBCTemplate","slug":"18JavaSEJDBC-事务-JDBCTemplate","date":"2017-02-15T13:39:10.000Z","updated":"2018-08-27T02:23:20.494Z","comments":true,"path":"2017/02/15/18JavaSEJDBC-事务-JDBCTemplate/","link":"","permalink":"htts://cocked.github.io/2017/02/15/18JavaSEJDBC-事务-JDBCTemplate/","excerpt":"","text":"一、JDBC_事务通过JDBC来操作银行转账的事务 1.API介绍Connection接口中与事务有关的方法 123456void setAutoCommit(boolean autoCommit) throws SQLException;false：开启事务， ture：关闭事务void commit() throws SQLException;提交事务void rollback() throws SQLException;回滚事务 案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class JDBCTransactionTest &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement stmt = null; try &#123; // 1. 获取连接对象 conn = JDBCUtils.getConnection(); // 第一步 : 开启事务 conn.setAutoCommit(false); // 2. 操作数据 // 2.1 账户转出 String outSql = \"update account set money = money - ? where name = ?;\"; stmt = conn.prepareStatement(outSql); stmt.setInt(1, 1000); stmt.setString(2, \"tom\"); stmt.executeUpdate(); // 模拟异常 ... // int num = 10 / 0; // 2.2 账户转入 String inSql = \"update account set money = money + ? where name = ?;\"; stmt = conn.prepareStatement(inSql); stmt.setInt(1, 1000); stmt.setString(2, \"jery\"); stmt.executeUpdate(); // 第二步 : 提交事务 conn.commit(); System.out.println(\"转账成功!\"); &#125; catch (Exception e) &#123; // 如果出现异常, 需要进行事务回滚. // 第三步 : 回滚事务 try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; System.out.println(\"转账失败!\"); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125;&#125; 二、jdbcTemplate1.API介绍org.springframework.jdbc.core.JdbcTemplate类方便执行SQL语句 1234public JdbcTemplate(DataSource dataSource)创建JdbcTemplate对象，方便执行SQL语句public void execute(final String sql)execute可以执行所有SQL语句，因为没有返回值，一般用于执行DML语句。 2.使用步骤1. 准备DruidDataSource连接池 \\2. 导入依赖的jar包 spring-beans spring-core spring-jdbc spring-tx com.springsource.org.apache.commons.logging.jar \\3. 创建JdbcTemplate对象，传入c3p0连接池 \\4. 调用execute、update、queryXxx等方法 3.案例（1）c3p0-config.xml配置文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置，c3p0框架默认加载这段默认配置 --&gt; &lt;default-config&gt; &lt;!-- 配置JDBC 四个基本属性 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb?&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 可以自定义配置，为这段配置起一个名字，c3p0指定名称加载配置 --&gt; &lt;named-config name=\"xxxxx\"&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb?&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; (2)JDBCUtils工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class JDBCUtils &#123; // 核心连接池类 private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static DataSource getDataSource() &#123; return dataSource; &#125; // 获取连接 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; jdbcTemplate的exeucte方法 1234567891011121314151617public class JDBCTemplateExecute &#123; public static void main(String[] args) &#123; // 1. 创建表的SQL语句 String sql = \"create table product (\" + \"pid int primary key auto_increment,\" + \"pname varchar(20),\" + \"price double\" + \");\"; // 2. 创建 jdbcTemplate 对象, 并将数据库连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 3. 使用 jdbcTemplate 对象调用 execute 方法, 执行 sql 语句, 创建数据库表. jdbcTemplate.execute(sql); &#125;&#125; 4通过jdbcTemplate实现增删改API介绍 123// org.springframework.jdbc.core.JdbcTemplate类方便执行SQL语句public int update(final String sql)用于执行`INSERT`、`UPDATE`、`DELETE`等DML语句 使用步骤： 1.创建JdbcTemplate对象 2.编写SQL语句 3.使用JdbcTemplate对象的update方法进行增删改 1.insert 增加数据 :123456789101112131415161718192021@Test public void insert() &#123; // 1. 创建一个 JdbcTemplate 对象, 并将连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 编写 sql 语句 String sql = \"insert into product values(null, ?, ?);\"; // 3. 执行 update 方法. jdbcTemplate.update(sql, \"iPhone3GS\", 3333); jdbcTemplate.update(sql, \"iPhone4\", 5000); jdbcTemplate.update(sql, \"iPhone4S\", 5001); jdbcTemplate.update(sql, \"iPhone5\", 5555); jdbcTemplate.update(sql, \"iPhone5C\", 3888); jdbcTemplate.update(sql, \"iPhone5S\", 5666); jdbcTemplate.update(sql, \"iPhone6\", 6666); jdbcTemplate.update(sql, \"iPhone6S\", 7000); jdbcTemplate.update(sql, \"iPhone6SP\", 7777); jdbcTemplate.update(sql, \"iPhoneX\", 8888); &#125; 2.update 修改数据 :1234567891011@Test public void update() &#123; // 1. 创建一个 JdbcTemplate 对象, 并将数据库连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 update 语句 String sql = &quot;update product set pname = ?, price = ? where pid = ?;&quot;; int count = jdbcTemplate.update(sql, &quot;XVIII&quot;, 18888, 10); System.out.println(&quot;count = &quot; + count); &#125; 3.delete 删除数据 :12345678910@Testpublic void delete() &#123; // 1. 创建一个 JdbcTemplate 对象, 并将数据库连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 delete 操作 String sql = \"delete from product where pid = ?;\"; int count = jdbcTemplate.update(sql, 7); System.out.println(\"count = \" + count);&#125; 小结：JdbcTemplate的update方法用于执行DML语句。同时还可以在SQL语句中使用？占位，在update方法的Object… args可变参数中传入对应的参数。 5 jdbcTemplate实现查询API介绍 queryForObject返回一个指定类型 12345678910111213141516171819// 单行单列的查询public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args): 传入参数, 执行查询语句，返回一个指定类型的数据。// 单行多列public Map&lt;String, Object&gt; queryForMap(String sql, Object... args)传入参数，执行查询语句，将一条记录放到一个Map中。// 多行多列public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args)传入参数，执行查询语句，返回一个List集合，List中存放的是Map类型的数据。// 返回一个List 存放对象数据public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper)执行查询语句，返回一个List集合，List中存放的是RowMapper指定类型的数据。// 提供了一个上述方法的一个实现类 RowMapper 行映射接口 BeanPropertyRowMapper 实体类属性行映射public class BeanPropertyRowMapper&lt;T&gt; implements RowMapper&lt;T&gt;BeanPropertyRowMapper类实现了RowMapper接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@Testpublic void test1() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 queryForObject 方法 String sql = \"select pname from product where price = 7777\"; String pname = jdbcTemplate.queryForObject(sql, String.class); System.out.println(\"pname = \" + pname);&#125;@Testpublic void test2() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 queryForMap 方法 String sql = \"select * from product where pid = ?;\"; Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 6); System.out.println(\"map = \" + map);&#125;@Testpublic void test3() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 objectForList 方法 String sql = \"select * from product where pid &lt; ?;\"; List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql, 8); for (Map&lt;String, Object&gt; map : list) &#123; System.out.println(map); &#125;&#125;@Testpublic void test4() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 query 方法 String sql = \"select * from product;\"; List&lt;Product&gt; list = jdbcTemplate.query(sql, new RowMapper&lt;Product&gt;() &#123; @Override public Product mapRow(ResultSet rs, int i) throws SQLException &#123; Product product = new Product(); int pid = rs.getInt(\"pid\"); String pname = rs.getString(\"pname\"); double price = rs.getDouble(\"price\"); product.setPid(pid); product.setPname(pname); product.setPrice(price); return product; &#125; &#125;); // 遍历 list 集合 for (Product product : list) &#123; System.out.println(product); &#125;&#125;@Testpublic void test5() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 query 方法 String sql = \"select * from product;\"; List&lt;Product&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Product.class)); // 3. 遍历 list 集合 for (Product product : list) &#123; System.out.println(product); &#125;&#125; 三、小结：JDBCTemplate的query方法用于执行SQL语句，简化JDBC的代码。同时还可以在SQL语句中使用？占位，在query方法的Object... args可变参数中传入对应的参数。","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"17JavaSE数据库连接池","slug":"17JavaSE数据库连接池","date":"2017-02-12T04:20:52.000Z","updated":"2018-08-27T02:23:15.174Z","comments":true,"path":"2017/02/12/17JavaSE数据库连接池/","link":"","permalink":"htts://cocked.github.io/2017/02/12/17JavaSE数据库连接池/","excerpt":"","text":"一、c3p0连接池1.导包(lib 下)数据库连接池 c3p0 machange-commons-java MySQL驱动 mysql-connector-java 2.核心方法12345678910111213// 核心连接池类 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); // 设置四个JDBC基本连接属性 comboPooledDataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); comboPooledDataSource.setJdbcUrl(\"jdbc:mysql:///test\"); comboPooledDataSource.setUser(\"root\"); comboPooledDataSource.setPassword(\"111\"); 3.jdbc.properties配置文件1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mysqlusername=rootpassword=111 4.JDBCUtils工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.io.FileReader;import java.io.IOException;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static final String driverClass; private static final String url; private static final String username; private static final String password; static &#123; Properties prop = new Properties(); try &#123; prop.load(new FileReader(\"jdbc.properties\")); driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); // 加载驱动 loadDriver(); &#125; catch (IOException e) &#123; // e.printStackTrace(); throw new RuntimeException(\"配置文件加载失败!\"); &#125; &#125; // 加载驱动 public static void loadDriver() &#123; try &#123; Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; // e.printStackTrace(); throw new RuntimeException(\"驱动加载失败!\"); &#125; &#125; // 获取连接 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, username, password); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 5.测试123456789101112131415161718192021222324252627282930313233343536373839404142// 测试类public class JDBCTemplateTest1 &#123; @Test public void test1() throws SQLException, PropertyVetoException &#123; // 需求 : 查询 user 表中的所有数据 // 核心连接池类 ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 设置四个JDBC基本连接属性 dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydb?serverTimezone=UTC&amp;characterEncoding=utf-8\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"111\"); Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = dataSource.getConnection(); // 2. 操作数据 String sql = \"select * from user;\"; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125; &#125;&#125; 6.通过xml 获取配置信息ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); 会自定加载配置文件 #常用基本连接池属性 acquireIncrement 如果连接池中连接都被使用了，一次性增长3个新的连接 maxPoolSize 最大连接池中连接数量默认：15连接 maxIdleTime 如果连接长时间没有时间，将被回收默认：0 连接永不过期 minPoolSize 连接池中最小连接数量 默认：3 initialPoolSize 连接池中初始化连接数量默认:3 1234567891011121314151617181920212223242526272829303132@Testpublic void test_c3p0() throws PropertyVetoException &#123; // 需求 : 查询 user 表中的所有数据 // 核心连接池类 ComboPooledDataSource dataSource = new ComboPooledDataSource(); Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = dataSource.getConnection(); // 2. 操作数据 String sql = \"select * from user;\"; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125;&#125; 7.优化JDBCUtils12345678910111213141516171819202122232425262728293031323334353637383940414243优化版的JDBCUtils 中的getConnectio 使用数据库连接池对象方式实现 public class JDBCUtils &#123; // c3p0 数据库连接池对象属性 private static final ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 获取连接 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 测试 123456789101112131415161718192021222324252627282930@Testpublic void test_jdbcUtils() &#123; // 需求 : 查询 user 表中的所有数据 Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"select * from user;\"; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"03MySQL3","slug":"03MySQL3","date":"2017-02-01T06:11:08.000Z","updated":"2018-08-27T02:34:16.154Z","comments":true,"path":"2017/02/01/03MySQL3/","link":"","permalink":"htts://cocked.github.io/2017/02/01/03MySQL3/","excerpt":"","text":"一、内外连接全连接，左右连接 通过两张表查找其对应的记录. 隐式 内连接 select * from a,b where a.列名 = b.列名 #左连接select * from a left outer join b on a.id = b.id #右连接select * from a right outer join b on a.id = b.id #全连接可以使用union来达到全外连接的查询效果。 union ：可以将左外连接查询和右外连接查询两条sql语句使用union合并起来进行查询，去掉重复的数据。 select * from a left outer join b on a.id = b.id union select * from a right outer join b on a.id = b.id 小结内连接：1、 隐式内连接：Select from a,b where a.id = b.id;结果：C2、 显示内连接：Select from a inner join b on a.id = b.id;结果：C 外连接：1、 左外连接select from a left outer join b on a.id = b.id结果：A+C2、 右外连接select from a right outer join b on a.id = b.id结果：B+C3、 union:相当于全外连接select from a left outer join b on a.id = b.idunionselect from a right outer join b on a.id = b.id 结果：A+B+C,会自动虑重 select from a left outer join b on a.id = b.idunion allselect from a right outer join b on a.id = b.id结果：A+B+C,有重复数据","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"htts://cocked.github.io/tags/mysql/"}]},{"title":"01MySQL1","slug":"01MySQL1","date":"2017-01-18T10:21:43.000Z","updated":"2018-08-27T02:35:05.623Z","comments":true,"path":"2017/01/18/01MySQL1/","link":"","permalink":"htts://cocked.github.io/2017/01/18/01MySQL1/","excerpt":"","text":"一、数据库的基本概念1.1 常用的关系型数据库123数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。 1.2 sql语言SQL是Structured Query Language(结构化查询语言)的缩写。SQL是专为数据库而建立的操作命令集。SQL功能强大、简单易学、使用方便，已经成为了数据库操作的基础，并且现在几乎所有的关系型数据库均支持SQL。 特点：1非过程性语言。一条语句一个结果。多条语句之间没有影响。每一条SQL执行完都会有一个具体的结果出现。 SQL是用来操作关系数据库的语言，具有查询、操纵、定义和控制关系型数据库的四方面功能 11.3 sql分类 DDL （数据定义语言）数据定义语言 - Data Definition Language用来定义数据库的对象，如数据表、视图、索引等create drop alter truncate DML （数据操纵语言）数据处理语言 - Data Manipulation Language在数据库表中更新，增加和删除记录如 update， insert， delete 不包含查询 DCL （数据控制语言）数据控制语言 – Data Control Language指用于设置用户权限和控制事务语句如grant，revoke，if…else，while，begin transaction DQL （数据查询语言）（★★★★★）数据查询语言 – Data Query Language数据表记录的查询。select 二、对数据库进行操作的语句1.1 数据库中默认自带有4个库：123 1.information_schema 数据库：其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据的表，表栏的数据类型与访问权限等。 2.performance_schema 数据库： 存储引擎：命名PERFORMANCE_SCHEMA，主要用于手机数据库服务器性能参数。 1233.mysql 数据库：mysql库是系统库，里面保存有账户信息，权限信息，存储过程，event,时区等信息4.test 数据库: 这个是安装时候创建的一个测试数据库，和它的名字一样，是一个完全的空数据库，没有任何表，可以删除。 1.2 查看所有数据库1.1 查询当前所有的数据库show databases；1.2 查看当前数据的创建方式：查看数据库的编码表show create database 库名；1.3 创建数据库create database 数据库名： 由于创建数据库时没有指定编码表，因此会使用安装数据库时默认的编码表create database 数据库名 character set 编码表名；创建数据库会使用指定的编码表1.4 删除数据库drop database 数据库名；1.5 修改数据库编码集alter database 数据库名称 character set 字符集； 1.3 数据表结构的sql语句 121.1 数据表的创建语句create table 表名( 列名 数据类型， 列名 数据类型， …… 列名 数据类型 (最后一个列不需要逗号) 1)； 1.2 查看表 1234show tables : 查看该数据库的所有的表 show create table 表名 ：查看建表语句以及字符集 desc emp 查看表的详细信息 show columns from emp ；查看表的列信息 1.4 约束 123451.1 主键约束 primary key varchar 类型的主键不可以自增长. 示例： 【示例】 create table 表名 ( id int primary key auto_increment, name varchar(20), ………….)； 121.2 唯一约束 unique 内容不允许重复，可以为null（null不算重复）。 一个表里可以添加多个唯一约束。【示例】create table 表名 ( id int primary key auto_increment, name varchar(20) unique, ………….)；唯一约束和主键约束的区别1、唯一约束可以是空(null)。 但是主键约束不能为空2、一张表中只能有一个主键，但是唯一约束可以有多个 12 1.3 非空约束not null 不允许为空 表示该列的内容 不允许为空。 约束的目的。目的：保证数据的正确性。约束列。限制列的内容。1.5 数据表结构的修改 1234561.修改数据表 可以对表名、表中的列名、列的类型、列的约束进行增删改 语法 ：alter table 表名 add/drop/modify 改名 类型长度 约束； 2. 修改现有列的类型，长度和约束 用modify3. 修改现有列名称 语法 alter table 表名 change 旧列名 新列名 类型（长度） 约束； · 4. 删除现有列 12345 语法 alter table 表名 drop 列名；5. 修改表名 语法 ：rename table 旧表名 to 新表名6. 修改表的字符集 语法 ： alter table 表名 character set 编码集； 1.6 数据表的删除 1语法 ： drop table 表名： 三、数据记录的增删改1在java代码中对数据库操作最频繁的就是对表中数据的CRUD操作：create read / retrive update delete 数据记录存储位置​ 12345增： 语法：insert into 表名 （列名，列名，列名。。。） values（ 值，值，值。。。）；改：update 表名 set 列名 = 值 ， 列名 = 值 .. . [where 条件语句]； notes：如果不加条件 则修改整列删：delete ：delete from 表名 [where 条件语句] notes：如果没有where 删除表中所有的记录 delete 删除的是行 truncate table 表名 是删除一个表，之后在根据你 的表结构在给你创建一张新表","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"htts://cocked.github.io/tags/mysql/"}]},{"title":"02MySQL2","slug":"02MySQL2","date":"2017-01-10T09:10:23.000Z","updated":"2018-08-27T02:34:44.792Z","comments":true,"path":"2017/01/10/02MySQL2/","link":"","permalink":"htts://cocked.github.io/2017/01/10/02MySQL2/","excerpt":"","text":"一、数据库的查询用法1、 数据表记录的查询: 运算符、虑重、列运算、别名、排序、聚合函数、分组 1.1数据准备 create table exam( id int primary key auto_increment, name varchar(20) not null, chinese double, math double, english double ); insert into exam values(null,’关羽’,85,76,60); insert into exam values(null,’张飞’,70,75,70); insert into exam values(null,’赵云’,90,65,95); insert into exam values(null,’刘备’,97,50,50); insert into exam values(null,’曹操’,90,89,80); insert into exam values(null,’司马懿’,90,67,65); insert into exam values（null，’刘阿斗’）； 1.2 数据查询 文件结构： 名字： 语法： █▓ 查询所有信息 select * from 表名 █▓ 查询指定列的信息 select 列名，列名... from 表名； █▓ 条件查询 select * from表名 where 条件 █▓ 运算符 比较运算符 &gt; &lt;&lt;= &gt;= =&lt;&gt; 大于、小于、大于/小于等于、不等于 between 1 and 10 显示某一区间的值:1—10之间 in(1,2,3) 显示在in列表中的值：1、2、3任意一个 Like ‘张_’Like ‘张%’ 模糊查询：%表示零或任意多个字符，表示一个字符.例子1：张三丰 like ‘张%’例子2：张三 like ‘张’ is null、is not null 是否为空 逻辑运算符 and&amp;&amp; 多个条件同时成立 or\\ \\ 多个条件任意一个成立 not! 不成立，例如：where not(age&gt;18) █▓ 虑重 查询排重：select distinct 列名 from 表名 where 条件； █▓ 别名以及列运算 select 列名 as 别名， 列名 as 别名 ... from 表名 where 条件； █▓ order by 排序 select * from 表名 order by 列名 asc desc； █▓ 关于null 问题 通过 ifnull（values，default）解决 █▓ SQL中聚合 / 聚集函数 聚集函数：多个数据进行运算，运算出一个结果。例如，求和，平均值，最大值，最小值。 语法：select avg(列名) from 表名；都是位于 select 后 █▓ █▓ █▓ group by 分组查询 select ... from ... group by 列名； █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ 重点总结 select 语句执行顺序 █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ select …要显示的内容.. from …表名.. where 条件…. group by …分组的列 …having …分组后的条件… order by …排序 select …4… from …1.. where …2.. group by ..3…having ..5… order by …6. 二、数据备份和恢复1.备份语法：mysqldump -u **用户名 -p 数据库名 &gt; 磁盘SQL**文件路径 2.恢复恢复方式1： 1.创建数据库 备份的时候，没有备份创建数据库的语句，当需要恢复某个具体数据的时候需要手动创建 1. 导入数据 source D://mydb.sql 恢复方式2： 1.创建数据库 2.语法：mysql -u 用户名 -p 导入库名 &lt; 硬盘SQL文件绝对路径 三、外键约束 添加外键需要注意的问题 l 如果从表要去添加一个外键约束。要求主表被引用的字段是主键或者唯一的。通常使用主键。 l 如果要删除主表中的数据。要求在从表中这个数据，要没有被引用，才可以去删除。 l 如果要向从表中去添加数据。要求在主表中，要有对应的数据。才可以去添加。 l 如果要删除表。要先删除从表。然后去删除主表。 l 新建表的时候。需要先去创建主表，然后去创建从表。 作用：保持数据的完整性，和有效性。 1.添加外键约束的语法创建表之后添加外键 █▓ █▓ alter table 从表名称 add foreign key （外键列的名称）references 主表名称（主键） 创建表的时候添加外键 /*创建部门表*/ create table dept( id int primary key auto_increment, name varchar(20) ); /创建员工表/ create table employee( id int primary key auto_increment, name varchar(20), age int , salary double, dept_id int, foreign key (dept_id) references dept(id) ); #总结：1.库的操作创建库：create database 库名 character set 编码表; 删除库：drop database 库名; 查询库：show databases; 查看库的编码表：show create database 库名; 更改库：use 库名; 查看当前正在使用的库：select database(); 修改库的编码表：alter database 库名 character set 编码表; 2.表本身的操作创建表：create table 表名( 列名 列的类型(长度) 类的约束 ,列名 列的类型(长度) 类的约束…… ); 删除表：drop table 表名; 查询表：show tables; 查看表的结构：desc 表名; 查看表的编码表：show create table 表名; 修改表：alter table 表名 增/删/改 列名 列的类型(长度) 约束; add/drop/change/modify 修改表名：rename table 旧表名 to 新表名； 3.表中数据的操作增：insert into 表名(列名) values(值); 删：delete from 表名 where 条件; truncate 改：update 表名 set 列名=值 ，列名=值 where 条件 ； 查：select 列名 as 别名 ,列名 as 别名… from 表名 where 条件 group by 列名 having 条件 order by 排序. 查询排重：select distinct 列名 from 表名 where 条件; 4.聚合函数：count 统计个数、sum求和、avg 平均值、max、min 在使用这几个函数进行数据的统计分析时，有时需要对数据表中的列进行数据的分组处理。group by 分组 group by : 排序：order by 列名 asc | desc；","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"htts://cocked.github.io/tags/mysql/"}]},{"title":"16JavaSEJDBC初体验","slug":"16JavaSEJDBC初体验","date":"2016-12-26T02:32:29.000Z","updated":"2018-08-27T02:23:09.962Z","comments":true,"path":"2016/12/26/16JavaSEJDBC初体验/","link":"","permalink":"htts://cocked.github.io/2016/12/26/16JavaSEJDBC初体验/","excerpt":"","text":"一、JDBC常用类和接口JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API。JDBC是Java访问数据库的标准规范，可以为不同的关系型数据库提供统一访问，它由一组用Java语言编写的接口和类组成。 JDBC**与数据库驱动的关系：接口与实现类的关系。** 二、JDBC常用类和接口JDBC有关的类：都在java.sql 和 javax.sql 包下. 接口在Java中是用来定义 行为规范的. 接口必须有实现类. JDBC规范（四个核心对象）： DriverManager:用于注册驱动 Connection: 表示与数据库创建的连接 Statement: 操作数据库sql语句的对象 ResultSet: 结果集或一张虚拟表 特别注意： Mysql驱动的driverClass 和url 的写法 com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/text 1.JDBC 初体验1234567891011121314151617181920212223// JDBC 初体验 @Testpublic void demo01() throws SQLException &#123; // 1. 装载驱动 DriverManager.registerDriver(new Driver()); // 2. 建立连接 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"111\"); // 3. 操作数据 String sql = \"select * from user;\"; Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; // 4. 释放资源 rs.close(); stmt.close(); conn.close();&#125; 2.JDBC工具类的提取（）方式一、 –src下放连接数据库的配置文件 |--properties 1234567 // 配置文件的名字 jdbc.properties#mysqldriverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mydbuser=rootpassword=111 –util包 |--JDBCUtils 类 | 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class JDBCUtils &#123; // 属性 private static String driverClass; private static String url; private static String username; private static String password; // 什么时候加载外部配置文件最合适 ??? // 特点1 : 随着类的加载而加载. // 特点2 : 静态代码块只在类加载的被执行一次. 仅一次. static &#123; Properties prop = new Properties(); try &#123; prop.load(new FileReader(\"jdbc.properties\")); // 如果程序执行到这里, 说明外部资源文件加载成功, 需要给我们的静态属性赋值 driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); // 直接执行加载驱动 loadDriver(); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(\"文件资源加载失败!\"); &#125; &#125; // 加载驱动 public static void loadDriver() &#123; try &#123; // 1. 加载驱动 Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; // e.printStackTrace(); // 驱动加载失败! throw new RuntimeException(\"驱动加载失败!\"); &#125; &#125; // 建立连接 public static Connection getConnection() throws SQLException &#123; // 2. 建立连接 return DriverManager.getConnection(url, username, password); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; // 4. 释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; // 将 rs 清空 rs = null; &#125; // 直接调用 release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; // 4. 释放资源 if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 3.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 @Test public void test_update() &#123; Connection conn = null; Statement stmt = null; try &#123; // 2. 建立连接 conn = JDBCUtils.getConnection(); // 3. 操作数据 String sql = \"update user set username = 'zhaoliu', password = '123', email = 'zhaoliu@youjian.cn' where id = 4;\"; stmt = conn.createStatement(); int affectedRowNum = stmt.executeUpdate(sql); System.out.println(affectedRowNum); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125; @Test public void test_delete() &#123; Connection conn = null; Statement stmt = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"delete from user where id = 5;\"; stmt = conn.createStatement(); int affectedRowNum = stmt.executeUpdate(sql); System.out.println(affectedRowNum); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125; @Test public void test_insert() &#123; Connection conn = null; Statement stmt = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"insert into user values(null, 'xiaoqi', '123', 'xiaoqi@youjian.cn');\"; stmt = conn.createStatement(); int affectedRowNumber = stmt.executeUpdate(sql); System.out.println(affectedRowNumber); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125;// 以上使用时 在进行查询的操作时 有可能会出现 sql注入问题// 解决SQL注入：使用PreparedStatement 取代 Statement // PreparedStatement 解决SQL注入原理，运行在SQL中参数以?占位符的方式表示// select * from user where username = ? and password = ? ;// 将带有?的SQL 发送给数据库完成编译 （不能执行的SQL 带有?的SQL 进行编译 叫做预编译），在SQL编译后发现缺少两个参数// PreparedStatement 可以将? 代替参数 发送给数据库服务器，因为SQL已经编译过，参数中特殊字符不会当做特殊字符编译，无法达到SQL注入的目的 /************ JDBC 数据库连接操作 ***************/ Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"select * from user where username = ? and password = ?;\"; stmt = conn.prepareStatement(sql); // 设置sql语句的参数 stmt.setString(1, username); stmt.setString(2, password); // 执行sql语句 rs = stmt.executeQuery(); // 判断返回的结果 if (rs.next()) &#123; // 登录成功 int id = rs.getInt(\"id\"); String u_name = rs.getString(\"username\"); String u_pwd = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + u_name + \" : \" + u_pwd + \" : \" + email); System.out.println(\"登录成功!\"); &#125; else &#123; // 登录失败 System.out.println(\"登录失败! 用户名或密码错误!\"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125; &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"15JavaSE动态代理、XML、正则","slug":"15JavaSE动态代理、XML、正则","date":"2016-12-12T15:31:58.000Z","updated":"2018-08-27T02:23:05.194Z","comments":true,"path":"2016/12/12/15JavaSE动态代理、XML、正则/","link":"","permalink":"htts://cocked.github.io/2016/12/12/15JavaSE动态代理、XML、正则/","excerpt":"","text":"15.1 动态代理学习Spring框架时，Spring框架有一大核心思想，就是AOP，(Aspact-Oriented-Programming 面向切面编程) 而AOP的原理就是Java的动态代理机制，在Java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的 15.1.1 动态代理的基础动态代理的基础 : 必须有接口Java中使用接口来定义统一的行为规范 : 接口. 接口必须有实现类：interface SuperStar 超级明星行为规范 :void sing(int money);void liveShow(int moeny);void sleep();​// 接口必须有实现类 : L implements SuperStar B implements SuperStarProxy 代理类 : Class Proxy 代理类 是在运行时创建的实现指定的接口列表（称为代理接口）的类 。 代理实例是代理类的一个实例。 每个代理实例都有一个关联的调用处理程序对象，它实现接口InvocationHandler 。 通过其代理接口之一的代理实例上的方法调用将被分派到实例调用处理程序的invoke方法 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 返回指定接口的代理实例，该代理实例将方法调用分派给指定的调用处理程序。 15.1.2 动态代理作用：拦截和控制 被代理对象 的所有行为 15.1.3 InvocationHandler 调用处理器Interface InvocationHandler 每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。 15.2 XML简介 : XML全称为Extensible Markup Language，意思是可扩展的标记语言。 标记 -&gt; 用标记来修饰文本信息. 可扩展 -&gt; 标记可随意定义. XML技术 : 与数据相关技术, 在企业中xml技术常用来存储数据和传输数据, xml之所以流行的原因在于xml语言与任何编程语言无关, xml可用于 php, java, .net任何编程语言. 15.2.1 书写一个xml配置文件xml编写时也要符合一定的规则 : 1）xml文件的后缀名是.xml2）xml有且只有一个根标签3）xml的标签是尖括号包裹关键字成对出现的，有开始标签有结束标签，关键字是自定义的, xml也可以有空标签/自关闭标签4）xml允许有属性，属性也是根据需要自定义的，属性格式：属性= “属性值”，多个属性之间使用空格隔开5）xml是区分大小写的 xml 的组成1）文档声明：&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt; 2）根标签，例如: 3）其他标签，例如： 4）属性，例如：category=”手机数码” 5）文本，例如：华为手机 6）注释，例如： 15.2.2 约束介绍 DTD ，Schema15.2.3 xml 解析：XML的实际应用场景 : 实际开发中，我们一般会使用各种各样的框架进行企业开发，而这些框架一般都会将某些公共的功能都已经写好，我们需要做的只需要按照框架提供的约束进行框架的配置就可以了，当我们使用XML配置好框架后，再运行时，框架底层会解析我们配置XML文档获取有用的信息，从而根据我们的需求实现某些功能。 所以，实际开发中我们很少会自己编写XML约束和解析XML. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141 @Test public void test1() throws DocumentException &#123; // 1. 创建一个 saxReader 解析器 SAXReader saxReader = new SAXReader(); // 2. 调用 read 方法读取 xml 配置文件, 并获取一个 document 对象 Document document = saxReader.read(\"books.xml\"); // 3. 调用 getRootElement 方法, 获取根标签对象 Element root = document.getRootElement(); // 4. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; bookElements = root.elements(); // 5. 遍历 bookElements 数组 for (Element book : bookElements) &#123; // 6. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String author = book.attributeValue(\"author\"); System.out.println(\"author = \" + author); // 7. 获取子标签 List&lt;Element&gt; elements = book.elements(); // 8. 遍历子标签 for (Element e : elements) &#123; // 9. 获取标签名称, 和标签体数据 String name = e.getName(); String text = e.getText(); System.out.println(name + \" = \" + text); &#125; &#125; &#125;输出结果 :author = 张三丰name = Java从入门到精通price = 98author = 灭绝师太name = Java编程思想price = 998 @Test public void test2() throws DocumentException &#123; // 1. 创建一个 saxReader 解析器 SAXReader saxReader = new SAXReader(); // 2. 调用 read 方法读取 xml 配置文件, 并获取一个 document 对象 Document document = saxReader.read(\"beans.xml\"); // 3. 调用 getRootElement 方法, 获取根标签对象 Element root = document.getRootElement(); // 4. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; beanElements = root.elements(); // 5. 调用 elements 方法, 获取子标签数组 for (Element bean : beanElements) &#123; // 6. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String id = bean.attributeValue(\"id\"); String className = bean.attributeValue(\"className\"); System.out.println(id + \" = \" + className); // 7. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; propElements = bean.elements(); // 8. 调用 propElements 方法, 获取子标签数组 for (Element prop : propElements) &#123; // 9. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String name = prop.attributeValue(\"name\"); String value = prop.attributeValue(\"value\"); System.out.println(name + \" = \" + value); &#125; &#125; &#125;输出结果 :001 = cn.itcast.bean.Userusername = ZhangSanpassword = 123456002 = cn.itcast.bean.Userusername = LiSipassword = 654321 15.3 正则表达式15.3.1 正则概念 egular Expression 正则表达式 : 在Java中, 正则主要使用在 String 类的方法参数为 regex 的名称上 String 类的三个带 regex 参数的方法 :split(String regex) 切割.matches(String regex) 匹配.replaceAll(String regex, String replacement) 替换. 15.3.2 符号介绍12345678910[] 取值的范围. 0-9 数值0到9都成立. 说明 : [0-9] 可以使用 \\d 表示1. &#123;&#125;表示前一个条件中 值 / 字符 可以出现的次数. 说明 : &#123;4,11&#125; 至少4次, 最多11次. &#123;0,1&#125;至少0次,最多一次.可以使用 ? 表示. &#123;1,&#125;至少1次,最多无限次可以使用 + 表示. &#123;0,&#125;至少0次,最多无限次.可以使用 * 表示.2. ()表示分组. 在replaceAll方法的第二个参数上可以使用 $ 符号来引用之前的分组,分组编号自动从1开始. 15.3.3 案例123456789101112131415161718192021public class ReplaceAllTest4 &#123; public static void main(String[] args) &#123; // 13311111946 -&gt; 133**1946 String phone = &quot;13311111946&quot;; /* 源数据 : 13311111946 第一部分 : 133 规则一 : 1[34578]\\d 第二部分 : 1111 规则二 : \\d&#123;4&#125; 第三部分 : 1946 规则三 : \\d&#123;4&#125; */ String result = phone.replaceAll(&quot;(1[34578]\\d)(\\d&#123;4&#125;)(\\d&#123;4&#125;)&quot;, &quot;1****3&quot;); System.out.println(&quot;result = &quot; + result); &#125;&#125;输出结果 :result = 133**1946","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"14JavaSE反射、注解、Junit","slug":"14JavaSE反射、注解、Junit","date":"2016-12-08T14:19:56.000Z","updated":"2018-08-27T02:22:59.935Z","comments":true,"path":"2016/12/08/14JavaSE反射、注解、Junit/","link":"","permalink":"htts://cocked.github.io/2016/12/08/14JavaSE反射、注解、Junit/","excerpt":"","text":"14Junit、反射、注解14.1.1 Junit的概述一般IDE都内置了junit,若需要自行下载jar包,可以访问官网,官网地址如下：http://www.junit.org 特点 方法命名规则：以test开头，使用驼峰命名法。 方法声明上：必须使用注解：@Test，必须使用public修饰符，没有返回值，方法没有参数。 运行测试方法 选中方法名：右键 –&gt; Run 测试方法名，则运行选中的测试方法比如测试方法名为testSum，则右键 --&gt; Run testSum 选中类名：右键 –&gt; Run 类名，则运行该类的所有测试方法比如类名为TestCalculte，则右键 --&gt; Run TestCalculte 选中模块名或项目名：右键 –&gt; Run ‘All Tests’，则运行整个模块中所有类的所有测试方法。 查看测试结果 绿色：表示测试通过， 红色：表示失败或出现错误， 14.1.2 常用注解 @Before：在每个测试方法之前都会运行一次 @After：在每个测试方法运行以后运行的方法 @BeforeClass：在所有的测试方法运行之前，只运行一次，而且必须用在静态方法上面。 @AfterClass：所有的测试方法运行以后，只运行一次，必须用在静态方法上面。 业务类​ 1234567891011121314151617181920- /** 业务类 */ public class Calculate &#123; /* 求a和b之和 */ public int sum(int a,int b)&#123; return a + b; &#125; /** 求a和b之差 */ public int sub(int a,int b)&#123; return a - b; &#125; &#125; ​ 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879- import org.junit.*; public class Test2 &#123; @BeforeClass public static void testBeforeClass() &#123; System.out.println(\"类加载时, 只运行一次.\"); &#125; @Before public void testBefore() &#123; System.out.println(\"测试方法运行前被执行 ...\"); &#125; @Test public void testSum() &#123; Calculator calculator = new Calculator(); int sum = calculator.sum(10, 20); System.out.println(\"sum = \" + sum); &#125; @Test public void testSub() &#123; Calculator calculator = new Calculator(); int sub = calculator.sub(100, 20); System.out.println(\"sub = \" + sub); &#125; @After public void testAfter() &#123; System.out.println(\"每个测试方法被执行后执行 ...\"); &#125; @AfterClass public static void testAfterClass() &#123; System.out.println(\"类结束前, 只执行一次.\"); &#125; &#125;输出结果 : 类加载时, 只运行一次. 测试方法运行前被执行 ... sub = 80 每个测试方法被执行后执行 ... 测试方法运行前被执行 ... sum = 30 每个测试方法被执行后执行 ... 类结束前, 只执行一次. 14.2 反射2.1 反射的基本概念反射是一种机制，利用该机制可以在程序运行过程中对类进行解剖并操作类中的方法，属性，构造方法等成员。 2.2 使用反射机制解剖类的前提必须先要获取到该类的字节码文件对象，即Class类型对象。关于Class描述字节码文件如下图所示： tips： 1）Java中使用Class类表示某个class文件. 2）任何一个class文件都是Class这个类的一个实例对象. 2.3 获取Class对象的三种方式 创建测试类： 1234567- Student public class Student &#123; // 属性 // 行为 &#125; 12345678910112.2.1 方式1：通过类名.class获取 @Test public void test1() &#123; // 方式一 : 通过类名获取 class 对象 // 格式 : 类名.class 属性 // 常用场景 : 反射获取方法时, 确定方法的形参列表类型 Class&lt;Student&gt; cls = Student.class; System.out.println(&quot;cls = &quot; + cls); &#125; 输出结果 : cls = class cn.qiezicy.test2.Student ​ 123456789101112131415161718192021222324252627282.2.2 方式2：通过Object类的成员方法getClass()方法获取 @Test public void test2() &#123; // 1. 创建一个 Student 类型的对象 Student stu = new Student(); // 2. 调用方法, 并传入 stu 对象 showInfo(stu); &#125; public void showInfo(Object obj) &#123; // 方式二 : 使用对象名调用 getClass() 方法. // 格式 : 对象名.getClass() 方法. // 使用场景 : 在方法内部, 确定传入形参的真实类型. Class&lt;?&gt; cls = obj.getClass(); System.out.println(&quot;cls = &quot; + cls); &#125; 输出结果 : cls = class cn.qiezicy.test2.Student2.2.3 方式3：通过Class.forName(&quot;全限定类名&quot;)方法获取 @Test public void test3() throws ClassNotFoundException &#123; // 方式三 : 使用 Class 调用静态方法 forName(全限定类名); 包名+类名 // 使用场景 : 加载外部的配置文件时使用 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); System.out.println(&quot;cls = &quot; + cls); &#125; 输出结果 : cls = class cn.qiezicy.test2.Student 2.3 获取Class对象的信息知道怎么获取Class对象之后，接下来就介绍几个Class类中常用的方法了。 2.3.1 Class对象相关方法 String getSimpleName(); 获得简单类名，只是类名，没有包 String getName(); 获取完整类名，包含包名+类名 T newInstance() ;创建此 Class 对象所表示的类的一个新实例。要求：类必须有public的无参数构造方法 public class TestDate { @Test public void testDate1() throws Exception { // 1. 获取 Date 表示的 Class 对象. Class&lt;?&gt; cls = Class.forName(&quot;java.util.Date&quot;); // 2. 获取简单类名 String simpleName = cls.getSimpleName(); System.out.println(&quot;simpleName = &quot; + simpleName); // 3. 获取完成名称 (包名 + 类名) String name = cls.getName(); System.out.println(&quot;name = &quot; + name); // 3. 创建一个日期对象 // cls.newInstance(); 已过时. Object obj = cls.getDeclaredConstructor().newInstance(); System.out.println(&quot;obj = &quot; + obj); } } ​​ 2.4 获取Class对象的Constructor信息一开始在阐述反射概念的时候，我们说到利用反射可以在程序运行过程中对类进行解剖并操作里面的成员。而一般常操作的成员有构造方法，成员方法，成员变量等等，那么接下来就来看看怎么利用反射来操作这些成员以及操作这些成员能干什么，先来看看怎么操作构造方法。而要通过反射操作类的构造方法，我们需要先知道一个Constructor类。 1234567891011121314151617182.4.1 Constructor类概述 Constructor是构造方法类，类中的每一个构造方法都是Constructor的对象，通过Constructor对象可以实例化对象。2.4.2 Class类中与Constructor相关方法1. Constructor getConstructor(Class... parameterTypes) 根据参数类型获取构造方法对象，只能获得public修饰的构造方法。 如果不存在对应的构造方法，则会抛出 java.lang.NoSuchMethodException 异常。2. Constructor getDeclaredConstructor(Class... parameterTypes) 根据参数类型获取构造方法对象，包括private修饰的构造方法。 如果不存在对应的构造方法，则会抛出 java.lang.NoSuchMethodException 异常。3. Constructor[] getConstructors()获取所有的public修饰的构造方法4. Constructor[] getDeclaredConstructors()获取所有构造方法，包括privat修饰的 2.4.3 Constructor类中常用方法1. T newInstance(Object... initargs)根据指定参数创建对象。2. void setAccessible(true)暴力反射，设置为可以直接访问私有类型的构造方法。 2.5 获取Class对象的Method信息操作完构造方法之后，就来看看反射怎么操作成员方法了。同样的在操作成员方法之前我们需要学习一个类：Method类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687882.5.1 Method类概述 Method是方法类，类中的每一个方法都是Method的对象，通过Method对象可以调用方法。 2.5.2 Class类中与Method相关方法1. Method getMethod(&quot;方法名&quot;, 方法的参数类型... 类型) 根据方法名和参数类型获得一个方法对象，只能是获取public修饰的2. Method getDeclaredMethod(&quot;方法名&quot;, 方法的参数类型... 类型) 根据方法名和参数类型获得一个方法对象，包括private修饰的3. Method[] getMethods() (了解) 获取所有的public修饰的成员方法，包括父类中。4. Method[] getDeclaredMethods() (了解) 获取当前类中所有的方法，包含私有的，不包括父类中。2.5.3 Method类中常用方法1. Object invoke(Object obj, Object... args) 根据参数args调用对象obj的该成员方法 如果obj=null，则表示该方法是静态方法2. void setAccessible(boolean flag) 暴力反射，设置为可以直接调用私有修饰的成员方法2.5.4 示例代码测试一 : @Test public void testMethod1() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.itcast.test2.Student&quot;); // 2. 调用 getMethod 方法 Method eat = cls.getMethod(&quot;eat&quot;, String.class); // 3. 调用 invoke 方法 Object obj = cls.getDeclaredConstructor().newInstance(); eat.invoke(obj, &quot;牛肉&quot;); &#125; 输出结果 : 正在吃牛肉测试二 : @Test public void testDeclaredMethod2() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); // 2. 调用 declaredMethod 方法 Method sleep = cls.getDeclaredMethod(&quot;fallInLove&quot;); // 3. 暴力反射 (设置可访问权限) sleep.setAccessible(true); // 4. 调用 invoke 执行 Object obj = cls.getDeclaredConstructor().newInstance(); sleep.invoke(obj); &#125; 输出结果 : 正在谈恋爱 ...测试三 : @Test public void testStaticMethod3() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); // 2. 调用 getMethod 方法 Method study = cls.getMethod(&quot;study&quot;); // 3. 调用 invoke 方法 study.invoke(null); &#125; 输出结果 : 正在学习中 ...测试四 : @Test public void tesMethods4() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); // 2. 调用 getMethods 方法 Method[] methods = cls.getMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125;测试五 : @Test public void tesDelcaredMethods5() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); // 2. 调用 getDeclaredMethods 方法 Method[] methods = cls.getDeclaredMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125; 2.6 获取Class对象的Field信息(了解)2.6.1 Field类概述 Field是属性类，类中的每一个属性(成员变量)都是Field的对象，通过Field对象可以给对应的成员变量赋值和取值。 2.6.2 Class类中与Field相关方法 Field getDeclaredField(String name)根据属性名获得属性对象，包括private修饰的 Field getField(String name)根据属性名获得属性对象，只能获取public修饰的 Field[] getFields()获取所有的public修饰的属性对象，返回数组。 Field[] getDeclaredFields()获取所有的属性对象，包括private修饰的，返回数组。 2.6.3 Field类中常用方法 void set(Object obj, Object value) Object get(Object obj) void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。 Class getType(); 获取属性的类型，返回Class对象。 2.6.4 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263测试一 : @Test public void testField1() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(\"cn.itcast.test2.Student\"); // 2. 调用 getField 方法 Field description = cls.getField(\"description\"); // 3. 设置属性 Object obj = cls.getDeclaredConstructor().newInstance(); description.set(obj, \"这就是那个神奇的学生.\"); // 4. 获取属性 Object desc = description.get(obj); System.out.println(\"desc = \" + desc); &#125; 输出结果 : desc = 这就是那个神奇的学生.测试二 : @Test public void testDeclaredField2() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(\"cn.qiezicy.test2.Student\"); // 2. 调用 getDeclaredField 方法 Field name = cls.getDeclaredField(\"name\"); // 3. 暴力反射 name.setAccessible(true); // 4. 设置属性 Object obj = cls.getDeclaredConstructor().newInstance(); name.set(obj, \"111\"); // 5. 查看 System.out.println(obj); &#125; 输出结果 : Student&#123;name='111', age=0, gender= &#125;测试三 : @Test public void testFields3() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(\"cn.qiezicy.test2.Student\"); // 2. 调用 getFields 方法 Field[] fields = cls.getFields(); // 3. 遍历 fields 数组 for (Field field : fields) &#123; System.out.println(field); &#125; &#125; 输出结果 : public java.lang.String cn.qiezicy.test2.Student.description测试四 : @Test public void testDeclaredFields4() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(\"cn.qiezicy.test2.Student\"); // 2. 调用 getDeclaredFields 方法 Field[] fields = cls.getDeclaredFields(); // 3. 遍历 fields 数组 for (Field field : fields) &#123; System.out.println(field); &#125; &#125; 2.7 反射案例编写一个工厂方法可以根据配置文件产任意类型的对象。 例如有配置文件stu.properties，存储在当前项目下，内容如下：​ 1234 className=cn.qiezicy.reflect.Student name=rose age=18 gender=女 ​ 根据配置文件信息创建一个学生对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081- Student 类 : public class Student &#123; // 属性 private String name; private int age; private char gender; // 公开构造方法 : public Student(String name, int age, char gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; // 公开无参构造方法 public Student() &#123; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", gender=\" + gender + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getGender() &#123; return gender; &#125; public void setGender(char gender) &#123; this.gender = gender; &#125; &#125; CreateObject 类 : import java.io.FileReader; import java.io.IOException; import java.lang.reflect.Field; import java.util.Properties; import java.util.Set; public class CreateObject { // 属性 private static Properties prop; // 静态方法 : 加载配置文件 static { // 初始化 : prop = new Properties(); try { prop.load(new FileReader(&quot;stu.properties&quot;)); } catch (IOException e) { // e.printStackTrace(); throw new RuntimeException(&quot;配置文件加载失败!&quot;); } } // 方法 : 根据配置文件, 创建对象 public static Object createObject() throws Exception { // 1. 获取 class 名称 String className = prop.getProperty(&quot;className&quot;); // 2. 获取 class 对象 Class&lt;?&gt; cls = Class.forName(className); // 3. 创建一个 cls 表示的对象 Object obj = cls.getDeclaredConstructor().newInstance(); // 4. 获取属性集对象的所有 键集 Set&lt;String&gt; keys = prop.stringPropertyNames(); // 5. 遍历 for (String key : keys) { // 判断 : if (&quot;class&quot;.equals(key)) continue; // 6. 根据 key 获取对应的 value String value = prop.getProperty(key); // 7. 获取所有的 fields 数组 Field field = cls.getDeclaredField(key); // 8. 设置访问权限 field.setAccessible(true); // 9. 获取属性的类型 Class&lt;?&gt; type = field.getType(); // 10. 判断类型 if (type == int.class) { int v = Integer.parseInt(value); // 设置属性 field.set(obj, v); } else if (type == char.class) { char c = value.charAt(0); // 设置属性 field.set(obj, c); } else { field.set(obj, value); } } // 11. 返回对象 return obj; } } 测试类 : public class Test { public static void main(String[] args) throws Exception { Object obj = CreateObject.createObject(); System.out.println(&quot;obj = &quot; + obj); } } 输出结果 : obj = Student{name=&apos;rose&apos;, age=18, gender=女} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426 # 14.3 注解## 3.1 注解的概述3.1.1 注解的概念- 注解是JDK1.5的特性。- 注解相当一种标记，是类的组成部分，可以给类携带一些额外的信息。- 标记(注解)可以加在包，类，字段，方法，方法参数以及局部变量上。- 注解是给编译器或JVM看的，编译器或JVM可以根据注解来完成对应的功能。 注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。3.1.2 注解的作用 注解的作用就是给程序带入参数。以下几个常用操作中都使用到了注解：1. 生成帮助文档：@author和@version- @author：用来标识作者姓名。- @version：用于标识对象的版本号，适用范围：文件、类、方法。- 使用@author和@version注解就是告诉Javadoc工具在生成帮助文档时把作者姓名和版本号也标记在文档中。如下图：1. 编译检查：@Override- @Override：用来修饰方法声明。- 用来告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。如下图1. 框架的配置(框架=代码+配置)- 具体使用请关注框架课程的内容的学习。3.1.3 常见注解1. @author：用来标识作者名。2. @version：用于标识对象的版本号。3. @Override ：用来修饰方法声明，告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。4. @Deprecated: 用来表示不赞成使用.## 3.2 自定义注解3.2.1 定义格式 public @interface 注解名 &#123; &#125; 如：定义一个名为 Student 的注解 public @interface Student &#123; &#125;- 以上定义出来的注解就是一个最简单的注解了，但这样的注解意义不大，因为注解中没有任何内容，就好像我们定义一个类而这个类中没有任何成员变量和方法一样，这样的类意义也是不大的，所以在定义注解时会在里面添加一些成员来让注解功能更加强大，这些成员就是属性。接下来就看看怎么给注解添加属性。3.2.2 注解的属性1. 属性的作用- 可以让用户在使用注解时传递参数，让注解的功能更加强大。1. 属性的格式- 格式1：数据类型 属性名();- 格式2：数据类型 属性名() default 默认值;1. 属性定义示例 // 该注解拥有三个属性 (name, age, gender) public @interface Student &#123; String name(); int age() default 18; char gender() default &apos;男&apos;; &#125;1. 属性适用的数据类型- 八种基本数据类型（byte, short, int, long, float, double, char, boolean)- String类型，Class类型，枚举类型，注解类型- 以上所有类型的一维数组## 3.3 使用自定义注解3.3.1 定义注解1. 定义一个注解：Book- 包含属性：String value() 书名- 包含属性：double price() 价格，默认值为 100- 包含属性：String[] authors() 多位作者 说明 : 当注解中只有一个属性且名称是value，在使用注解时给value属性赋值可以直接给属性值，无论value是单值元素还是数组类型。1. 代码实现 public @interface Book &#123; // 书名 String value(); // 价格 int price() default 100; // 多位作者 String[] authors(); &#125; 3.3.2 使用注解2. 定义类在成员方法上使用Book注解 public class BookShelf &#123; @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;白求恩&quot;&#125;) public void show() &#123; &#125; &#125;​使用注意事项- 如果属性有默认值，则使用注解的时候，这个属性可以不用赋值。- 如果属性没有默认值，那么在使用注解时一定要给属性赋值。## 3.4 注解之元注解3.4.1 元注解的概述- Java API 提供的注解- 专门用来定义注解的注解。- 任何 Java 官方提供的非元注解的定义中都使用到了元注解。 3.4.2 常用元注解- @Target 注释的使用位置.- @Retention 注解的声明周期. 3.4.2.1 元注解之@Target- 作用：指明此注解用在哪个位置，如果不写默认是任何地方都可以使用。- 可选的参数值在枚举类ElemenetType中包括： TYPE： 用在类,接口上 FIELD：用在成员变量上 METHOD： 用在方法上 PARAMETER：用在参数上 CONSTRUCTOR：用在构造方法上 LOCAL_VARIABLE：用在局部变量上 3.4.2.2 元注解之@Retention- 作用：定义该注解的生命周期(有效范围)。- 可选的参数值在枚举类型RetentionPolicy中包括 SOURCE：注解只存在于Java源代码中，编译生成的字节码文件中就不存在了。 CLASS：注解存在于Java源代码、编译以后的字节码文件中，运行的时候内存中没有，默认值。 RUNTIME：注解存在于Java源代码中、编译以后的字节码文件中、运行时内存中，程序可以通过反射获取该注解。3.4.3 元注解使用示例 // (书名, 价格, 作者) import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // 元注解 : Target 目标 (注解使用的位置) @Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) // 元注解 : Retention 保留策略 (SOURCE, CLASS, RUNTIME) @Retention(RetentionPolicy.RUNTIME) public @interface Book &#123; String value(); // 说明 : 如果注解只有一个属性, 最好取名为 value, 因为书写时, 可以省略. int price() default 100; String[] authors(); // 多位作者 &#125;​​​BookShelf 类​ @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;xxx&quot;&#125;) public class BookShelf &#123; // 属性 // @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;xxx&quot;&#125;) private int id; @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;xxx&quot;&#125;) public void show() &#123; String value = &quot;&quot;; int price = 0; String[] authors = &#123;&#125;; System.out.println(&quot;书名为 : &quot; + value); System.out.println(&quot;价格为 : &quot; + price); System.out.println(&quot;作者为 : &quot; + Arrays.toString(authors)); &#125; &#125;​​​## 3.5 注解解析3.5.1 什么是注解解析- 通过Java技术获取注解数据的过程则称为注解解析。3.5.2 与注解解析相关的接口- Anontation：所有注解类型的公共接口，类似所有类的父类是Object。- AnnotatedElement：定义了与注解解析相关的方法，常用方法： boolean isAnnotationPresent(Class annotationClass); 判断当前对象是否有指定的注解，有则返回true，否则返回false。 T getAnnotation(Class&lt;T&gt; annotationClass); 获得当前对象上指定的注解对象。3.5.3 获取注解数据的原理- 注解作用在那个成员上，就通过反射获得该成员的对象(Filed)来得到它的注解。- 如注解作用在方法上，就通过方法(Method)对象得到它的注解*- 如注解作用在类上，就通过Class对象得到它的注解3.5.4 使用反射获取注解的数据3.5.4.1 需求说明1. 定义注解Book，要求如下：- 包含属性：String value() 书名- 包含属性：double price() 价格，默认值为 100- 包含属性：String[] authors() 多位作者 - 限制注解使用的位置：类和成员方法上- 指定注解的有效范围：RUNTIME1. 定义BookStore类，在类和成员方法上使用Book注解2. 定义TestAnnotation测试类获取Book注解上的数据3.5.4.2 代码实现1.注解Book import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) public @interface Book &#123; // 书名 String value(); // 价格 int price() default 100; // 作者 (多位作者) String[] authors(); &#125;​2.BookShelf 类​ import java.lang.reflect.Method; import java.util.Arrays; @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;白求恩&quot;&#125;) public class BookShelf &#123; // 属性 // @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;白求恩&quot;&#125;) private int id; @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;白求恩&quot;&#125;) public void show() &#123; // 定义变量 String value = &quot;&quot;; int price = 0; String[] authors = &#123;&#125;; // 获取当前类的 Class 对象 Class&lt;? extends BookShelf&gt; cls = this.getClass(); try &#123; // 获取当前方法对象 Method show = cls.getMethod(&quot;show&quot;); // 判断当前方法上是否有注解信息 if (show.isAnnotationPresent(Book.class)) &#123; // 条件成立, 获取到当前注解对象 Book book = show.getAnnotation(Book.class); // 取出信息, 并实现赋值 value = book.value(); price = book.price(); authors = book.authors(); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; // 输出查看 System.out.println(&quot;书名为 : &quot; + value); System.out.println(&quot;价格为 : &quot; + price); System.out.println(&quot;作者为 : &quot; + Arrays.toString(authors)); &#125; &#125;​3.TestBookShelf 类​ public class TestBookShelf &#123; public static void main(String[] args) &#123; BookShelf bookShelf = new BookShelf(); bookShelf.show(); &#125; &#125; 输出结果 : 书名为 : 西游记 价格为 : 998 作者为 : [吴承恩, 白求恩] 书名为 : 价格为 : 0 作者为 : []​​​补充 : 解析类上的注解​ import java.util.Arrays; public class TestBookShelf2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 1. 获取类 Class&lt;?&gt; cls = Class.forName(&quot;cn.itcast.annotation.BookShelf&quot;); // 2. 判断该类上是否有 Book 注解信息 if (cls.isAnnotationPresent(Book.class)) &#123; // 3. 获取 Book 注解对象 Book book = cls.getAnnotation(Book.class); // 4. 取出注解信息 String value = book.value(); int price = book.price(); String[] authors = book.authors(); // 5. 输出查看 System.out.println(&quot;value = &quot; + value); System.out.println(&quot;price = &quot; + price); System.out.println(&quot;authors = &quot; + Arrays.toString(authors)); &#125; &#125; &#125; 输出结果 : value = 西游记 price = 998 authors = [吴承恩, 白求恩]## 3.6 注解案例3.5.1 案例说明 模拟Junit测试的@Test3.5.2 案例分析1. 模拟Junit测试的注释@Test，首先需要编写自定义注解@MyTest，并添加元注解，保证自定义注解只能修饰方法，且在运行时可以获得。2. 然后编写目标类（测试类），然后给目标方法（测试方法）使用 @MyTest注解，编写三个方法，其中两个加上@MyTest注解。3. 最后编写调用类，使用main方法调用目标类，模拟Junit的运行，只要有@MyTest注释的方法都会运行。 3.5.3 案例代码4. 注解MyTest ​ import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyTest &#123; &#125;​1. 目标类MyTestClass ​ public class MyTestClass &#123; @MyTest public void test01() &#123; System.out.println(&quot;测试方法一被执行 ...&quot;); &#125; public void test02() &#123; System.out.println(&quot;测试方法二被执行 ...&quot;); &#125; @MyTest public void test03() &#123; System.out.println(&quot;测试方法三被执行 ...&quot;); &#125; &#125;​1. 调用类ParseAnnotation ​ import java.lang.reflect.Method; // 解析注解类 : public class ParseAnnotation &#123; public static void main(String[] args) throws Exception &#123; // 1. 获取 MyTestClass 的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.practice.MyTestClass&quot;); Object obj = cls.getDeclaredConstructor().newInstance(); // 2. 调用 getMethods 获取所有方法 Method[] methods = cls.getMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; // 4. 判断当前方法上是否存在 MyTest 注解 if (method.isAnnotationPresent(MyTest.class)) &#123; // 5. 执行当前方法 method.invoke(obj); &#125; &#125; &#125; &#125; 输出结果 : 测试方法一被执行 ... 测试方法三被执行 ...","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"13JavaSE函数式编程&Stream流","slug":"13JavaSE函数式编程-Stream流","date":"2016-12-04T11:10:08.000Z","updated":"2018-08-27T02:22:54.653Z","comments":true,"path":"2016/12/04/13JavaSE函数式编程-Stream流/","link":"","permalink":"htts://cocked.github.io/2016/12/04/13JavaSE函数式编程-Stream流/","excerpt":"","text":"13.1常用的函数式接口总结 接口名称 方法名称 抽象/默认 延迟/终结 方法描述 Supplier get 抽象 终结 供给型接口，无参有返回值，主要用于 Consumer accept 抽象 终结 消费型接口，有参数无返回值 andThen 默认 延迟 Function apply 抽象 终结 函数型接口，有参数有返回值 andThen 默认 延迟 compose 默认 延迟 Predicate test 抽象 终结 断言型接口，元芳你怎么看 and 默认 延迟 or 默认 延迟 negate 默认 延迟 notes： 延迟方法：只是在拼接Lambda函数模型的方法，并不立即执行得到结果。 终结方法：根据拼好的Lambda函数模型，立即执行得到结果值的方法。 13.2 Stream流13.2.1 获取流的三种方式1234567891011121314151617public static void main(String[] args) &#123; // Collection 集合 Collection c = new ArrayList&lt;String&gt;(); Stream stream1 = c.stream(); System.out.println(\"stream1 = \" + stream1); // List 集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream2 = list.stream(); System.out.println(\"stream2 = \" + stream2); // Set 集合 HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); Stream&lt;String&gt; stream3 = set.stream(); System.out.println(\"stream3 = \" + stream3);&#125; Map集合 1234567891011121314151617public static void main(String[] args) &#123; // Map 集合 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 获取流 // 1. keySet Stream&lt;String&gt; stream1 = map.keySet().stream(); // 2. values Stream&lt;Integer&gt; stream2 = map.values().stream(); // 3. entrySet Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream3 = map.entrySet().stream(); System.out.println(\"stream1 = \" + stream1); System.out.println(\"stream2 = \" + stream2); System.out.println(\"stream3 = \" + stream3);&#125; 13.2.2 流的常用方法** 终结方法**：返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用。本小节中，终结方法包括count和forEach方法。 非终结方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。） 终结方法：逐一处理：forEach，统计个数：count 非终结方法：过滤：filter，取用前几个：limit，跳过前几个：skip，映射：map 组合： 使用Stream接口的静态方法concat 方法名 方法作用 方法种类 是否支持链式调用 count 统计个数 终结 否 forEach 逐一处理 终结 否 filter 过滤 函数拼接 是 limit 取用前几个 函数拼接 是 skip 跳过前几个 函数拼接 是 map 映射 函数拼接 是 concat 组合 函数拼接 是 并发流： 1234567891011121314151617181920转换为并发流 1. Stream的父接口java.util.stream.BaseStream中定义了一个parallel方法： 2.在通过集合获取流时，也可以直接调用parallelStream方法来直接获取支持并发操作的流 default Stream&lt;E&gt; parallelStream() &#123;... 收集集合三种： 收集到集合中 Stream流提供collect方法，其参数需要一个java.util.stream.Collector&lt;T,A, R&gt;接口对象来指定收集到哪种集合中。幸运的是，java.util.stream.Collectors类提供一些方法，可以作为Collector接口的实例：- public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()：转换为List集合。- public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()：转换为Set集合。 收集到数组中 Stream提供toArray方法来将结果放到一个数组中，由于泛型擦除的原因，返回值类型是Object[]的： 扩展：解决泛型数组问题有了Lambda和方法引用之后，可以使用toArray方法的另一种重载形式传递一个IntFunction&lt;A[]&gt;的函数，继而从外面指定泛型参数。方法签名： &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);有了它，上例代码中不再局限于Object[]结果，而可以得到String[]结果","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"11Java网络编程","slug":"11Java网络编程","date":"2016-11-28T12:30:18.000Z","updated":"2018-08-27T02:22:44.139Z","comments":true,"path":"2016/11/28/11Java网络编程/","link":"","permalink":"htts://cocked.github.io/2016/11/28/11Java网络编程/","excerpt":"","text":"第一章 网络编程入门1.1软件结构C/S结构：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络通信协议 网络通信协议：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守，最终完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 1.3 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。 1.4 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。有资料显示，全球IPv4地址在2011年2月分配完毕。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 被称为 本机回环地址. ​ 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 第二章 TCP通信程序2.1 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： 1Socket client = new Socket(\"127.0.0.1\", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类 ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 2.4 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动, 等待连接 ...\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取 socket 通道输入流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // 4. 解析数据 String str = new String(buf, 0, len); System.out.println(\"服务端读取的数据为 : \" + str); &#125; // 5. 关闭资源 serverSocket.close(); System.out.println(\"服务端关闭, 结束连接.\"); &#125;&#125;输出结果 :服务端启动, 等待连接 ...服务端读取的数据为 : 在吗?服务端关闭, 结束连接. 客户端实现： 1234567891011121314151617181920import java.io.IOException;import java.io.OutputStream;import java.net.Socket;public class ClientTCP &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字, 尝试连接服务器 Socket socket = new Socket(\"127.0.0.1\", 8888); // 2. 获取 socket 通道输出流 OutputStream out = socket.getOutputStream(); // 3. 输出数据 out.write(\"在吗?\".getBytes()); // 4. 关闭资源 socket.close(); &#125;&#125; 服务器向客户端回写数据服务端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动, 等待连接 ...\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取 socket 通道输入流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // 4. 解析数据 String str = new String(buf, 0, len); System.out.println(\"服务端读取的数据为 : \" + str); &#125; /*************** 服务端实现数据回写 ****************/ // 5. 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 6. 回写数据 out.write(\"在\".getBytes()); // 注意 : 需要调用 socket.shutdown(); 方法, 向 socket 通道中写出结束符 socket.shutdownOutput(); // 7. 关闭资源 serverSocket.close(); System.out.println(\"服务端关闭, 结束连接.\"); &#125;&#125;输出结果 :服务端启动, 等待连接 ...服务端读取的数据为 :在吗?服务端关闭, 结束连接. 客户端实现： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class ClientTCP &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字, 尝试连接服务器 Socket socket = new Socket(\"127.0.0.1\", 8888); // 2. 获取 socket 通道输出流 OutputStream out = socket.getOutputStream(); // 3. 输出数据 out.write(\"在吗?\".getBytes()); // 注意 : 需要调用 socket.shutdown(); 方法, 向 socket 通道中写出结束符 socket.shutdownOutput(); /*************** 客户端解析回写数据 ****************/ // 4. 获取 socket 通道的输入流 InputStream in = socket.getInputStream(); // 5. 读取, 并解析回写数据 byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; String str = new String(buf, 0, len); System.out.println(\"客户端读写服务端的回写数据为 : \" + str); &#125; // 6. 关闭资源 socket.close(); &#125;&#125;输出结果 :客户端读写服务端的回写数据为 : 在 第三章 综合案例3.1 文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 基本实现服务端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端已启动, 等待客户端连接.\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File(\"D:/upload\"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 String ip = socket.getInetAddress().getHostAddress(); File file = new File(parentFile, ip + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write(\"上传成功!\".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); // 6. 关闭资源 serverSocket.close(); System.out.println(\"文件保存成功!\"); &#125;&#125;输出结果 :服务端已启动, 等待客户端连接.文件保存成功! 客户端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.net.Socket;public class FileUploadClient &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字对象, 尝试连接服务端 Socket socket = new Socket(\"127.0.0.1\", 8888); // 2. 复制文件 (先读后写) // 2.1 创建一个高效的字节缓冲输入流, 关联硬盘路径文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"D:/柳岩.jpg\")); // 2.2 创建一个高效的字节缓冲输出流, 关联 socket 通道输出流 BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); // 3. 读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 注意 : 向通道中写入一个结束符 socket.shutdownOutput(); // 4. 读取服务端的反馈信息 // 4.1 获取 socket 通道的输入流 InputStream in = socket.getInputStream(); byte[] readBuf = new byte[1024]; int readLen = -1; while ((readLen = in.read(readBuf)) != -1) &#123; String str = new String(readBuf, 0, readLen); System.out.println(str); &#125; // 5. 关闭资源 socket.close(); &#125;&#125;输出结果 :上传成功! 文件上传优化分析 :问题1 : 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+\".jpg\") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 使用 UUID 类解决图片名称的问题 : 1234for (int i = 0; i &lt; 10; i++) &#123; String name = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); System.out.println(name + \".jpg\");&#125; 输出结果 : 12345678910345154742a884d0c8d38a981b06d0f51.jpg828cade0a69b485983efa2efb6c2edf8.jpg2522a1462142450195a32997aa00968b.jpg0fb24406d79b40dcbefdd99298224d8f.jpg8d9f7ed4cf12430ba4b9904bc17541a3.jpg558fc7d91f614ae6845958cc81f9cfb6.jpg5ede501fbd624f9d8d021f582da73219.jpg5b51a105b3cf473ba0e2751029411ec9.jpg42ea3479a85b4c7db915335302661515.jpg89e58cb12a014c5faa83b6bb99a33ca6.jpg 问题2 : 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 问题3 : 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现 : 实现类完成123456789101112131415161718192021222324252627282930313233343536import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端已启动, 等待客户端连接.\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 UploadTask uploadTask = new UploadTask(socket); new Thread(uploadTask, \"上传线程\").start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125;输出结果 :服务端已启动, 等待客户端连接.文件保存成功!文件保存成功! 实现类 : UploadTask 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.*;import java.net.Socket;public class UploadTask implements Runnable &#123; // 属性 private Socket socket; // 构造方法 public UploadTask(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File(\"D:/upload\"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write(\"上传成功!\".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"文件保存成功!\"); &#125;&#125; 匿名内部类实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端已启动, 等待客户端连接.\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File(\"D:/upload\"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write(\"上传成功!\".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"文件保存成功!\"); &#125; &#125;, \"上传线程\").start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125; Lambda 表达式实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端已启动, 等待客户端连接.\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 new Thread(() -&gt; &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File(\"D:/upload\"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write(\"上传成功!\".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"文件保存成功!\"); &#125;).start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125; 3.2 模拟服务器模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 准备页面数据，web文件夹。 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910111213141516171819202122232425import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个服务端套接字对象, 绑定端口号为 8888 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取通道输出流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String str = new String(buf, 0, len); System.out.println(str); // 4. 关闭服务端套接字 serverSocket.close(); &#125;&#125; 返回数据内容 : 1234567GET / HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299Accept-Encoding: gzip, deflateHost: localhost:8888Connection: Keep-Alive 返回数据内容 : 1234567GET /web/index.html HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299Accept-Encoding: gzip, deflateHost: localhost:8888Connection: Keep-Alive GET /web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个服务端套接字对象, 绑定端口号为 8888 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取通道输出流, 读取数据 InputStream in = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); // 读取数据的第一行 String line = reader.readLine(); System.out.println(\"line = \" + line); // GET /web/index.html HTTP/1.1 // 切割字符 String[] split = line.split(\" \"); // 取出需要的一部分 String path = split[1].substring(1); System.out.println(\"path = \" + path); // 4. 关闭服务端套接字 serverSocket.close(); &#125;&#125;输出结果如下 :line = GET /web/index.html HTTP/1.1path = web/index.html","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"10JavaSE缓冲流、转换流、序列化流、Files","slug":"10JavaSE缓冲流、转换流、序列化流、Files","date":"2016-11-28T00:04:33.000Z","updated":"2018-08-27T02:22:39.100Z","comments":true,"path":"2016/11/28/10JavaSE缓冲流、转换流、序列化流、Files/","link":"","permalink":"htts://cocked.github.io/2016/11/28/10JavaSE缓冲流、转换流、序列化流、Files/","excerpt":"","text":"第一章 属性集1.1 概述java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 1.2 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Properties;import java.util.Set;public class PropertiesTest1 &#123; public static void main(String[] args) &#123; // 1. 创建属性集对象 Properties prop = new Properties(); // 2. 添加键值对元素 prop.setProperty(\"filename\", \"a.txt\"); prop.setProperty(\"length\", \"1024\"); prop.setProperty(\"location\", \"D:/a.txt\"); // 3. 打印属性集对象 System.out.println(\"prop = \" + prop); // 4. 通过键,获取属性值 String filename = prop.getProperty(\"filename\"); String length = prop.getProperty(\"length\"); String location = prop.getProperty(\"location\"); System.out.println(\"filename = \" + filename); System.out.println(\"length = \" + length); System.out.println(\"location = \" + location); // 5. 遍历属性集,获取所有键的集合 Set&lt;String&gt; keys = prop.stringPropertyNames(); System.out.println(\"--------------\"); // 6. 打印键值对 for (String key : keys) &#123; String value = prop.getProperty(key); System.out.println(key + \" = \" + value); &#125; &#125;&#125;输出结果：prop = &#123;filename=a.txt, length=1024, location=D:/a.txt&#125;filename = a.txtlength = 1024location = D:/a.txt--------------filename = a.txtlength = 1024location = D:/a.txt 与流相关的方法 public void load(InputStream inStream)： 从字节输入流中读取键值对。 参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式: 123filename=a.txtlength=209385038location=D:\\\\a.txt 加载代码演示： 123456789101112131415161718192021222324252627import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;import java.util.Set;public class PropertiesTest2 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个属性集对象 Properties prop = new Properties(); // 2. 加载数据到 prop 对象中 prop.load(new FileInputStream(\"a.txt\")); // 3. 获取所有的 key, 然后实现遍历 Set&lt;String&gt; keys = prop.stringPropertyNames(); for (String key : keys) &#123; String value = prop.getProperty(key); System.out.println(key + \" = \" + value); &#125; &#125;&#125;输出结果：filename = a.txtlength = 209385038location = D:\\a.txt 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。 第二章 转换流2.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集 字符集 Charset：是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 2.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 12345678910111213141516171819202122232425262728import java.io.FileReader;import java.io.IOException;public class Test1 &#123; public static void main(String[] args) throws IOException &#123; // FileReader reader = new FileReader(\"a.txt\"); FileReader reader = new FileReader(\"D:/a.txt\"); int read = -1; while ((read = reader.read()) != -1) &#123; System.out.println((char) read); &#125; reader.close(); &#125;&#125;输出结果：�������Ա. 那么如何读取GBK编码的文件呢？ 2.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\"); 指定编码读取12345678910111213141516171819202122232425262728293031323334353637import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class Test3 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符转换流对象 (默认为项目编码 UTF-8) InputStreamReader reader1 = new InputStreamReader(new FileInputStream(\"D:/a.txt\")); // 2. 创建一个字符转换流对象 (指定编码为 GBK) InputStreamReader reader2 = new InputStreamReader(new FileInputStream(\"D:/a.txt\"), \"GBK\"); // 读取数据 int read = -1; while ((read = reader1.read()) != -1) &#123; System.out.print((char)read); &#125; System.out.println(); System.out.println(\"-------------\"); read = -1; while ((read = reader2.read()) != -1) &#123; System.out.print((char) read); &#125; // 关闭资源 reader2.close(); reader1.close(); &#125;&#125;输出结果 :�Ұ��Ϻ�������.-------------爱尔兰大白鲨 2.4 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\"); 指定编码写出12345678910111213141516171819202122import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符转换流对象 (默认编码: UTF-8) OutputStreamWriter writer1 = new OutputStreamWriter(new FileOutputStream(\"D:/b.txt\")); // 2. 创建一个字符转换流对象 (执行编码: GBK) OutputStreamWriter writer2 = new OutputStreamWriter(new FileOutputStream(\"D:/c.txt\"), \"GBK\"); // 3. 写入数据 writer1.write(\"爱尔兰大白鲨.\"); // b.txt 22个字节 writer2.write(\"爱尔兰大白鲨.\"); // c.txt 15个字节 // 4. 关闭资源 writer2.close(); writer1.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 2.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现1234567891011121314151617181920212223import java.io.*;public class Test5 &#123; public static void main(String[] args) throws IOException &#123; // 1. 使用 GBK 编码读取 Windows 系统上创建的文件 InputStreamReader reader = new InputStreamReader(new FileInputStream(\"D:/a.txt\"), \"GBK\"); // 2. 创建一个 UTF-8 编码的写入字符转换流, 按照指定编码格式将读取的数据重新写入到文件中 OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"D:/aa.txt\"), \"UTF-8\"); int read = -1; while ((read = reader.read()) != -1) &#123; // 写入 writer.write(read); // System.out.println((char) read); &#125; writer.close(); reader.close(); &#125;&#125; 第三章 序列化3.1 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的数据等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。 3.2 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream(\"employee.txt\");ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 条件一 : 序列化接口 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 条件二 : 序列版本号 格式 : private static final long serialVersionUID = 1L; Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 如此，当JVM反序列化对象时，能找到class文件，如果class文件在序列化对象之后发生了修改，那么反序列化操作也不会失败，如果没有序列化版本号, 则反序列化会抛出一个InvalidClassException异常。 Employee 类定义 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.Serializable;public class Employee implements Serializable &#123; // 需要为序列化的类添加一个 `序列版本号` 属性 private static final long serialVersionUID = 1L; // 属性 private String name; private String address; private transient int age; // 被 transient 修饰的属性不参与序列化 @Override public String toString() &#123; return \"Employee&#123;\" + \"name='\" + name + '\\'' + \", address='\" + address + '\\'' + \", age=\" + age + '&#125;'; &#125; // 行为 public void checkAddress() &#123; System.out.println(name + \" = \" + address); &#125; public Employee(String name, String address, int age) &#123; this.name = name; this.address = address; this.age = age; &#125; public Employee() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 1234567891011121314151617181920212223242526272829import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class ObjectOutputStreamTest &#123; public static void main(String[] args) &#123; // 序列化 : 将一个Java对象存储到文件中. // 1. 创建一个 Employee 对象, 并初始化数值 Employee emp = new Employee(\"张三\", \"爱尔兰大白鲨\", 30); // 2. 创建一个对象输出流 try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"D:/emp.txt\"))) &#123; oos.writeObject(emp); &#125; catch (IOException e) &#123; // e.printStackTrace(); // 将一个编译时期的异常转换为运行时期的异常抛出. throw new RuntimeException(\"序列化对象失败.\"); &#125; System.out.println(\"序列化成功!\"); &#125;&#125;输出结果：序列化成功! 3.3 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728293031import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class ObjectInputStreamTest &#123; public static void main(String[] args) &#123; // 反序列化 : 将文件中的数据读取为一个 Java 对象 // 1. 创建一个对象读取流 try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"D:/emp.txt\"))) &#123; // 2. 读取文件中的数据为 Java 对象 Object obj = ois.readObject(); System.out.println(obj); // 3. 将 obj 类型强转为 Employee 类型, 并实现方法的调用 Employee emp = (Employee) obj; emp.checkAddress(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;输出结果 :Employee&#123;name='张三', address='爱尔兰大白鲨', age=0&#125;张三 = 爱尔兰大白鲨 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 第四章 打印流4.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 4.2 PrintStream类构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： 1PrintStream ps = new PrintStream(\"ps.txt\")； 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。 12345678910111213141516import java.io.FileNotFoundException;import java.io.PrintStream;public class PrintStreamTest &#123; public static void main(String[] args) throws FileNotFoundException &#123; PrintStream ps = new PrintStream(\"D:/ps.txt\"); // 技巧 : 设置系统的打印流方向 System.setOut(ps); // 输出数据 System.out.println(\"Who are you？\"); System.out.println(\"你是谁？\"); &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"09JavaSE字节流与字符流","slug":"09JavaSE字节流与字符流","date":"2016-11-26T12:03:53.000Z","updated":"2018-08-27T02:22:33.754Z","comments":true,"path":"2016/11/26/09JavaSE字节流与字符流/","link":"","permalink":"htts://cocked.github.io/2016/11/26/09JavaSE字节流与字符流/","excerpt":"","text":"一、IO概述1.1 什么是IO Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 1.2 IO的分类 根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 1.3 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 二、 字节流2.1 一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 2.2 字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.3 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 数据追加续写 public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 写出换行Windows系统里，换行符号是\\r\\n 。把 以指定是否追加续写了，代码使用演示： 回车符\\r和换行符\\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n； Unix系统里，每行结尾只有 换行 ，即\\n； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 2.4 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 2.5 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 三、 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 3.1 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 3.2 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public abstract void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public abstract void flush() ：刷新此输出流并强制任何缓冲的输出字符被写出。 public void write(int c) ：写出一个字符。 public void write(char[] cbuf)：将 b.length字符从指定的字符数组写出此输出流。 public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。 public void write(String str) ：写出一个字符串。 3.4 续写和换行与读取：字符缓冲流代码演示 : 1234// 创建字节缓冲输入流BufferedReader br = new BufferedReader(new FileReader(\"br.txt\", true));// 创建字节缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\", true)); 特有方法 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 notes：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 四、 IO异常的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用 try...catch...finally 代码块，处理异常部分，代码使用演示： 123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class Test6 &#123; public static void main(String[] args) &#123; // 1. 定义一个 writer 对象 BufferedWriter writer = null; try &#123; // 2. 初始化 writer 对象 writer = new BufferedWriter(new FileWriter(\"d.txt\")); // 写入三部曲 : writer.write(\"茄子创意\"); writer.newLine(); writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 关闭 writer 对象 if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;写入结果 :茄子创意 JDK7的处理还可以使用JDK7优化后的try-with-resources 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 1234567891011121314151617181920212223import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class Test6 &#123; public static void main(String[] args) &#123; // () 括号中解决的是 `流` 资源关闭的问题. try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"d.txt\"))) &#123; // 写入三部曲 : writer.write(\"茄子创意\"); writer.newLine(); writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;写出结果 :茄子创意 JDK9的改进(了解内容)JDK9中try-with-resources 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。 改进前格式： 12345678910111213141516171819202122import java.io.*;public class Test7 &#123; public static void main(String[] args) &#123; // () 小括号中定义需要释放的资源对象. try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"D:/1.jpg\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"1.jpg\"))) &#123; // 读写操作 : byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 改进后格式： 123456789101112131415161718192021222324import java.io.*;public class Test7 &#123; public static void main(String[] args) throws FileNotFoundException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"D:/1.jpg\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"1.jpg\")); // () 小括号中定义需要释放的资源对象. try (bis; bos) &#123; // 读写操作 : byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"03JavaSE异常处理","slug":"03JavaSE异常处理","date":"2016-11-01T12:00:59.000Z","updated":"2018-08-27T02:22:23.992Z","comments":true,"path":"2016/11/01/03JavaSE异常处理/","link":"","permalink":"htts://cocked.github.io/2016/11/01/03JavaSE异常处理/","excerpt":"","text":"一、 异常概念总结：练习一：异常的体系 问题： 请描述异常的继承体系 2.请描述你对错误(Error)的理解 3.请描述你对异常(Expection的理解) 4.请描述你对运行时异常(RuntimeException)的理解 答： 异常继承体系为：异常的根类是 java.lang.Throwable，其下有两个子类： java.lang.Error 与 java.util.Exception 。而Exception又分为编译时期异常：checked异常，与运行时期异常：runtime异常。 Error:表示不可修复的恶性的错误，只能通过修改代码规避错误的产生，通常是系统级别的，所以很严重。 3.Exception:表示可修复的良性（相对于错误）的异常，异常产生后程序员可以并且应该通过代码的方式纠正，使程序继续运行，是必须要处理的。 4.运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。 练习二：throw与throws的区别 问题： 请描述throw的使用位置,作用是什么? 请描述throws的使用位置,作用是什么? 答： throw关键字通常用在方法体中，并且抛出一个异常对象。程序在执行到throw语句时立即停止，它后面的语句都不执行。 2.throws关键字通常被应用在声明方法时，用来指定可能抛出的异常。多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会将异常对象抛给方法调用处。 练习三：异常的处理方式 问题： 异常处理方式有几种,分别是什么? 详细阐述每种方式对异常是如何处理的 答： 异常的处理方式有两种,分别是使用throws和try…catch…finally 2.throws用在方法的声明上后接异常类名,是把异常抛给调用者进行处理 3.try…catch…finally是捕获异常,自己处理,处理完毕后面的程序可以继续运行 a)try代码块中是可能出现异常的代码 b)catch代码块,是遇到异常,对异常进行处理的代码 c)finally代码块是无论是否发生异常,都必须执行的代码,用于释放资源. 练习四：常见异常，及产生原因 问题：请列举常见异常，并说明产生原因。 答： NullPointerException:空指针异常。 当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度等等。 ArrayIndexOutOfBoundsException:数组索引越界异常。 当对数组的索引值为负数或大于等于数组大小时抛出此异常。 ArithmeticException:算术运算异常。 程序中出现了除以零这样的运算就会出这样的异常，对这种异常，大家就要好好检查一下自己程序中涉及到数学运算的地方，公式是不是有不妥了。 NumberFormatException:数字格式异常。 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 二.异常 介绍：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理 notes: 异常指的并不是语法错误，语法错误的话 编译不通过，不会产生字节码文件，根本不能运行。 ①异常体系：API： 异常机制其实就是帮助我们找到程序中的问题， 异常的根类是 java.lang.Throwable,下面有两个子类， -java.lang.Error (工程师不能处理，只能尽量避免) -java.util.Exception (由于使用不当导致，可以避免的) 平常所说的异常就是java.util.Exception ②Throwable中的常用方法：⑴打印异常的详细信息 public void printStackTrace(): 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 ⑵获取发生异常的原因 public String getMessage(): 提示给用户的时候,就提示错误原因。 ⑶获取异常的类型和异常描述信息(不用) public String toString(): ​ ③异常的分类 ⑴编译时期的异常:checked异常.在编译时期,就会检查,如果没有处理异常,则编译失败(如日期格式化异常) ⑵运行时期异常:runtime异常.在运行时期,检查异常,在编译时期,运行异常不会编译器检测(不报错)(如数学异常) ​ 三.处理异常五大关键字: try catch finally throw throws ①抛出异常throw⑴格式: throw new 异常类名(参数) ⑵抛出异常告诉调用者 : 步骤1:创建一个异常对象.封装好一些提示信息(信息可以自己编写) throw new NullPointerException(&quot;要访问的arr数组不存在&quot;); 步骤2:告知调用者,通过throw抛出一个异常对象,传递到调用者处,并结束当前方法的执行 例子: public static void main(String[] args) { int[] arr = {2,4,52,2}; int index = 4; int element = getElement(arr, index); System.out.println(&quot;element = &quot; + element); System.out.println(&quot;over&quot;); } private static int getElement(int[] arr, int index) { // 判断 索引是否越界 if (index&lt;0||index&gt;arr.length-1){ // 如果越界 当执行完 throw 抛出异常随心后，方法无法继续运算 // 这时就会结束当前方法的执行，并将异常 告知 调用者 这时就需要通过异常来解决 throw new ArrayIndexOutOfBoundsException(&quot;数组越界&quot;); } int element = arr[index]; return element; } 结果: Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 数组越界l~~~ at DemoThread.ThrowTest.getElement(ThrowTest.java:22) at DemoThread.ThrowTest.main(ThrowTest.java:7) ②Objects非空判断 还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成， 这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的）， 那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static T requireNonNull(T obj):查看指定引用对象不是null。 public static T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } ③声明异常throws 说明: 将问题标识出来,报告给调用者,如果方法内通过throw抛出了编译时异常,而没有捕获处理,那么必须同throws进行声明 让调用者去处理. 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常 格式: 修饰符 返回值类型 方法名(参数) throws 异常类名1 ,异常类名2...{} 例子: public static void main(String[] args) throws FileNotFoundException { read(&quot;a.txt&quot;); } // 如果定义功能时 有问题 发生需要报告给调用者，可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException{ if (!path.equals(&quot;a.txt&quot;)){ // 假设 如果不是a.txt认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); } } ④捕获异常try catch 捕获异常: Java中对异常有针对性的语句进行捕获,可以对出现的异常进行指定方式处理 格式: try{ // 编写可能出现异常的代码 }catch(异常类型 e){ 处理异常的代码 // 可以是记录日志、打印异常信息、继续抛出异常 } try：该代码块中编写可能产生的异常代码 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理 例子： public static void main(String[] args) { try { read(&quot;a12.txt&quot;); }catch (FileNotFoundException e){ // 打印异常 e.printStackTrace(); } System.out.println(&quot;over&quot;); } private static void read(String path) throws FileNotFoundException { if (!path.equals(&quot;a.txt&quot;)){ throw new FileNotFoundException(&quot;文件不存在&quot;); } /* if (!path.equals(&quot;a.txt&quot;)){ throw new IOException(); }*/ } 捕获的异常常用的方法： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 在开发中呢也可以在catch将编译期异常转换成运行期异常处理。 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式， 格式如下： try{ 编写可能会出现异常的代码 }catch(异常类型A e){ 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 }catch(异常类型B e){ 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 } notes： 注意:这种异常处理方式，要求多个catch中的异常不能相同， 并且若catch中的多个异常之间有子父类异常的关系， 那么子类异常要求在上面的catch处理， 父类异常在下面的catch处理 ⑤finally代码块 说明： 有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。 而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 打开一些物理资源（比如磁盘文件/网络链接/数据库链接等）我们都得在使用完之后，最终关闭打开的资源 用法： try catch finally：自身需要处理异常，最终还得关闭资源。 notes： finally不能单独使用。 例子： public static void main(String[] args) { try { read(&quot;a11.txt&quot;); }catch (FileNotFoundException e){ e.printStackTrace(); }finally { System.out.println(&quot;不管怎么样我都要执行&quot;); } System.out.println(&quot;over&quot;); } private static void read(String path) throws FileNotFoundException { if (!path.equals(&quot;a.txt&quot;)){ throw new FileNotFoundException(&quot;文件不存在！&quot;); } } tips: 只有在try或者catch中调用退出JVM的相关方法时，此时finally才不会执行，否则finally用远会执行 结果： 不管怎么样我都要执行 java.io.FileNotFoundException: 文件不存在！ over at DemoThread.finallyTest01.read(finallyTest01.java:19) at DemoThread.finallyTest01.main(finallyTest01.java:8) ⑥异常注意事项 ⑴运行时期异常被 抛出可以不处理，既不捕获也不声明抛出 ⑵如果父类抛出多个异常，子类覆盖父类方法时，只能抛出相同的异常或者他的子集 ⑶父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常，此时子类产生该异常，只能捕获处理，不能声明抛出 ⑷当多异常处理时，捕获处理，前边的类不能时后边类的父类 ⑸当try/catch后可以主机finally代码块，其中的代码一定会被执行，通常用于资源回收 ⑹如果finally有return语句，永远返回finally中的结果，避免该情况 四、自定义异常123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 说明： 为什么需要自定义异常类: Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: LoginException。一个登陆异常类。 异常类如何定义: 1. 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 2. 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException 例子： public class DiyETest &#123; private static String[] names= &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; // 模拟登录 try&#123; // 可能出现异常的代码 checkUsername(\"bill\"); // 如果没有就是注册成功 System.out.println(\"注册成功\"); &#125;catch (LoginException e)&#123; e.printStackTrace(); &#125; &#125; private static boolean checkUsername(String uname) throws LoginException &#123; for (String name:names)&#123; if (name.equals(uname))&#123; // 如果名字在其中 则抛出 登录异常 throw new LoginException(\"禁止登录\"); &#125; &#125; return true; &#125; &#125; class LoginException extends Exception&#123; public LoginException() &#123; &#125; /** * * @param name 表示异常提示 */ public LoginException(String name)&#123; super(name); &#125; &#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"02JavaSE基本语法总结","slug":"02JavaSE基本语法总结","date":"2016-10-26T11:59:02.000Z","updated":"2018-08-27T02:22:13.192Z","comments":true,"path":"2016/10/26/02JavaSE基本语法总结/","link":"","permalink":"htts://cocked.github.io/2016/10/26/02JavaSE基本语法总结/","excerpt":"","text":"一、StringBuffer1.类介绍1234①线程安全的可变字符串序列，一个类似于String的字符串缓冲区，但是不能修改（就是不能通过加号+连接，String就可以）②StringBuffer和String类的区别 String是一个可改变的字符序列 StringBuffer是一个可变的字符序列 2.构造方法12345StringBuffer() 构造一个没有字符的字符串缓冲区，初始容量为16个字符StringBuffer(int capacity) 构造一个没有字符的字符串缓冲区和指定初始容量StringBuffer(CharSequence seq) 构造一个字符串缓冲区,其中包含与指定的 CharSequence相同的字符。StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。 Notes：从jdk5开始,为该类补充了一个单个线程使用的等价类,即StringBuilder类,通常优先使用StringBuilder类,因为他支持所有相同操作,但是由于它不执行同步,所有速度更快 3.增删,替换翻转,截取()123456789101112131415161718StringBuffer sb = new StringBuffer(&quot;abcd&quot;);①添加sb.append(&quot;str12&quot;); //在末尾添加一个字符串sb.insert(3,&quot;hhh&quot;); //在指定位置添加指定字符串②删除sb.deleteCharAt(3); //删除指定1位置的字符 并返回本身sb.delete(1,3); //左闭右开③清空缓冲区sb.delete(0,sb.length());④替换sb.replace(0,3,&quot;bai&quot;) // 包含头不包含尾⑤翻转sb.reverse();⑥截取sb.substring(int start) //从指定位置截取到末尾sb.substring(int start,int end) //从指定位置开始到结束位置，包括开始位置，不包括结束位置// 截取 返回值不再是StringBuffer而是String 4.StringBuffer –&gt; String1234567891011121314151617181920String --》 StringBuffer a.通过构造方法 StringBuffer stringBuffer = new StringBuffer(&quot;woai&quot;); System.out.println(stringBuffer); // 通过构造方法完成转换成String b.通过append()方法 StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;woai&quot;); System.out.println(stringBuffer); // 通过append()方法完成转换成StringStringBuffer --》 String StringBuffer sb = new StringBuffer(&quot;woai1&quot;); a.通过构造方法 String s = new String(sb); // 通过构造方法 System.out.println(s); b.通过toString()方法 String string = sb.toString(); //通过toString()方法 System.out.println(&quot;string = &quot; + string); c.通过subString(0,length); String substring = sb.substring(0, sb.length()); System.out.println(substring); 5.数组 –&gt; 字符串12345678910111213141516举例： int [] arr = &#123;1,2,3,&#125;; 输出结果: &quot;[1,2,3]&quot; 用StringBuff的功能实现： int[] arr = &#123;1, 2, 3&#125;; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; stringBuffer.append(arr[i]).append(&quot;]&quot;); // 使用这样的添加方式会减少垃圾的存在 &#125;else &#123; stringBuffer.append(arr[i]).append(&quot;,&quot;); &#125; &#125; System.out.println(stringBuffer); 6.字符串翻转1通过StringBuffer进行翻转 7.StringBuffer和StringBuilder区别123456StringBuffer是jdk1.0版本的，是线程安全的，效率低的 (对于用户访问量大的bat 保证其稳定性，对于金融要求，保证其稳定，其他都不存在) StringBuilder是jdk1.5版本的，是线程不安全的，效率高的 String和StringBuffer，StringBuilder的区别 String是一个不可变的字符序列 StringBuffer，StringBuilder是可变的字符序列 8.String和StringBuffer作为参数传递123456789101112基本数据类型的值传递，不改变其值引用数据类型的值传递，改变其值 // 因为传递的是内存地址，String s = &quot;heihei&quot;; System.out.println(s); change(s); System.out.println(s); // heihei System.out.println(&quot;------------------&quot;); StringBuffer sb = new StringBuffer(); sb.append(&quot;hhhhhh&quot;); change(sb); System.out.println(&quot;sb = &quot; + sb); // heiheihhhhhh 9.数组-冒泡,选择,二分排序12345(1)冒泡 // 数据元素：&#123;24,69,80,57,13&#125; 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处(2)选择(3)二分排序 10.Arrays类12 11.Interger类12 12.String –&gt; int12 13.Interger面试题12 二、正则表达式1234567891011121314151617181920212223241.概述和简单使用 * [abc] a,b或c(简单类) * [^abc] 任何字符,除了a,b,或c (否定) * [a-zA-Z] a到 z 或 A 到 Z, 两头的字母包括在内（范围） * [a-d[m-p]] a到 d 或 m到p ; [a-dm-p] (并集) * [a-z&amp;&amp;[def]] d,e,或 f (交集) * [a-z&amp;&amp;[^bc]] a 到 z ，除了b和c; [ad-z](减去) * [a-z&amp;&amp;[^m-p]] a 到 z 而非 m 到 p; [a-lq-z](减去) 2.预定义字符类 \\d 数字:[0-9] \\D 非数字:[^0-9] \\s 空白字符:[\\t\\n\\x0B\\f\\r] \\S 非空白字符:[^\\s] \\w 单词字符:[a-zA-Z_0-9] \\W 非单词字符：[^\\w] 3.常见对象(数量词) X? X,一次或一次也没有 X* X,零次或多次 X+ X,一次或多次 X&#123;n&#125; X,恰好n次 X&#123;n,&#125; X,至少n次 X&#123;n,m&#125; X,至少n次,但是不超过m次 ​ 二、Collection三、List四、Set五、Map1********** 总结 ************* 1Collection 12345678910111213141516171819* List (存取有序，有索引，可以重复) -ArrayList 底层是数组实现的，线程不安全，查找和修改快，增和删比较慢 -LinkedList 底层是链表实现的，线程不安全，增删快，查找和修改比较慢 -Vector 底层是数组实现的，线程安全，无论增删 查找都慢 notes： 如果查找和修改多，用ArrayList 如果增和删多，用LinkedList 如果都多，用ArrayList* Set (存取无序，无需索引，不可以重复) -HashSet 底层是哈希算法实现的 LinkedHashSet 底层是链表实现，但是也可以保证元素的唯一性，和HasSet原理一样 -TreeSet 底层是二叉树算法实现的 12345678910111213141516 notes： 一般在开发的时候不需要对存储的元素排序，所以在开发的时候大多用HashSet , HashSet的效率比较高 TreeSet在面试的时候比较多，问你有几种排序方式，和几种排序方式的区别。* Map HashMap 底层是哈希算法，针对键 LinkedHashMap 底层是链表，针对键 TreeMap 底层是二叉树算法，针对键 notes： 开发中用HashMap比较多 六、异常&amp;IO(文件类)123456789101112131415161718192021222324252627282930311.异常概述和分类 *概述 是java程序在运行过程中出现的错误 *分类 通过API可以查看Throwable 有两个子类error 和exception error 服务器宕机，数据库崩溃 Exception *RuntimeException 运行时异常2.异常(关于finally关键字的面试题) A.final , finally 和 finalize的区别 B.如果catch里面有return 语句请问finally的代码还会执行吗? 如果会是在return前还是后3.自定义异常 继承Exception 编译时异常 继承RuntimeException 运行时异常 4.异常的注意事项及使用异常处理 A:注意事项 a.子类重写父类的方法时,子类的方法必须抛出相同的异常或父类异常的子类. b.如果父类抛出多个异常,子类重写父类时,只能抛出相同的异常或者时他的子集,子集不能抛出父类没有的异常 c.如果被重写的方法没有异常抛出，那么子类的方法绝不可以抛出异常，如果子类方法内有异常发生，那么子类只能try，不能throws B:如何使用异常处理 原则：如果该功能的内部可以将问题处理，就用try ，如果处理不了，交由调用者处理，这里用throws 区别： *后续程序需要继续运行就try *后续程序不需要运行就throws *如果JDK没有提供对应的异常，需要自定义异常","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"01JavaSE入门基础总结","slug":"01JavaSE入门基础总结","date":"2016-10-20T13:00:18.000Z","updated":"2018-08-27T02:22:03.132Z","comments":true,"path":"2016/10/20/01JavaSE入门基础总结/","link":"","permalink":"htts://cocked.github.io/2016/10/20/01JavaSE入门基础总结/","excerpt":"","text":"一、String介绍(引用类型) 123456789101112131415161718192021222324252627282930313233343536373839404142434445461.java.lang.String字符串. 用&quot;&quot;括住的时字符串,都可以看做是实现此类的实例 类String中也有许多简单方法2.特点 1).字符串不变:字符串的值在创建后不能被更改 2).因为String对象不可改变.所有他们可以被共享 3).(底层是这么实现的)对String s1 赋值 &quot;abc&quot; 等效于char[] data = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]3.构造举例(面试可能会问，)// 无参构造String str = new String();// 通过字符数组构造char chars[] = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;String str2 = new String(chars);// 通过字节数组构造byte b[] = &#123;97,98,99&#125;;String str3 = new String(b);4.字符串的比较（面试的时候会问，结合String进行理解） 1. == 比较 1.对基本类型 这个东西 可以 比较基本类型 四类八种 （比较的是值是否相等） 2.对引用类型进行比较时， 则比较地址值 2.equals(String str) 内容相同 ，返回true 5.String 方法（1）获取equalsIgnoreCase(String str) 忽略大小写比较内容int length() 返回字符串长度String concat 将指定的字符串连接到该字符串的末尾char charAt(int index) 返回指定索引处的char值int indexOf(String str) 返回指定字符串第一次出现该字符串的位置(索引) 找到了就是对应的首次出现的索引，找不到就返回-1String substring (int beginIndex) 返回一个字符串，从beginIndex开始截取字符串到最后String substring (int beginIndex, int endIndex) 返回一个字符串，从beginIndex开始截取字符串到endIndex截取字符串。 含beg 不含 end 12345678910111213141516171819（2）转换1.String replace()ex: String str = &quot;abbccd&quot; String newstr = str.replace(&apos;b&apos;,&apos;*&apos;) System.out.println(newstr) a**ccd 此处将含有b的全部替换成*了 String newstr = str.replace(&quot;bb&quot;,&quot;*&quot;) 运行结果为a*ccd2.char [] chars = toCharArray()转成字符数组 3. byte[] getByte();使用平台默认的字符集将该String编码新的字节数组.4. String[] split(String regex) &quot;&quot;\\\\.&quot;表示.转义一下 以 regex对字符串进行分割 二、StringBuffer 123456789101.类介绍 ①线程安全的可变字符串序列，一个类似于String的字符串缓冲区，但是不能修改（就是不能通过加号+连接，String就可以） ②StringBuffer和String类的区别 String是一个可改变的字符序列 StringBuffer是一个可变的字符序列2.构造方法 StringBuffer() 构造一个没有字符的字符串缓冲区，初始容量为16个字符 StringBuffer(int capacity) 构造一个没有字符的字符串缓冲区和指定初始容量 StringBuffer(CharSequence seq) 构造一个字符串缓冲区,其中包含与指定的 CharSequence相同的字符。 StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 notes: 从jdk5开始,为该类补充了一个单个线程使用的等价类,即StringBuilder类,通常优先使用StringBuilder类,因为他支持所有相同操作,但是由于它不执行同步,所有速度更快3.增删,替换翻转,截取() StringBuffer sb = new StringBuffer(&quot;abcd&quot;); ①添加 sb.append(&quot;str12&quot;); //在末尾添加一个字符串 sb.insert(3,&quot;hhh&quot;); //在指定位置添加指定字符串 ②删除 sb.deleteCharAt(3); //删除指定1位置的字符 并返回本身 sb.delete(1,3); //左闭右开 ③清空缓冲区 sb.delete(0,sb.length()); ④替换 sb.replace(0,3,&quot;bai&quot;) // 包含头不包含尾 ⑤翻转 sb.reverse(); ⑥截取 sb.substring(int start) //从指定位置截取到末尾 sb.substring(int start,int end) //从指定位置开始到结束位置，包括开始位置，不包括结束位置 // 截取 返回值不再是StringBuffer而是String4.StringBuffer --&gt; String String --》 StringBuffer a.通过构造方法 StringBuffer stringBuffer = new StringBuffer(&quot;woai&quot;); System.out.println(stringBuffer); // 通过构造方法完成转换成String b.通过append()方法 StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;woai&quot;); System.out.println(stringBuffer); // 通过append()方法完成转换成String StringBuffer --》 String StringBuffer sb = new StringBuffer(&quot;woai1&quot;); a.通过构造方法 String s = new String(sb); // 通过构造方法 System.out.println(s); b.通过toString()方法 String string = sb.toString(); //通过toString()方法 System.out.println(&quot;string = &quot; + string); c.通过subString(0,length); String substring = sb.substring(0, sb.length()); System.out.println(substring); 5.数组 --&gt; 字符串 举例： int [] arr = &#123;1,2,3,&#125;; 输出结果: &quot;[1,2,3]&quot; 用StringBuff的功能实现： int[] arr = &#123;1, 2, 3&#125;; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; stringBuffer.append(arr[i]).append(&quot;]&quot;); // 使用这样的添加方式会减少垃圾的存在 &#125;else &#123; stringBuffer.append(arr[i]).append(&quot;,&quot;); &#125; &#125; System.out.println(stringBuffer);6.字符串翻转 通过StringBuffer进行翻转 7.StringBuffer和StringBuilder区别 StringBuffer是jdk1.0版本的，是线程安全的，效率低的 (对于用户访问量大的bat 保证其稳定性，对于金融要求，保证其稳定，其他都不存在) StringBuilder是jdk1.5版本的，是线程不安全的，效率高的 String和StringBuffer，StringBuilder的区别 String是一个不可变的字符序列 StringBuffer，StringBuilder是可变的字符序列8.String和StringBuffer作为参数传递 基本数据类型的值传递，不改变其值 引用数据类型的值传递，改变其值 // 因为传递的是内存地址， String s = &quot;heihei&quot;; System.out.println(s); change(s); System.out.println(s); // heihei 1System.out.println(&quot;------------------&quot;); 1234StringBuffer sb = new StringBuffer();sb.append(&quot;hhhhhh&quot;);change(sb);System.out.println(&quot;sb = &quot; + sb); // heiheihhhhhh 123456789109.数组-冒泡,选择,二分排序 (1)冒泡 // 数据元素：&#123;24,69,80,57,13&#125; 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处 (2)选择 (3)二分排序10.Arrays类11.Interger类12.String --&gt; int13.Interger面试题 ​三、StringBuffer的构造方法： 123456789101112131415161718192021222324252627282930* public StringBuffer():无参构造方法* public StringBuffer(int capacity) 指定容量的字符串缓冲区对象* public StringBuffer(String str) 指定字符串内容的字符串缓冲区对象StringBuffer sb = new StringBuffer()sb.append(&quot;&quot;)sb.insert(int offset , String str)// // 在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串本身// 在new的时候是在堆内存中创建了一个对象，底层是一个长度为16的字符数组，当调用添加方法时，不会再重新创建对象，在不断向原缓冲区添加zifusb.deleteCharAt(4) // 根据索引删除索引位置上对应的字符sb.detel(0,2) // 删除的时候包含头不包含尾sb.detel(0,sb.length()) // 情况缓冲区sb.replace(0,3,&quot;bai&quot;) // 替换 替换指定区域的字符sb.reverse() // 翻转sb.substring() // 截取sb.reverse() // 翻转String --&gt; StringBuffer //通过构造方法 //和 append 将 字符串 转换为 StringBuffer对象 StringBuffer sb = new StringBuffer(&quot;heima&quot;) StringBuffer --&gt; String // 通过构造方法 // 通过toString()方法 // 通过subString(0,length)StringBuffer和StrinBuilder的区别： 四、Arrays 1java.util.Arrays(操作数组的各种方法,如排序和搜索) 121.sort 排序 直接打印 无返回值2. 五、Math 1234java.lang.Math 类包含用于基本数学运算方法,如初等指数,对数,平方根和三角函数其所有方法为静态方法，并且不会创建对象，调用起来非常简单。1.abs 12345Math.sqrt()//计算平方根Math.cbrt()//计算立方根Math.pow(a, b)//计算a的b次方Math.max( , );//计算最大值Math.min( , );//计算最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364System.out.println(Math.sqrt(16)); //4.0 System.out.println(Math.cbrt(8)); //2.0System.out.println(Math.pow(3,2)); //9.0System.out.println(Math.max(2.3,4.5));//4.5System.out.println(Math.min(2.3,4.5));//2.3/** * abs求绝对值 */ System.out.println(Math.abs(-10.4)); //10.4 System.out.println(Math.abs(10.1)); //10.1 /** * ceil天花板的意思，就是返回大的值 */ System.out.println(Math.ceil(-10.1)); //-10.0 System.out.println(Math.ceil(10.7)); //11.0 System.out.println(Math.ceil(-0.7)); //-0.0 System.out.println(Math.ceil(0.0)); //0.0 System.out.println(Math.ceil(-0.0)); //-0.0 System.out.println(Math.ceil(-1.7)); //-1.0/** * floor地板的意思，就是返回小的值 */ System.out.println(Math.floor(-10.1)); //-11.0 System.out.println(Math.floor(10.7)); //10.0 System.out.println(Math.floor(-0.7)); //-1.0 System.out.println(Math.floor(0.0)); //0.0 System.out.println(Math.floor(-0.0)); //-0.0 /** * random 取得一个大于或者等于0.0小于不等于1.0的随机数 */ System.out.println(Math.random()); //小于1大于0的double类型的数System.out.println(Math.random()*2);//大于0小于1的double类型的数System.out.println(Math.random()*2+1);//大于1小于2的double类型的数/** * rint 四舍五入，返回double值 * 注意.5的时候会取偶数 异常的尴尬=。= */ System.out.println(Math.rint(10.1)); //10.0 System.out.println(Math.rint(10.7)); //11.0 System.out.println(Math.rint(11.5)); //12.0 System.out.println(Math.rint(10.5)); //10.0 System.out.println(Math.rint(10.51)); //11.0 System.out.println(Math.rint(-10.5)); //-10.0 System.out.println(Math.rint(-11.5)); //-12.0 System.out.println(Math.rint(-10.51)); //-11.0 System.out.println(Math.rint(-10.6)); //-11.0 System.out.println(Math.rint(-10.2)); //-10.0 /** * round 四舍五入，float时返回int值，double时返回long值 */ System.out.println(Math.round(10.1)); //10 System.out.println(Math.round(10.7)); //11 System.out.println(Math.round(10.5)); //11 System.out.println(Math.round(10.51)); //11 System.out.println(Math.round(-10.5)); //-10 System.out.println(Math.round(-10.51)); //-11 System.out.println(Math.round(-10.6)); //-11 System.out.println(Math.round(-10.2)); //-10 六、static(在方法区有一块固定的存储区域,由于优先于对象存在,所以可以被所有对象共享)​ 1234567891011121314在定义方法的时候你写main方法的类加static,写普通类的写方法的时候就不要加static1.static可以用来修饰成员变量和成员方法，被修饰的成员属于类，而不是单单属于某个对象，也就是说，既然属于类，就可以不靠创建对象来调用了进一步介绍： 修饰成员变量 当static修饰成员变量时，该变量称为类变量，该类的每个对象都共享同一个类变量的值，任何对象都可以更改 该变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作 类名.类变量 类名.静态方法名(参数); 1修饰成员方法 (静态方法可以访问静态变量,不能访问普通的变量) 12345类名.方法() 推荐对象名.方法名() 麻烦特点静态方法只能访问静态内容(成员变量,静态成员方法) ​​ 1234notes: 静态方法 可以直接访问 静态变量和 静态方法. 静态方法 不能直接访问 普通成员变量 或 成员方法,反之成员方法可以直接访问静态变量或静态方法 静态方法 不能使用this关键字 ​七、静态代码块(想在main方法之前执行,可以给静态成员变量赋值) 12345678910静态代码块：定义成员位置，使用static修饰代码块()位置:类方法外执行:随着类的加载而执行且执行一次,优先于main方法构造和构造方法执行格式: public class ClassName&#123; static&#123; // &#125; &#125; ​ JAVA中分为基本数据类型和引用数据类型区别一、基本数据类型： byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0 char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0 boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false 二、引用数据类型： 类、接口类型、数组类型、枚举类型、注解类型。 区别： 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 例如，有一个类Person,有属性name,age,带有参的构造方法， Person p = new Person(“zhangsan”,20); 在内存中的具体创建过程是： 1.首先在栈内存中位其p分配一块空间; 2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值””，0； 3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作； 4.调用构造方法，为两个属性赋值为”Tom”,20；（注意这个时候p与Person对象之间还没有建立联系）； 5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。 相关知识： 静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。 堆区： 一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错 栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限 文字常量区： 常量字符串就是放在这里的。 程序结束后由系统释放。","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"第一篇博客","slug":"第一篇博客","date":"2016-05-18T23:12:27.000Z","updated":"2018-08-27T02:28:31.098Z","comments":true,"path":"2016/05/19/第一篇博客/","link":"","permalink":"htts://cocked.github.io/2016/05/19/第一篇博客/","excerpt":"","text":"#第一篇博客​ ##费尽周折终于将自己的博客上线， ​ 在这里 ，在我对hexo熟悉之后，将会不定期的更新我的博客主要关于Java，以及java中遇到的问题，也有可能分享生活， ​ ##以后补充： ​ ##之前的博客： ​ 博客园：https://www.cnblogs.com/zhengyuan/ ​ CSDN：https://blog.csdn.net/A_Eric ​ GitHub：https://github.com/cocked ​ ##git上的博客页面参照大佬的： ​ 参照大佬的博客:https://github.com/iTimeTraveler/hexo-theme-hiker","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"htts://cocked.github.io/tags/blog/"}]}]}