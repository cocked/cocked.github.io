{"meta":{"title":"Francis的个人博客","subtitle":"sharing technology or share music","description":"银河街角，时光路口","author":"Francis","url":"htts://cocked.github.io"},"pages":[],"posts":[{"title":"12Java函数式接口、方法引用","slug":"12Java函数式接口、方法引用","date":"2018-08-27T02:31:37.928Z","updated":"2018-08-27T02:56:04.009Z","comments":true,"path":"2018/08/27/12Java函数式接口、方法引用/","link":"","permalink":"htts://cocked.github.io/2018/08/27/12Java函数式接口、方法引用/","excerpt":"","text":"12.1 函数式接口12.1.1 概念1.函数式接口在Java中是指：有且仅有一个抽象方法的接口。 2.函数式接口，即适用于函数式编程场景的接口，而Java中的函数式编程体现就是Lambda，所有函数式接口就是可以适用于Lamnda使用的接口，只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。 3、语法糖的定义：是指使用更加方便，但是原理不变的代码语法，例如在遍历集合时使用的for-each语法，其实底层的实现原理 仍然是迭代器，这就是语法糖，从应用层讲， java中的Lambda可以被当做是匿名内部类的语法糖，但是二者原理上不同的 4.复习之前Lambda的使用要求， 使用条件1：必须拥有函数式接口，（java语言中已经提供了很多函数式接口） 使用条件2：调用的方法必须拥有函数式接口作为方法的参数，（Java语言已经提供了很多方法，这些方法的参数都是函数式接口） 12.1.2 格式只要确保接口中有且仅有一个抽象方法即可 12345修饰符 interface 接口名称 &#123; public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容&#125; 由于接口当中抽象方法的public abstract是可以省略的，所以定义一个函数式接口很简单： 123public interface MyFunctionalInterface &#123; void myMethod();&#125; 12.1.3 @FunctionalInterface注解与@Override注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。该注解可用于一个接口的定义上： 12345678// 函数式接口注解 : 该接口仅能拥有一个抽象方法@FunctionalInterfacepublic interface MyFunctionalInterface &#123; // 抽象方法定义 : void myMethod();&#125; notes：一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样 12.2 函数式编程12.2.1 Lambda 的延时执行有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。 性能浪费的日志案例 一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出： 123456789101112131415161718192021 public static void main(String[] args) &#123; String s1 = \"Hello\"; String s2 = \"World\"; String s3 = \"Java\"; // 调用方法 log(0, s1 + s2 + s3); &#125; // 方法 : public static void log(int level, String msg) &#123; if (level == 1) &#123; System.out.println(msg); &#125; &#125;结果： 说明 : 如果 level 不为 1, 则没有任何输出结果. 说明 : 如果 level 为 1, 输出结果如下 : HelloWorldJava notes：这段代码存在问题：无论级别是否满足要求，作为log方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。 体验Lambda的优化写法 使用Lambda必然需要一个函数式接口： 123456@FunctionalInterfacepublic interface MessageBuilder &#123; // 抽象方法 String buildMsg();&#125; 然后对log方法进行改造 123456789101112131415161718192021 public static void main(String[] args) &#123; String s1 = \"Hello\"; String s2 = \"World\"; String s3 = \"Java\"; // 调用方法 : log(1, () -&gt; s1 + s2 + s3); &#125; // 方法 : public static void log(int level, MessageBuilder messageBuilder) &#123; if (level == 1) &#123; String result = messageBuilder.buildMsg(); System.out.println(\"result = \" + result); &#125; &#125;输出结果 :result = HelloWorldJava noets：这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。 除此之外Lambda还可作为参数和返回值 12.2.2 使用函数式接口作为参数 例子：自定义一个函数是接口MyFunctionalInterface，里面有且仅有一个抽象方法void myMethod()。来说明使用函数式接口作为参数 思路历程： ** Lambda表达式实现 ** **思考1**，接口MyFunctionalInterface中的抽象方法长什么样（有无参数，有无返回值）， **思考2**，Lambda的表达式的各个部分是什么样的 （） -&gt; {} () 其中这里面放的是参数列表，一定要和函数式接口中的抽象放的参数列表保持一致 {} 方法的实现题部分 一定要和函数式接口中的抽象方法的返回值保持一致 开始写代码： 1234567891011121314151617181920public class MyFunctionalInterfaceTest1 &#123; public static void main(String[] args) &#123; // 重点 : 调用方法, 传递 Lambda 表达式作为函数式接口的实际参数 // 思考 : MyFunctionalInterface 函数式接口中的抽象方法长什么样 ??? void myMethod(); // () 小括号 : 函数式接口抽象方法的参数列表. // &#123;&#125; 大括号 : 函数式接口抽象方法的方法实现体. // Lambda 表达式的标准格式 : doSomething(() -&gt; &#123; System.out.println(\"Lambda 表达式被执行 ...\"); &#125;); // Lambda 表达式的省略格式 : doSomething(() -&gt; System.out.println(\"Lambda 表达式被执行 ...\")); &#125; // 定义一个方法, 使用函数式接口作为方法的参数列表 public static void doSomething(MyFunctionalInterface inter) &#123; // 此处为 Lambda 表达式代码的调用 inter.myMethod(); &#125;&#125; 1234567891011121314/*Lambda 表达式书写的前提要求 : (传递 Lambda 表达式作为方法的参数就是重要) 1. 必须要有 `函数式接口`. (自动推导) (Java提供) 2. 必须有方法使用 `函数式接口` 作为方法的参数列表. (Java提供) */// 请问 : 如何让编译器该接口是否为函数式接口@FunctionalInterfacepublic interface MyFunctionalInterface &#123; // 抽象方法 : 无参无返回值 void myMethod();&#125; 12.2.3 使用函数式接口作为返回值例子：自定义一个MySupplier函数式接口，无参有返回值，里面有且仅有一个方法Object getData();来说明函数式接口作为返回值 思路历程： 1.函数式接口中的抽象方法是什么样子的（Object getData()） 其中 抽象方式是没有参数，但是是有返回值的，返回值类型是 Object， 1. Lambda 的格式按照需求应该怎么写 ()中不需要写任何参数列表 {} 中有返回值 加return 书写要实现的方法。 **开始写代码** 12345678910111213141516171819202122232425262728public class MySupplierTest1 &#123; public static void main(String[] args) &#123; // 调用方法 // 思考 : 看一下 MySupplier 的抽象方法长什么样 ??? Object data(); printData(() -&gt; &#123; return \"Hello ShangHai, I Love you.\"; &#125;); // 调用方法 MySupplier mySupplier = getDataFromLambda(); // 请问 : 如何取出数据 ??? 调用函数式接口中的方法, 来获取数据 Object data = mySupplier.getData(); System.out.println(\"data = \" + data); &#125; // 方法 : 将函数式接口作为方法的参数 public static void printData(MySupplier mySupplier) &#123; Object data = mySupplier.getData(); System.out.println(\"data = \" + data); &#125; // 方法 : 将函数式接口作为方法的返回值 public static MySupplier getDataFromLambda() &#123; // 如何实现 : 返回一个 Lambda 表达式 Object getData(); // return () -&gt; &#123; return \"你爱北京长城.\"; &#125;; return () -&gt; \"你爱北京长城.\"; &#125;&#125; 123456@FunctionalInterfacepublic interface MySupplier &#123; // 抽象方法 : 无参, 有返回值 Object getData();&#125; 12.3 方法引用 **概述** : 什么是方法引用呢 ??? 其实就是 Lambda 表达式的孪生兄弟. 也可以理解为引用一个已经实现了 Lambda 表达式相同功能的方法. ** 格式** : 对象::对象方法 System.out::println 12.3.2 冗余的Lambda场景看一个简单的函数式接口以应用Lambda表达式 1234@FunctionalInterfacepublic interface Printable&lt;T&gt; &#123; void print(T t);&#125; ​ 在Printable接口当中唯一的抽象方法print接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单： 12345678910111213 public static void main(String[] args) &#123; // 调用方法 : printString(\"Hello beijing, 你好, 北京.\", s -&gt; System.out.println(s)); &#125; // 方法 : public static void printString(String str, Printable&lt;String&gt; printable) &#123; printable.print(str); &#125;输出结果： Hello beijing, 你好, 北京. 分析：这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是System.out对象中的println(String)方法。既然Lambda希望做的事情就是调用println(String)方法，那何必自己手动调用呢？这时候引入了其孪生兄弟， 方法引用： 改进之后的代码 12345678910111213141516171819202122 public static void main(String[] args) &#123; // 调用方法 : Lambda 表达式 printString(\"Hello beijing, 你好, 北京.\", s -&gt; System.out.println(s)); // 调用方法 : 方法引用 -&gt; 对象引用对象方法 PrintStream ps = System.out; printString(\"Hello beijing, 你好, 北京.\", ps::println); // 调用方法 : 简化格式 printString(\"Hello beijing, 你好, 北京.\", System.out::println); &#125; // 方法 : public static void printString(String str, Printable&lt;String&gt; printable) &#123; printable.print(str); &#125;输出结果 : Hello beijing, 你好, 北京. Hello beijing, 你好, 北京. Hello beijing, 你好, 北京. notes： 注意其中的双冒号::写法，这被称为“方法引用”，而双冒号是一种新的语法。** 12.3.3 方法引用符双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 *语义分析** 例如上例中，System.out对象中有一个重载的println(String)方法恰好就是我们所需要的。那么对于printString方法的函数式接口参数，对比下面两种写法，完全等效： Lambda表达式写法：s -&gt; System.out.println(s); 方法引用写法：System.out::println 第一种语义是指：拿到参数之后经Lambda之手，继而传递给System.out.println方法去处理。 第二种等效写法的语义是指：直接让System.out中的println方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 推导与省略** 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 12.3.4 通过对象名引用成员方法这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法： 思路历程： 1.接口Printable 中的抽象方法 void print(T t) 有参数 未指定类型，无返回值 printString(“Hello World. 你好, 世界!”, s -&gt; System.out.println(s)); 2，上面传递的Lambda 表达式 （s -&gt; System.out,println(s) ）的实现效果与 Sysetm.out 对象的println 方法实现一致 ​ 既然效果一样，那么Lambda表达式可不可以不写了，直接引用别人的方法。 ​ 方法引用的条件：引用的方法必须与函数式中的抽象方法匹配，（参数类型和返回值需要保持一致） ​ // Printable : void print(T t); System.out 对象的 void println(String x); ​ // 引用语法 : 对象名::对象方法名 3. // 简化格式 : System.out::println 对象名::对象方法 // 作用 : 已经有方法完成 Lambda 表达式需要实现的效果. 因此, 在程序中可以使用方法引用替代 Lambda 表达式. 4. // 方法 : 使用函数式接口作为参数 (这是 Lambda 表达式的传递基本) 12345678public class ObjectMethodRef &#123; // 对象方法 : public void printUpperCase(String str) &#123; String s = str.toUpperCase(); System.out.println(s); &#125;&#125; 12345// 函数式接口仍然定义为@FunctionalInterfacepublic interface Printable&lt;T&gt; &#123; void print(T t);&#125; 那么当需要使用这个printUpperCase成员方法来替代Printable接口的Lambda的时候，已经具有了ObjectMethodRef类的对象实例，则可以通过对象名引用成员方法，代码为： 1234567891011121314151617 public static void main(String[] args) &#123; // Lambda 表达式实现 : printString(\"hello\", s -&gt; System.out.println(s.toUpperCase())); // 对象方法引用 : ObjectMethodRef obj = new ObjectMethodRef(); printString(\"hello\", obj::printUpperCase); &#125; public static void printString(String str, Printable&lt;String&gt; printable) &#123; printable.print(str); &#125;输出结果 :HELLOHELLO 12.3.5 通过类名称引用静态方法由于在java.lang.Math类中已经存在了静态方法abs，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口： 123456@FunctionalInterfacepublic interface Calculator &#123; // 抽象方法 : int calc(int num);&#125; 1234567891011121314151617181920public class Test3 &#123; public static void main(String[] args) &#123; // 调用方法 : Lambda 表达式 printCalculator(-88, num -&gt; Math.abs(num)); // 调用方法 : 静态方法引用 printCalculator(-88, Math::abs); &#125; // 方法 : public static void printCalculator(int num, Calculator calculator) &#123; int result = calculator.calc(num); System.out.println(\"result = \" + result); &#125;&#125;输出结果 :result = 88result = 88 notes： 在这个例子中，下面两种写法是等效的： Lambda表达式：n -&gt; Math.abs(n) 方法引用：Math::abs 12.3.6 通过super引用成员方法​ 如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口 notes： 在这个例子中，下面两种写法是等效的： - Lambda表达式：() -&gt; super.sayHello() 方法引用：super::sayHello 12.3.7 通过this引用成员方法​ this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。首先是简单的函数式接口： 1234@FunctionalInterfacepublic interface Richable &#123; void buy();&#125; 123456789101112131415161718192021222324252627public class Husband &#123; // 行为 : 变得快乐 public void beHappy() &#123; // 结婚吧 merry(() -&gt; System.out.println(\"买套房子.\")); merry(() -&gt; this.buyCar()); merry(this::changeWife); &#125; // 行为 : 结婚 (需要变得有钱, 必须要买东西) private void merry(Richable richable) &#123; richable.buy(); &#125; // 行为 : 买套方法 private void buyHouse() &#123; System.out.println(\"买套房子.\"); &#125; // 行为 : 买辆车子 private void buyCar() &#123; System.out.println(\"买辆车子.\"); &#125;&#125; 123456789101112public class Test &#123; public static void main(String[] args) &#123; Husband husband = new Husband(); husband.beHappy(); &#125;&#125;输出结果 :买套房子.买辆车子. 开心方法beHappy调用了结婚方法marry，后者的参数为函数式接口Richable： 在这个例子中，下面两种写法是等效的： - Lambda表达式：() -&gt; this.buyCar() - 方法引用：this::buyCar 12.3.8 类的构造器引用由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用类名称::new的格式表示。首先是一个简单的Person类： 12345678910111213141516171819public class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 在这个例子中，下面两种写法是等效的： - Lambda表达式：name -&gt; new Person(name) - 方法引用：Person::new 12.3.9 数组的构造器引用数组也是Object的子类对象，所以同样具有构造器，只是语法稍有不同。 需要一个函数式接口 12345@FunctionalInterfacepublic interface ArrayBuilder &#123; // 抽象方法 int[] buildArray(int length);&#125; 12345678910111213141516171819public class Test2 &#123; public static void main(String[] args) &#123; int[] arr1 = initIntArray(10, len -&gt; new int[len]); System.out.println(\"arr1.length = \" + arr1.length); int[] arr2 = initIntArray(10, int[]::new); System.out.println(\"arr2.length = \" + arr2.length); &#125; // 初始化一个 int[] 数组 public static int[] initIntArray(int length, ArrayBuilder builder) &#123; return builder.buildArray(length); &#125;&#125;输出结果 :arr1.length = 10arr2.length = 10 在这个例子中，下面两种写法是等效的： - Lambda表达式：length -&gt; new int[length] - 方法引用：int[]::new 12.4 总结之 前瞻 Java语言的4大核心函数式接口12.4.1 总结 第一步：定义函数式接口 第二步： 定义方法，将函数式接口作为方法的参数类型 总结：只要满足前两个步骤，我们就可以书写Lambda表达式了， 问： 在使用Lambda表达式传送传输时，思考哪两个东西？？ 思考1：函数式接口中华抽象方法的参数列表 思考2：函数式接口中抽象方法的返回值类型 核心点：要求程序员对函数式接口中的抽象方法，参数类型和返回值类型，非常清晰的理解。因此没有这一层的理解，Lambda表达式的语法就无从书写了 Lambda表达式的语法格式**：（抽象方法参数） -&gt; { return 抽象方法的实现体 } 12.4.2 4大函数式接口 Java 语言中提供了最重要的 “四大核心函数式接口” 特有的抽象方法 消费型接口： 特点（有去无回）Consumer void accept（T t） 供给型接口 特点 （无中生有）Supplier T get(); 函数型接口 特点（有去有回）Function&lt;T, R&gt; R apply (T t) T -&gt; Type 参数类型 R -&gt; Result 返回值类型 断言型接口 特点（元芳，你怎么看）Predicate boolean test （T t） 说明：使用函数式接口作为方法的参数，这些API大部分都被定义到 StreamAPI 中 StreamAPI 主要操作对象为 “集合” 对象，不是 “读写” 对象 ​ 说明1：读写IO 主要是 “内存与硬盘” 实现数据交互 ​ 说明2：StreamAPI 主要是 ”内存与内存“ 实现数据交互 （变量，数组，集合）","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"Jquery初探","slug":"Jquery初探01","date":"2018-08-20T02:15:18.000Z","updated":"2018-08-27T02:23:31.472Z","comments":true,"path":"2018/08/20/Jquery初探01/","link":"","permalink":"htts://cocked.github.io/2018/08/20/Jquery初探01/","excerpt":"","text":"#一、jQuery1.jQery核心语法​ jq的核心语法： jQuery(“选择器”)， jQuery(callback)， jQuery(html)。其中jQuery可以使用$代替。 2.js和jQery对象比较 JS对象（DOM） DOM：是文档对象模型；DOM对象指的是这个文档（html）中的某一个具体的节点对象； jQuery对象 jQuery对象是一个类数组的对象这个对象里面其实是包含了DOM对象的信息的然后封装了很多操作方法，调用自己的方法html与css处理，得到的效果与标准的JavaScript处理结果是一致的。 ​jQuery ——–&gt; js jQuery对象[0]； jQuery对象.get(0)； ​js ———&gt; jQuery 只需要使用$将JS对象包裹即可：$(dom) 3.两者方法不通用 ​ jQuery对象不能使用JS对象的方法； ​ JS对象不能使用jQuery对象的方法； 4.事件注册 ​ js的事件的写法：js对象.onclick = function(){ … … }​ jquery的事件的写法：jquery对象.click( function(){ … … } )​ JS可以使用事件绑定和事件派发两种事件注册方式； ​ jQuery只能使用事件派发的方式来绑定事 5.onload事件 ​ js的页面加载完毕： 1window.onload = function()&#123; ...... &#125; ​ jquery的页面加载完毕： 12$(function()&#123;&#125;)$(document).ready(function()&#123;... ... &#125;) 6.jQuery常用事件 事件 使用方法 说明 click() jq对象.click( function(){ //方法体 } ) 鼠标单击事件 blur() jq对象.blur( function(){ //方法体 } ) 失去焦点事件 change() jq对象.change( function(){ //方法体 } ) 内容改变事件 submit() jq对象.submit( function(){ //方法体 } ) 表单提交事件 #二、选择器1.jQuery选择器 选择器 示例 说明 基本选择器 $(element),$(&quot;#id&quot;),$(&quot;.class&quot;),$(element,element) 元素，id，class，组合选择器 层级选择器 $(&quot;A B &quot;),$(&quot;A &gt; B&quot;),$(&quot;A + B&quot;),$(&quot;A ~ B&quot;) 根据标签之间的层级关系进行选择 属性过滤选择器 $(&quot;A[属性名]&quot;),$(&quot;A[属性名!=值]&quot;) 根据标签的属性对选中的标签进行过滤 基本过滤选择器 $(&quot;div:first&quot;),$(&quot;div:even&quot;) 根据标签所处的位置及特性进行过滤 表单对象属性过滤选择器 $(&quot;:selected&quot;),$(&quot;input:disabled&quot;) 根据表单对象的属性对选中的标签进行过滤 可见性过滤选择器 $(&quot;input:visible&quot;),$(&quot;input:hidden&quot;) 根据表单是否可见进行过滤。不可见的元素包括：1.隐藏域；2.style=”display:none” 内容过滤选择器 $(&quot;div:has(&#39;selector&#39;)&quot;) 根据元素中包含的内容过滤 表单过滤选择器 $(&quot;:input&quot;)$(&quot;:radio&quot;) 根据表单的特性进行过滤 2.基本选择器​ 基本选择器主要有：标签名（元素）选择器，id选择器，class选择器和组合选择器；如下： 选择器 使用示例 说明 标签名（元素）选择器 $(p),$(div) 根据标签名选择具有相同标签名的标签 id选择器 $(#idVal) 根据标签的id属性值选择 class选择器 $(.classVal) 根据标签的class属性值，选择具有相同class属性值的元素 组合选择器 $(div,p) 将多个选择器选中的标签合并返回 * $(*) 选择页面上的所有标签 3.层级选择器根据元素之间的层级关系进行选择。 选择器 名称 描述 $(“A空格B”) 后代选择器 后代选择器:选择给定祖先A元素的所有后代B元素，包括子元素，孙子元素等全部后代元素 $(“parent &gt; child”) 直接子元素 子选择器:选择所有指定”parent”元素中指定的”child”的直接子元素 $(“A+ B”) 相邻兄弟 相邻兄弟选择器:选择所有紧接在A元素后的第一个B元素 $(“A~ B”) 后面的兄弟元素 后面兄弟选择器：匹配“A”元素之后的所有兄弟B元素。 $(“A”).siblings(“B”); 一般兄弟元素 兄弟元素选择器 ：匹配所有的（之前+之后）兄弟元素 4.属性过滤选择器属性过滤选择器的作用：1.先选中；2.再根据属性过滤出想要的元素； 过滤器 使用示例 说明 [attribute] $(“input[name]”) 过滤拥有指定属性的元素 [attribute=value] $(“input[name=userName]”) 过滤出属性值=value的元素 [attribute!=value] $(“input[name!=password]”) 过滤出属性值！=value的元素 [attribute^=value] $(“input[name^=myClass]”) 过滤出属性值以value开始的元素 [attribute$=value] $(&quot;input[name$=myClass]&quot;) 过滤出属性值以value结束的元素 [attribute*=value] $(“input[class*=myClass]”) 过滤出属性值含有value的元素 [attr1][attr2][attr3]... $(&quot;input[name=username][value!=张三]...&quot;&quot;) 过滤指定的多个属性同时满足条件的元素，以上属性过滤的任意组合 5.基本过滤选择器 过滤方法 使用示例 说明 :first $(&quot;tr:first&quot;)：第一个tr，相当于$(&quot;tr:eq(0)&quot;) 第一个位置 :last $(&quot;tr:last&quot;):tr中的最后一个，相当于$(&quot;tr:eq(-1)&quot;) 最后一个位置 :odd $(&quot;tr:odd&quot;):tr中的奇数行（1,3,5,7……） 奇数位置 :even $(&quot;tr:even&quot;):tr中的偶数行(2,4,6,8……) 偶数位置 :eq(index) $(“tr:eq(0)”)：第一个tr 选取指定索引的元素 :gt(index) $(“tr:gt(1)”)：索引大于1的tr，即第2个tr之后的tr 选取索引大于指定索引的元素 :lt(index) $(“tr:lt(3)”)：索引小于3的tr，即前3个tr(0,1,2) 选取索引小于指定索引的元素 :not(selector) $(&quot;tr:not(tr:eq(2))&quot;):tr中除第2行外的行 去除与给定选择器匹配的元素（排除） :header $(&quot;:header&quot;)：获取h1到h6 匹配所有标题元素 :animated $(&quot;:animated&quot;):匹配所有正在执行动画效果的元素 匹配所有正在执行动画效果的元素 :focus $(&quot;input:focus&quot;):获取input中获取焦点的 匹配所有获取焦点的元素 6.表单对象属性过滤选择器表单对象属性过滤选择器是根据表单元素的某些属性来进行过滤选择的。 过滤器 使用示例 说明 :enabled $(“input:enabled”) 过滤可用的元素 :disabled $(“input:disabled” 过滤不可用的元素 :checked $(&quot;input[type=checkbox]:checked&quot;)或$(&quot;:checkbox:checked&quot;) 过滤被选中元素(复选框、单选框等，不包括select中的option) :selected $(&quot;select option:selected&quot;) 过滤被选中的元素（select的option） 7.可见性过滤选择器​ 可见性过滤选择器是根据标签是否可见进行过滤的，页面上能够看见的标签都是可见的。不可见的标签主要包括以下两种： 隐藏域：&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;520&quot;&gt; ； diaplay属性隐藏：&lt;div style=&quot;display:none&quot;&gt;&lt;/div&gt; ; 123456789101112$(function() &#123; //&lt;input type=\"button\" value=\" 选取所有可见的div元素\" id=\"b1\" /&gt; $(\"#b1\").click(function()&#123; $(\"div:visible\").css(\"background-color\",\"yellow\"); &#125;) //&lt;input type=\"button\" value=\" 选取所有不可见的div元素, 利用 jQuery 中的 show() 方法将它们显示出来\" id=\"b2\" /&gt; $(\"#b2\").click(function()&#123; $(\"div:hidden\").show(); &#125;)&#125;); 8.内容过滤选择器内容过滤选择器是根据标签中时候包含有某些内容，来对选择的标签进行过滤的。语法格式：$(&quot;div:has(selector)&quot;) 。 1234567$(function() &#123; //&lt;input type=\"button\" value=\"选取含有class为mini元素 的div元素.\" id=\"btn1\" /&gt; $(\"#btn1\").click(function()&#123; $(\"div:has('.mini')\").css(\"background-color\",\"yellow\"); &#125;)&#125;); 9.表单选择器​ 根据表单子标签的type属性进行过滤。目前只需要大家知道:input选择器选中的标签有哪些。其余的都可以使用属性过滤选择器来代替。 选择器 使用方法 说明 :input $(&quot;:input&quot;) 过滤出所有的表单子标签，包括：input，select，textarea，button :text $(&quot;:text&quot;) 过滤出表单子标签中type=”text”的标签 :password $(&quot;:password&quot;) 过滤出表单子标签中type=”password”的标签 :radio $(&quot;:radio&quot;) 过滤出表单子标签中type=”radio”的标签 :checkbox $(&quot;:checkbox&quot;) 过滤出表单子标签中type=”checkbox”的标签 :file $(&quot;:file&quot;) 过滤出表单子标签中type=”file”的标签 :hidden $(&quot;:hidden&quot;) 过滤出表单子标签中type=”hidden”的标签 :button $(&quot;:button&quot;) 过滤出表单子标签中type=”button”的标签，和&lt;button&gt;&lt;/button&gt;标签 :reset $(&quot;:reset&quot;) 过滤出表单子标签中type=”reset”的标签 :submit $(&quot;:submit&quot;) 过滤出表单子标签中type=”submit”的标签 :image $(&quot;:image&quot;) 过滤出表单子标签中type=”image”的标签 #三、jQuery操作方法1.jQuery的dom操作 方法 作用 说明 html()/text()/val() 设置或者获取：html代码/文本/值 方法不传参数为取值；方法传入参数为设置值 attr()/prop() 设置或者获取标签的属性 方法不传入参数为获取属性值，方法传入参数为设置属性值 addClass()/ removeClass() 添加或者移除标签的class属性 addClass()为添加class属性；removeClass()为移除class属性； css() 设置或者获取css样式 方法传入一个参数（样式名）为获取指定样式；方法传入两个参数为设置样式 $(&quot;&lt;p&gt;茄子创意&lt;/p&gt;&quot;) 创建新的标签 参数为完整的html标签 append()/prepend() 给父标签添加子标签 append（）：在父标签的子节点后面追加；prepend（）：在父标签的子节点前面追加； remove()/empty() 移除标签（文本和子标签）/清空标签体（文本和子标签） remove()：移除标签（当前标签及其子标签）；empty()：清空当前标签中的内容（保留原标签）； (1)、html代码/文本/值操作 html()方法与dom中的innerHTML操作结果一样，获取的是标签中的html内容； text()方法与dom中的innerText操作的结果一样，获取的是标签中的文本内容； val()方法与dom中的value操作的结果一样，获取的是标签的vlaue属性值； html(),text()和val()方法如果不传入参数则为取值，如果传入参数则为赋值操作； (2)、属性操作：attr()和prop() 对标签的普通属性的操作使用attr()方法更准确； 在获取checked或者selected属性值的时候建议使用prop()方法，其余都使用attr()方法； (3)、class属性操作和css样式操作 class属性操作： addClass()：给元素添加class属性； removeClass()：给元素移除class属性； css属性操作： css(cssName)：获取标签的css样式； css(cssName,cssValue)：给标签添加css样式； (4)、html元素创建与插入 html元素创建：$(html代码)； html元素插入：（注：a和b都是jq对象） 【内部插入】父子关系 方法 使用示例 说明 append() a.append(b) a把b插入到自己内部的后面（追加） appendTo() a.appendTo(b) a把自己插入到b的内部的后面 prepend() a.prepend(b) a把b插入到自己内部的前面 prependTo() a.prependTo(b) a把自己插入到b的内部的前面 【外部插入】兄弟关系 方法 使用示例 说明 after() a.after(b) a把b插入到自己的后面 insertAfter() a.insertAfter(b) a把自己插入到b的后面 before() a.before(b) a把b插入到自己的前面 insertBefore() a.insertBefore(b) a把自己插入到b的前面 (5)、html元素的删除操作 删除元素主要用到以下两个方法：remove() 和empty()方法，两者的区别： remove()方法：移除当前元素及其所有子元素； empty()方法：将当前元素的所有子元素清空，保留当前元素； 【应用场景】 remove()方法适用于完全删除元素及其子元素； empty()方法适用于将元素中的文本及其子元素清空，保留当前元素；如：清空select中的option。 2.jQuery效果（1）元素的显示与隐藏 元素的显示与隐藏主要用到以下3个方法： 方法 使用示例 说明 show(speed,fn) $(&quot;#_div&quot;).show(3000,function(){ alert(&quot;Hello World&quot;) }) 参数speed：元素显示的速度；参数fn：元素显示后执行的方法； hide(speed,fn) $(&quot;#_div&quot;).hide(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 toggle(speed,fn) $(“#_div”).toggle(3000,function(){ alert(“Hello World”) }) 同上 （2）元素的滑动显示与隐藏 元素的滑动显示与隐藏主要用到以下3个方法： 方法 使用示例 说明 slideUp(speed,fn) $(&quot;#_div&quot;).slideUp(3000,function(){ alert(&quot;Hello World&quot;) }) 通过高度变化（向上减少）参数speed：元素显示的速度；参数fn：元素显示后执行的方法； slideDown(speed,fn) $(&quot;#_div&quot;).slideDown(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 slideToggle(speed,fn) $(“#_div”).slideToggle(3000,function(){ alert(“Hello World”) }) 同上 (3)元素的淡入淡出显示效果 元素的淡入淡出显示效果主要使用到以下3个方法： 方法 使用示例 说明 fadeIn(speed,fn) $(&quot;#_div&quot;).fadeIn(3000,function(){ alert(&quot;Hello World&quot;) }) 参数speed：元素显示的速度；参数fn：元素显示后执行的方法； fadeOut(speed,fn) $(&quot;#_div&quot;).fadeOut(3000,function(){ alert(&quot;Hello World&quot;) }) 同上 fadeToggle(speed,fn) $(“#_div”).fadeToggle(3000,function(){ alert(“Hello World”) }) 同上","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"htts://cocked.github.io/tags/jQuery/"}]},{"title":"","slug":"Redis初探01","date":"2018-08-19T00:34:12.797Z","updated":"2018-09-01T08:29:11.041Z","comments":true,"path":"2018/08/19/Redis初探01/","link":"","permalink":"htts://cocked.github.io/2018/08/19/Redis初探01/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"01springmvc初探","slug":"01springmvc初探","date":"2017-04-05T01:24:14.000Z","updated":"2018-09-16T13:45:44.679Z","comments":true,"path":"2017/04/05/01springmvc初探/","link":"","permalink":"htts://cocked.github.io/2017/04/05/01springmvc初探/","excerpt":"","text":"#springmvcspringmvc简介​ 大部分java应用都是web应用，表现层是web应用最为重要的部分。Spring为表现层提供了一个优秀的web框架——SpringMVC。和众多其他web框架一样，它是基于mvc的设计理念，此外，它采用了松散耦合可插拔组件结构，比其他mvc框架更具有扩展性和灵活性。 SpringMVC通过一套MVC注解，让POJO（Plain Ordinary Java Object，简单的Java对象）成为处理请求的处理器，无需实现任何接口，同时，SpringMVC还支持REST风格的URL请求。此外，SpringMVC在数据绑定、视图解析、本地化处理以及静态资源处理上都有许多不俗的表现。 它在框架设计、扩展性、灵活性等方法全面超越的Struts、WebWork等MVC框架，从原来的追赶者一跃成为了MVC的领跑者。 SpringMVC框架围绕DispatcherServlet这个核心展开，DispatcherServlet是SpringMVC框架的总导演、总策划，它负责拦截请求并将其分派给相应的处理器。 springmvc入门1.创建maven工程 记得添加webapp目录 2.添加打包方式和引入依赖 3.添加日志和springmvc配置文件 4.添加视图 在WEB-INF下创建一个views目录，在views目录下添加一个hello.jsp。 5.配置前端控制器 在web.xml中配置DispatcherServlet控制器： 6.创建自定义处理器 1234567891011121314151617@Controllerpublic class HelloController &#123; /** * @RequestMapping(\"/show1.do\"): 使得请求的url可以映射到指定的目标方法上 * @return */ @RequestMapping(\"/show1.do\") public ModelAndView test1()&#123; ModelAndView mv = new ModelAndView(); //设置要显示的页面：视图 mv.setViewName(\"/WEB-INF/views/hello.jsp\"); //添加要显示的数据:数据是存在request域中 mv.addObject(\"msg\",\"Hello Word！\"); return mv; &#125;&#125; 7.开启注解扫描 8.访问localhost:8080/show1.do springmvc架构 用户发送请求至前端控制器DispatcherServlet DispatcherServlet手动请求调用HandlerMapping处理器映射器 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 执行处理器（Controller，也叫后端控制器） Controller执行完成返回ModelAndView HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ViewReslover解析后返回具体View DispatcherServlet对View进行渲染视图（将模型数据填充到视图中） DisparcherServlet响应给用户 DispatcherServlet：前端控制器 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcher是整个流程控制中心，由它调用其他组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性 HandlerMapping：处理器映射器 HandlerMapping 负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现了不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等 HandlerAdapter：处理器适配器 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 Handler：处理器 它就是我们开发中要编写的具体业务处理器，由DispatcherServlet把用户请求转发到Handler。由Handler对具体的用户请求进行处理 View Resolver：视图解析器 View Resolver 负责处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后掉View进行渲染将处理结果通过页面展示给用户。 View：视图 Springmvc框架提供了很多的View视图类型的支持，包括：jstlView，freemarkerView，pdfView等，我们最常用的视图就是html。一般情况下需要通过页面标签将模型数据通过页面展示给用户，需要根据业务需求开发具体页面 默认加载的组件： 我们在配置文件中只配置DispatcherServlet，缺能正常运行，说名springmvc的执行流程中需要配置映射器和适配器，而两个springmvc框架帮我们默认配置完成了，因此无需用户手动配置 在控制器DispatcherServlet中：有一行默认配置，控制器会读取该默认的资源文件DispatcherServlet.properties 1234567org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter 为了方便起见我们在配置文件中做出如下修改 视图解析器框架默认的InternalResourceViewResolver，该视图解析器支持jsp视图的解析 1234567 &lt;!--配置视图解析器解析规则 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--配置视图解析器的前缀：去哪个位置找视图 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"&gt;&lt;/property&gt; &lt;!--配置视图解析器的后缀：找以.jsp为后缀的视图 --&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt; 视图名称需要在处理器的方法中使用ModelAndView进行封装后返回，如果视图名称名为hello,那么最终返回的jsp视图地址为： “/WEB-INF/views/hello.jsp” 最终jsp的物理地址为：前缀+视图名称+后缀 小结springmvc的使用步骤： ​ 1.配置web.xml ​ 配置前端控制器 ​ tomcat启动时初始化 ​ 指定springmvc的配置文件的位置 ​ 2.编写springmvc的配置文件 ​ 开启包扫描 ​ 配置mvc注解驱动：注册各种功能，使用spring推荐的映射器和适配器和消息转化器 ​ 配置视图解析器：指定如果去查找视图 ​ 3.编写自定义处理器 ​ 将处理器装配到容器中 ​ 编写请求的url映射关系：@ResquestMapping(“xxx”)：来映射要执行的方法 ​ 在@RequestMapping(“xxx”)下编写方法处理具体的业务逻辑，返回一个ModelAndView，其中可以封装视图名称和数据 #RequestMapping映射请求1.简介 标准url映射 Ant风格的映射：(0个或多个字符)、？(单个字符)、**(0个或多个路径) Rest风格的映射:占位符 限定请求方法的映射:get post put delete 限定参数的映射:限定那些请求参数可以访问 2.标准URL映射@RequestMapping(value = “xxx”) 在springmvc众多Controller以及每个Controller的众多方法中,请求是如何映射到具体的处理方法上的呢? 它可以定义在方法上,也可以定义在类上. 定义在方法上 直接定义在方法上,这时请求路径就是方法上的@RequestMapping的value 定义在类上 相当于给url多加了一个一级路径 3.Ant风格的映射(通配符)?：通配一个字符 *：通配任意多个字符，可以是0个，可以是1个，可以是多个.但是最好和其他字符一起使用 **：通配任意多个路径 4.Rest风格(占位符)的映射@RequestMapping(value = “hello/{name}/{id}”) 请求url:http://localhost:8080/hello/zhangsan/1001.do 注意：占位符的主要应用是用来接受url中的参数 比如：@PathVariable(“userid”) Long id , @PathVariable(“name”) String name 获取对应的参数 注意：@PathVariable(“key”) 中的key必须和对应的占位符的参数名一致，而方法形参的参数可任意取。 如果传递的参数类型和接受参数的形参类型不一致，则会自动转换，如果转换出错，（例如：id传了abc字符串，方法形参使用Long来接受参数）则会报400错误（参数列表错误 ） 5.限定请求方法的映射限定单个请求方法 @RequestMapping(value = “x”, method = RequestMethod.POST) 限定多个请求方法 @RequestMapping(value = “x”, method = {RequestMethod.POST, RequestMethod.GET}) 6.限定请求参数的映射@RequestMapping(value= “”, params= “”) params = “userId” : 请求参数中必须带有userId params = “!userId” : 请求参数中不能包含userId params = “userId = 1” ：请求参数中必须包含userId并且值必须为1 params = “userId ! = 1” : 请求的所有参数中如果有userId必须不为1 ，参数中可以不包含userId params = {“userId”, “name”} ：请求参数中必须有userId，name 参数 7.组合注解@GetMapping：相当于@RequestMapping (method =RequestMethod.GET) @PostMapping：相当于@RequestMapping（method= RequestMethod.POST） @PutMapping：相当于@RequestMapping（method= RequestMethod.PUT） @DeleteMapping：相当于@RequestMapping（method= RequestMethod.DELETE） 也可以在注解中限定请求参数，用法和之前的一样。 #返回值类型1.返回值是String类型1234567@RequestMapping(value=\"show\")public String test(Model model)&#123; model.addAttribute(\"msg\", \"优化后的代码\");//添加数据 return \"hello\";//springmvc默认将返回值 视为视图名称&#125; 2.返回值是void类型123456@RequestMapping(\"show\")@ResponseStatus(value=HttpStatus.OK)public void test(Model model) &#123; System.out.println(\"返回值是void\");&#125; #接受数据及数据绑定 接收servlet的内置对象 接收占位符请求路径中的参数 接收普通的请求参数 获取cookie参数 基本数据类型的绑定 pojo对象绑定 集合绑定 ​ 1.接收Servlet的内置对象123456//这些对象的接收非常简单，只需要在方法形参中有该对象就能接收，不需要任何配置 @RequestMapping(value=\"show19\")public String test19(Model model, HttpServletRequest request, HttpServletResponse response, HttpSession session)&#123; model.addAttribute(\"msg\", request+\"&lt;br/&gt;\"+response+\"&lt;br/&gt;\"+session); return \"hello\";&#125; 2.接收普通的请求参数@RequestParam(value = “”, required = true/false, defaultValue = “”) 1.value: 参数名 2.required：是否必须， 默认为true，标识请求参数中必须包含该参数，如果不包含则抛出异常 3.defaultValue：默认参数值，如果设置了该值，required = true 将失效(即使手动设置了也会失效)，自动为false，如果请求中不包含该参数则使用默认值 @RequestParam和@PathVariable的区别： ​ @RequestParam比@PathVariable的区别是不需要在注解中使用占位符{xxx} 不设置required属性，那么默认提交参数name，因为required默认为true 123456@RequestMapping(value=\"show20\")public String test20(Model model,@RequestParam(value=\"name\")String name)&#123; model.addAttribute(\"msg\", \"使用@RequestParam接收到的参数为：\"+name); return \"hello\";&#125; 只有当手动设置了required为false时，才可以不用传递参数 123456@RequestMapping(value=\"show20\")public String test20(Model model,@RequestParam(value=\"name\",required=false)String name)&#123; model.addAttribute(\"msg\", \"使用@RequestParam接收到的参数为：\"+name); return \"hello\";&#125; 3.defaultValue属性如果设置了defaultValue属性，那么表示可以不用传递参数，一旦不传递参数，就使用默认值 12345@RequestMapping(value=\"show20\")public String test20(Model model,@RequestParam(value=\"name\",defaultValue=\"lisi\")String name)&#123; model.addAttribute(\"msg\", \"使用@RequestParam接收到的参数为：\"+name); return \"hello\";&#125; 一旦设置了默认值，那么required = true 就失效了，那怕手动设置required为true页没用，照样可以不传递参数 小结：只有配置了defaultValue属性，required属性就失效了 4.传统方式获取cookie1234567891011121314@RequestMapping(value = \"show21\")public String test21(Model model, HttpServletRequest request) &#123; Cookie[] cookies = request.getCookies(); if (cookies!=null) &#123;//由于第一次访问，cookie是null,因此需要手动判断一下 for (Cookie cookie : cookies) &#123; if (cookie.getName().equalsIgnoreCase(\"jsessionid\")) &#123; model.addAttribute(\"msg\", \"jsessionid：\" + cookie.getValue()); &#125; &#125; &#125; return \"hello\";&#125; 5.注解方式获取cookie注意：@CookieValue(“JSESSION”)必须大写 123456@RequestMapping(value = \"show22\")public String test22(Model model, @CookieValue(\"JSESSIONID\")String jsessionid) &#123; model.addAttribute(\"msg\", \"jsessionid：\" + jsessionid); return \"hello\";&#125; notes： ​ 如果是清除Chrome缓存后发送请求，此时cookie中没用数据，因此页无法在参数中使用注解获取jsession，那就会报400 此时当cookie中没有该属性时，可以设置参数非必须或者设置一个默认即可 123456@RequestMapping(value = \"show22\")public String test22(Model model, @CookieValue(value=\"JSESSIONID\",required = false)String jsessionid) &#123; model.addAttribute(\"msg\", \"jsessionid：\" + jsessionid); return \"hello\";&#125; 6.基本数据类型的绑定123456789101112131415@RequestMapping(\"show23\")public String test23(Model model, @RequestParam(\"name\") String name, @RequestParam(\"age\") Integer age, @RequestParam(\"isMarry\") Boolean isMarry, @RequestParam(\"income\") Float income, @RequestParam(\"interests\") String[] interests) &#123; System.out.println(name); System.out.println(age); System.out.println(isMarry); System.out.println(income); System.out.println(Arrays.toString(interests)); return \"hello\";&#125; 7.pojo对象的绑定SpringMVC会将请求参数名和pojo实体类中属性名(set 方法) 进行自动匹配如果名称一致，将把值填充到对象的属性中，并且支持级联（user.dept.id） 例如：自己编写User属性，idea在生成isMarry的setter和getter方法的时候会变成setMarry而非setIsMarry，需要手动更改。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class User &#123; private String name; private Integer age; private Boolean isMarry; private Float income; private String [] interests; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getIsMarry() &#123; return isMarry; &#125; public void setIsMarry(Boolean isMarry) &#123; this.isMarry = isMarry; &#125; public Float getIncome() &#123; return income; &#125; public void setIncome(Float income) &#123; this.income = income; &#125; public String[] getInterests() &#123; return interests; &#125; public void setInterests(String[] interests) &#123; this.interests = interests; &#125; @Override public String toString() &#123; return \"User [name=\" + name + \", age=\" + age + \", isMarry=\" + isMarry + \", income=\" + income + \", interests=\" + Arrays.toString(interests) + \"]\"; &#125;&#125; 12345@RequestMapping(value=\"show24\")public String test24(Model model,User user) &#123; model.addAttribute(\"msg\",user); return \"hello\";&#125; 当自动讲数据封装到User对象中之后，如果还想单独获取某个或几个参数，可以单独设置形参获取。 集合的绑定 12345@RequestMapping(value=\"show25\")public String test25(Model model,@RequestParam(\"ids\")List&lt;Long&gt; ids) &#123; model.addAttribute(\"msg\",\"打印参数：\"+ids.toString()); return \"hello\";&#125; 集合元素中为pojo，这个时候用一个UserVO来包装List集合： 123456789101112131415161718public class UserVO &#123; private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; @Override public String toString() &#123; return \"UserVO [users=\" + users + \"]\"; &#125;&#125; Controller方法 12345@RequestMapping(value=\"show26\")public String test26(Model model,UserVO userVO) &#123; model.addAttribute(\"msg\",\"打印参数：\"+userVO); return \"hello\";&#125; #jstl标签的使用springmvc虽然有自己的标签库，但是其使用并不方便，因此几乎没有人使用，甚至没有人知道其存在。因而一般还是使用的jstl标签。 JSTL：标准标签库 JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。 JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，SQL标签。 12345&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 找一个jsp页面，将其头信息复制该userList.jsp中： 1&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; 引入jstl核心标签库: 1&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; Jsonspringmvc提供了一种更为简便的方式传递数据。 @ResponseBody是把Controller方法返回值转化为JSON，称为序列化 当一个处理请求的方法标记为@ResponseBody时，表示该方法需要输出其他视图（json、xml），springmvc会通过默认的json转化器转化输出。 @RequestBody 是把接收到的JSON数据转化为Pojo对象，称为反序列化 转换json的常用方式：1、 Gson Google的工具，功能强大，但是效率稍逊。 2、 Fastjson 阿里的工具，效率高，但是功能稍逊。 3、 jackson springmvc内置的转换工具，功能和效率都有不俗的表现，在世界范围内使用较广。 引入依赖123456&lt;!-- Jackson Json处理工具包 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.4&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021/** * 将list集合响应成json数据 * @return */@RequestMapping(value=\"show28\")@ResponseBody//将数据响应成json格式的数据public List&lt;User&gt; test28() &#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); for(int i = 0;i&lt; 20;i++) &#123; User user = new User(); user.setId(i+1L); user.setUsername(\"zhangsan\"+i); user.setName(\"张三\"+i); user.setAge(18); list.add(user); &#125; return list;&#125; 报错：在使用jackson转换json数据时需要消息转换器HttpMessageConverter的支持，该消息转换器默认并没有开启。 12&lt;!--配置注解驱动--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 使用pojo接收接送数据@RequestBody：接收一个json并且转换成一个对象。接收一个json数据并反序列化为一个user对象。 12345678910111213/** * 将提交的json格式的数据封装到user对象中 * * @RequestBody()：自动将json数据序列化成一个user对象 * @param model * @param user * @return */@RequestMapping(value=\"show29\")public String test29(Model model,@RequestBody User user) &#123; model.addAttribute(\"msg\", user); return \"hello\";&#125; 使用String接收json数据12345@RequestMapping(value=\"show30\")public String test30(Model model,@RequestBody String user) &#123; model.addAttribute(\"msg\", user); return \"hello\";&#125; 解决中文乱码问题原因:使用的消息转换器换成了StringHttpMessageConverter，该转换器中使用的默认的编码为ISO_8859_1： 解决方案: 修改消息转换器中的编码集 将注解驱动修改如下：1、 设置String的消息转换器2、 该消息转换器中有一个构造函数可以设置编码集，因此只要直接赋值即可。 12345678&lt;!--配置注解驱动--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg index=\"0\" value=\"utf-8\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; @RestController有时如果在一个Contoller中所有的方法都是用来响应json格式数据的，那么如果有多个方法，就需要在多个方法上使用@ResponseBody，这样太麻烦，springmvc提供了一个@RestController，将该注解使用在Controller类上，那么该controller中的所有方法都默认是响应json格式的数据了。 #文件上传添加依赖123456&lt;!-- 文件上传 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 配置文件上传解析器需要在springmvc的配置文件中配置一个文件上传解析器（在spring-web包下），并且设置其解析器的某些参数，如上传文件大小和编码集等。 在springmvc-servlet.xml中配置：注意：必须配置id属性，并且名称固定为multipartResolver，否则无法使用. 1234567&lt;!--配置文件上传解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--设置上传文件大小--&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"&gt;&lt;/property&gt; &lt;!--设置上传文件编码集--&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"&gt;&lt;/property&gt;&lt;/bean&gt; defaultEncoding:用来设置上传文件名称的参数，如果不设置的话，问题如下: 保存的图片会出现乱码 1234567891011121314151617/** * 文件上传 * 需要通过MultipartFile类型来接收上传数据 * * @throws Exception * @throws IllegalStateException */@RequestMapping(\"show31\")public String test31(Model model,@RequestParam(\"file\")MultipartFile file) throws Exception&#123; if (file!=null) &#123; //将文件存储到指定路径 file.transferTo(new File(\"d://upload//\"+file.getOriginalFilename())); &#125; model.addAttribute(\"msg\", \"上传成功!\"); return \"hello\";&#125; 但是如果上传图片过大就会报500的错误 如此的话，用户体验不好，我们应该自定义一个错误页面来告诉用户，哪里出问题了。这是有一个处理器异常解析器抛出的错误，在请求到达我们自定义的Controller之前就抛出了异常。 自定义一个处理器异常解析器:​ 1、自定义处理器异常解析器实现HandlerExceptionResolver ​ 2、 在springmvc-servlet.xml中注册自定义的处理器异常解析器 1234567891011121314public class MyHandlerExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ModelAndView mv = new ModelAndView(); //判断是什么异常 if (ex instanceof MaxUploadSizeExceededException) &#123; //添加异常信息 mv.addObject(\"msg\",\"上传文件大小不得超过5个字节\"); mv.setViewName(\"hello\"); &#125; return mv; &#125;&#125; 123&lt;!--装配自定义处理器错误解析器--&gt;&lt;bean class=&quot;cn.itcast.exception.MyHandlerExceptionResolver&quot;&gt;&lt;/bean&gt; 当上传多个的时候后台使用数据接收遍历循环12345678910@RequestMapping(\"show32\")public String test32(Model model,@RequestParam(\"files\")MultipartFile[] files) throws Exception&#123; for (MultipartFile file : files) &#123; if (file!=null) &#123; file.transferTo(new File(\"d://upload//\"+file.getOriginalFilename())); &#125; &#125; model.addAttribute(\"msg\", \"上传成功\"); return \"hello\";&#125; #转发和重定向返回值为字符串时，默认为视图名称。当返回值字符串是以”forward:”或者”redirect:”开头，则会被认为是转发或者重定向。 使用方式如下： 转发：forward:/hello/show.do(绝对路径)或者forward:show.do(相对路径) 重定向：redirect:/hello/show.do(绝对路径)或者redirect:show.do(相对路径) /：表示绝对路径，指的是localhost:8080/springmvc（项目名称可以省略） 不带/：表示相对路径，相对于当前请求的路径 如果当前请求是：localhost:8080/springmvc（项目名称可以省略）/hello/show32 那么不带/：表示localhost:8080/springmvc（项目名称可以省略）/hello/ forward redirect 拦截器HandlerExecutionChain是一个执行链，当请求到达DispatchServlet时，DispatchServlet根据请求路径到HandlerMapping查询具体的Handler，从HandlerMapping返回执行链给DispatcherServlet，其中包含了一个具体的Handler对象和Interceptors（拦截器集合）。 拦截器一般用于对处理器进行预处理和后处理。 应用场景： 1、权限检查：如登录检测，进入处理器前检测用户是否登录，如果没有登陆直接返回到登录页面。 2、性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，统计处理器执行使用了多少时间。 springmvc的拦截器接口（HandlerInterceptor）定义了三个方法： n preHandle调用Handler之前执行，称为预处理回调方法 返回值：true表示放行，后续业务逻辑继续执行 false表示被拦截，后续业务逻辑不再执行，但之前返回true的拦截器的请求完成回调方法会倒叙执行 n postHandle调用Handler之后执行，称为后处理回调方法 n afterCompletion视图渲染完成之后执行，可以称为请求完成回调方法 拦截器的配置过程： 1、 编写自定义拦截器实现HandlerInterceptor 2、 在springmvc-servlet.xml中注册自定义拦截器 1234567891011121314151617181920212223242526272829303132public class MyInterceptor1 implements HandlerInterceptor &#123; /** * 在Handler方法执行之前执行，顺序执行 * 返回值，返回true拦截器放行 false拦截器不通过，后续业务逻辑不再执行 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"MyInterceptor1，预处理回调方法正在执行\"); return true; &#125; /** *在执行完Handler方法之后执行，倒序执行 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"MyInterceptor1，后处理回调方法正在执行\"); &#125; /** * 在视图渲染完成之后执行，倒序执行 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"MyInterceptor1，请求完成回调方法正在执行\"); &#125;&#125; 配置自定义拦截器 123456789/： 表示绝对路径：http://localhost:8080/springmvc/*：表示绝对路径下的任意一级路径：http://localhost:8080/springmvc/xxx/**：表示绝对路径下的任意多级目录：http://localhost:8080/springmvc/xxxhttp://localhost:8080/springmvc/xxx/xxx/xxx注意：之所以请求url中看不到springmvc，是因为在pom.xml中配置了tomcat插件，配置了path为/而省略了项目名称springmvc在springmvc-servlet.xml中配置自定义的拦截器，/**：拦截所有请求 12345678&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--拦截所有请求--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.qiezicy.interceptor.MyInterceptor1\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 当有多个拦截器时 12345678910111213&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--拦截所有请求--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.qiezicy.interceptor.MyInterceptor1\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--拦截所有请求--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.qiezicy.interceptor.MyInterceptor2\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 小结： 拦截器的预处理回调方法依次执行，后处理回调方法和请求完成回调方法倒序执行当预处理回调方法返回false时，后续的拦截器以及Handler方法不再执行，但它前面的预处理回调方法返回值为true的拦截器的请求完成回调方法会倒序执行。请求完成回调方法会在视图渲染完成之后才去执行。 中断拦截器的预处理回调方法 当有多个拦截器的时候， 中断第一个拦截器的预处理回调方法，将第一个拦截器的预处理回调方法返回值设置为false 1234567891011121314151617181920212223242526272829303132public class MyInterceptor1 implements HandlerInterceptor &#123; /** * 在Handler方法执行之前执行，顺序执行 * 返回值，返回true拦截器放行 false拦截器不通过，后续业务逻辑不再执行 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"MyInterceptor1，预处理回调方法正在执行\"); return false; &#125; /** *在执行完Handler方法之后执行，倒序执行 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"MyInterceptor1，后处理回调方法正在执行\"); &#125; /** * 在视图渲染完成之后执行，倒序执行 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"MyInterceptor1，请求完成回调方法正在执行\"); &#125;&#125; 结果：后续方法不再执行 中断第二个拦截器的预处理回调方法（先将第一个恢复） 将第二个拦截器的预处理回调方法返回值设置为false: 1234567891011121314151617181920212223242526272829303132Public class MyInterceptor2 implements HandlerInterceptor &#123; /** * 在Handler方法执行之前执行，顺序执行 * 返回值，返回true拦截器放行 false拦截器不通过，后续业务逻辑不再执行 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"MyInterceptor2，预处理回调方法正在执行\"); return false; &#125; /** *在执行完Handler方法之后执行，倒序执行 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"MyInterceptor2，后处理回调方法正在执行\"); &#125; /** * 在视图渲染完成之后执行，倒序执行 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"MyInterceptor2，请求完成回调方法正在执行\"); &#125;&#125; 结果： ​ 执行测试：执行完连个预处理回调方法后，倒叙执行请求完成回调方法，由于第二个连接器的预处理回调方法返回false,因此自定义处理器不再执行，然后开始倒叙执行请求完成回调方法，并且没有机会执行第二个拦截器的请求完成回调方法，而是从第一个拦截器的请求完成回调方法开始执行。 #POST和GET乱码解决(tomcat7)在使用Post提交请求参数的时候，一旦参数是中文的，那么controller中获取到的数据数据就会乱 编写自定义处理器12345@RequestMapping(\"show36\")public String test36(@RequestParam(\"name\") String name) &#123; System.out.println(name); return \"hello\";&#125; 当传来参数是中文时，会产生乱码 解决方案: 手动配置post请求编码过滤器 Spring-web给我们提供了解决post请求编码的过滤器： 12345678910111213&lt;!--post请求乱码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 解决get请求乱码文件1234567891011121314&lt;plugins&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt;&lt;!-- 相当于工程名称，一旦配置了/，那么在访问时可以省略工程名称 --&gt; &lt;!--设置get请求编码集--&gt; &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;","categories":[],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"htts://cocked.github.io/tags/springmvc/"}]},{"title":"01spring入门","slug":"01spring入门","date":"2017-03-31T09:21:56.000Z","updated":"2018-09-16T09:29:07.550Z","comments":true,"path":"2017/03/31/01spring入门/","link":"","permalink":"htts://cocked.github.io/2017/03/31/01spring入门/","excerpt":"","text":"#Spring概述 Spring是分层的、JavaSE/EE一站式(full-stack)、轻量级开源框架。以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了表现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 Spring的发展历史： 1997年IBM提出了EJB的思想 1998年，SUN制定开发标准规范EJB1.0 1999年，EJB1.1发布 2001年，EJB2.0发布 2003年，EJB2.1发布 2006年，EJB3.0发布 **Rod Johnson**（****spring****之父） Expert One-to-One J2EE Design andDevelopment(2002) 阐述了J2EE使用EJB开发设计的优点及解决方案 Expert One-to-One J2EE Developmentwithout EJB(2004) 阐述了J2EE开发不使用EJB的解决方式（Spring雏形） Spring的优势spring是为了解决javaEE实际问题 1.方便解耦，简化开发 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 2.AOP编程的支持 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP(面向对象)实现的功能可以通过AOP轻松应付。 3. 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 4. 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 5. 方便集成各种优秀框架 Spring可以降低各种框架的使用难度，提供了对各种优秀框架Struts、Hibernate、Hessian(远程通讯，类似于webService)、Quartz(定时任务)等的直接支持。 6. 降低JavaEE API的使用难度 Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 Spring的体系结构核心容器(Core Container) 包括Core、Beans、Context、EL模块。 1：Core和Beans模块提供了Spring最基础的功能，提供IoC和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。 2：Context模块基于Core和Beans来构建，它提供了用一种框架风格的方式来访问对象，有些像JNDI注册表。Context封装包继承了beans包的功能，还增加了国际化（I18N）,事件传播，资源装载，以及透明创建上下文，例如通过servlet容器，以及对大量JavaEE特性的支持，如EJB、JMX。核心接口是ApplicationContext。 3：Expression Language，表达式语言模块，提供了在运行期间查询和操作对象图的强大能力。支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。 数据访问/集成部分(Data Access/Integration) 1：JDBC模块，提供对JDBC的抽象，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。 2：ORM模块，提供了常用的”对象/关系”映射APIs的集成层。 其中包括JPA、JDO、Hibernate 和 iBatis 。利用ORM封装包，可以混合使用所有Spring提供的特性进行”对象/关系”映射，如简单声明性 事务管理 。 3：OXM模块，提供一个支持Object和XML进行映射的抽象层，其中包括JAXB、Castor、XMLBeans、JiBX和XStream。 4：JMS模块，提供一套”消息生产者、消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 5：Transaction模块，支持程序通过简单声明性 事务管理，只要是Spring管理对象都能得到Spring管理事务的好处，即使是POJO，也可以为他们提供事务。 Web 1：Web模块，提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问、以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问 2：Web-Servlet模块，提供了Web应用的Model-View-Controller（MVC）实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。 3：Web-Struts模块， 提供了对Struts集成的支持，这个功能在Spring3.0里面已经不推荐了，建议你迁移应用到使用Struts2.0或Spring的MVC。 4：Web-Portlet模块，提供了在Portlet环境下的MVC实现 AOP 1：AOP模块，提供了符合AOP 联盟规范的面向方面的编程实现，让你可以定义如方法拦截器和切入点，从逻辑上讲，可以减弱代码的功能耦合，清晰的被分离开。而且，利用源码级的元数据功能，还可以将各种行为信息合并到你的代码中 。 2：Aspects模块，提供了对AspectJ的集成。 3：Instrumentation模块， 提供一些类级的工具支持和ClassLoader级的实现，可以在一些特定的应用服务器中使用。 Test 1：Test模块，提供对使用JUnit和TestNG来测试Spring组件的支持，它提供一致的ApplicationContexts并缓存这些上下文，它还能提供一些mock对象，使得你可以独立的测试代码。 Spring核心IoC（Inverse ofControl 控制反转）： 将对象创建权利交给Spring工厂进行管理。 IoC底层实现：工厂（设计模式）+反射（机制） + 配置文件 AOP（Aspect OrientedProgramming 面向切面编程），基于动态代理的功能增强方式。 高内聚、低耦合耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。 耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：高内聚，低耦合。 内聚与耦合： 内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 解释： 程序的耦合 耦合：程序间的依赖关系 包括： 类之间的依赖 方法间的依赖 解耦： 降低程序间的依赖关系 实际开发中： 应该做到：编译期不依赖，运行时才依赖。 解耦的思路： 第一步：使用反射来创建对象，而避免使用 new 关键字。 第二步：通过读取配置文件来获取要创建的对象全限定类名 Spring中工厂的类结构BeanFactory和 ApplicationContext 的区别 BeanFactory 才是 Spring 容器中的顶层接口。 ApplicationContext 是它的子接口。 BeanFactory 和 ApplicationContext 的区别： 创建对象的时间点不一样。 ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。 BeanFactory：什么使用什么时候创建对象。 Beanfactory的用法： 1BeanFactory ac = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\")); ApplicationContext 接口的实现类 ClassPathXmlApplicationContext： 它是从类的根路径下加载配置文件 推荐使用这种 FileSystemXmlApplicationContext： 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext: 当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 #Bean的相关的配置用于配置对象，让spring创建管理。默认使用无参的构造方法，如果没有无参构造方法则会创建失败。 1.Bean标签的属性：id:指定对象的唯一标识名称，里面不能出现特殊字符 name：没有使用约束中的唯一约束（理论上可以出现重复，但是实际开发中不能出现）里面可以出现特殊字符。 class:指定类的全限定名称（包名+类名） 2.Bean的作用范围的配置scope:指定bean的作用范围 singleton:单例（默认值 Spring会采用单例模式创建这个对象） prototype:多列 （Struts2和Spring整合一定会用到） 单例对象：scope=&quot;singleton&quot; 一个应用只有一个对象的实例。它的作用范围就是整个应用。 生命周期： 对象出生：当应用加载，创建容器时，对象就被创建了。 对象活着：只要容器在，对象一直活着。 对象死亡：当应用卸载，销毁容器时，对象就被销毁了。 多例对象：scope=&quot;prototype&quot; 每次访问对象时，都会重新创建对象实例。 生命周期： 对象出生：当使用对象时，创建新的对象实例（getBean）。 对象活着：只要对象在使用中，就一直活着。 对象死亡：当对象长时间不用时，被java的垃圾回收器回收了。 生命周期方法： init-method：指定类中的初始化方法名称(生命周期相关)。 destroy-method：指定类中销毁方法名称(生命周期相关)。 request:web项目中，spring将创建的对象，存入request域中session globalsession：web项目中，如果是服务器集群环境，应用在整个集群中；如果没有服务器集群，相当于session 3.Bean生命周期init-method：指定类中的初始化方法名称，一般用于执行资源的初始化 destory-method：指定类的初始化方法名称，一般用于执行资源的释放 4.Bean的实例化方式1.无参构造方式 2.静态工厂实例化的方式 3.实例工厂 #spring的属性注入1.构造方法的属性注入1234567891011121314151617181920&lt;!-- 将service 实现类装配到容器中 --&gt;&lt;bean id=\"accountDao\" class=\"com.qiezicy.dao.impl.AccountDaoImpl\"/&gt;&lt;bean id=\"accountService\" class=\"com.qiezicy.service.impl.AccountServiceImpl\"/&gt;&lt;!-- 使用构造函数注入属性值： 涉及的标签：constructor-arg 属性：index：指定参数在构造函数参数列表的索引位置 name: 指定参数在构造函数中的名称，指定给谁赋值 ================= 上面三个属性是指给谁赋值，下面属性是指赋什么值 value：它能赋的值是基本数据类型和String类型 ref：它能赋的值是其他bean类型，也就是说，必须得在配置文件中配置过的bean--&gt;&lt;bean id=\"accountServiceImpl2\" class=\"com.qiezicy.service.impl.AccountServiceImpl2\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"/&gt; &lt;constructor-arg name=\"age\" value=\"12\"/&gt; &lt;constructor-arg name=\"accountDao\" ref=\"accountDao\"/&gt;&lt;/bean&gt; 2.set方法的属性注入123456789101112 &lt;bean id=\"bean1\" class=\"com.qiezi.xmlpeizhi.Bean1\"&gt; &lt;property name=\"name\" value=\"BMW\"/&gt; &lt;property name=\"price\" value=\"80\"/&gt; &lt;/bean&gt; // 设置对象类型的属性 // name 属性：是标识要注入属性的setName 方法后面的 Name 单词名称首字母小写 &lt;bean id=\"bean2\" class=\"com.qiezi.xmlpeizhi.Bean2\"&gt; &lt;property name=\"name\" value=\"BMW\"/&gt;// 这里的 第一个name = \"bean1\" 是 类中的名字 ref是连接 上一个属性的id &lt;property name=\"bean1\" ref=\"bean1\"/&gt; &lt;/bean&gt; 3.p名称空间的属性注入(spring2.5以后)首先引入p名称空间完成属性的注入 1xmlns:p = \"http://www.springframework.org/schema/p\" 1.普通属性 p:属性名 = “值” 2.对象属性 p:属性名-ref = “值” 12&lt;bean id=\"bean1\" class=\"com.qiezi.xmlpeizhi.Bean1\" p:name=\"凯迪拉克\" p:prince=\"20\"&gt;&lt;/bean&gt;&lt;bean id=\"bean1\" class=\"com.qiezi.xmlpeizhi.Bean2\" p:name=\"张三\" p:bean1-ref=\"bean1\"&gt;&lt;/bean&gt; 4.SplEL的属性注入(spring3.0以后)Spring Expression Language，Spring的表达式语言\u0004。 {SpEl} 12345678910&lt;bean id=\"carInfo\" class=\"com.qiezi.xmlpeizhi.CarInfo\"/&gt;&lt;bean id=\"car2\" class=\"com.qiezi.xmlpeizhi.car2\"&gt; &lt;property name=\"name\" value=\"#&#123;carInfo.name&#125;\"&gt;&lt;/property&gt; &lt;property name=\"price\" value=\"#&#123;carInfo.calculatorPrice()&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"employee\" class=\"com.qiezi.xmlpeizhi.Employee\"&gt; &lt;property name=\"name\" value=\"#&#123;'赵六'&#125;\"&gt;&lt;/property&gt; &lt;property name=\"car2\" value=\"#&#123;car2&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 5.集合类型属性注入123456789101112131415161718192021222324252627282930313233343536373839&lt;bean id=\"collection\" class=\"com.qiezi.collectionBean.demo01\"&gt; // 数组类型 &lt;property name=\"arrs\"&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; // 注入list 集合 &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;赵三&lt;/value&gt; &lt;value&gt;李六&lt;/value&gt; &lt;value&gt;老七&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; // 注入 set 集合 &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bb&lt;/value&gt; &lt;value&gt;cccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; // 注入 map 集合 &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"aaa\" value=\"111\" /&gt; &lt;entry key-ref=\"bean1\" value=\"211\" /&gt; &lt;entry key=\"cc\" value-ref=\"bean2\" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; #分模块开发的配置1.在加载配置文件的时候，加载多个 1ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml1\",\"applicationContext.xml2\"); 2.在一个配置文件中引入多个配置文件 1&lt;import resource=\"applicationContext2.xml\"/&gt; #spring的IOC注解12345&lt;!-- 配置资源文件 --&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"&gt;&lt;/context:property-placeholder&gt; &lt;!--配置注解扫描的包：声明到指定的包下去进行扫描，如果发现类上有对应的注解 将其装配到容器中--&gt; &lt;context:component-scan base-package=\"com.qiezicy\"&gt;&lt;/context:component-scan&gt; 1.spring4还需要引入aop的包 2.导入包logging-1.1.1jar, log4j-1.2.15.jar, aop-4.2.4, beans, context, core, expression 3.创建配置文件并引入约束 4.配置组件扫描（那些包下的类使用IOC注解） 1.在类上添加注解@Component(“”) 组件 作用： 在类上使用该注解，把资源让spring来管理。相当于在xml中配置一个bean。 属性： value：指定bean的id。如果不指定value属性，默认bean的id是当前类的类名。首字母小写。 @Component 注解：相当于配置了标签 value= &quot;accountService&quot;:相当于配置了bean标签的id属性，单独配置value时，可以省略value属性名称。 1.修饰一个类，将我们这个类交给spring管理 2.这个注解有三个衍生注解（功能类似） 修饰类 ​ @Controller web层 ​ @Service service层 ​ @Repository dao层 2.设置属性的值注解方式：可以没有set方法 ​ 1.有set方法需要将属性注入的注解添加到set方法 ​ 2.属性如果没有set方法，需要将属性注入到注解添加到属性上 设置普通属性的 值 @Value(“”) ：设置普通属性的 值 设置对象属性的 值 @Autowired 注解的方式按照类型的方式设置 ， xml是按照名称的方式进行设置 可以用@Autowired和@Qualified(value=”userDao”) 一起使用 强制按照名称的方式进行配置 上面两种的注解 可以使用一个替代类型是一套spring实现的一套接口规范 自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他bean类型。当有多个类型匹配时，使用要注入的对象的变量名称作为bean的id，在spring容器查找，找到了也可以注入成功。找不到就报错。 自动安装类型注入：比如说注入IAccount 自动去spring容器中寻找其子类比如说IAccountImpl在spring中，则将其注入到IAccount中 ，当有多个类型匹配时，使用要注入对象的变量名称作为bean的id在spring中找到并匹配，还可以配合@Qualifier(value = “xxx”)指定某一个id的bean进行注入。当都不喜欢用这两个的时候，可以直接使用@Resource(name = “xxxx”) 指定某一id的bean进行**注入**。 它只能注入其他bean类型：是受spring管理的bean @Qualifier 作用： 在自动按照类型注入的基础之上，再按照Bean的id注入。它在给字段注入时不能独立使用，必须和@Autowire一起使用；但是给方法参数注入时，可以独立使用。 属性： value：指定bean的id。 @Resource 按照名称注入 来对 对象设置属性 1234作用： 直接按照Bean的id注入。它也只能注入其他bean类型。 属性： name：指定bean的id。 @Value 作用： 注入基本数据类型和String类型数据的 属性： value：用于指定值 123// value 可以读取资源文件中的数据，但是必须现在applicationContext.xml中声明@Value(\"$&#123;jdbc.url&#125;\")private String url; 3.Bean的其他注解1.声明周期相关的注解 @PostConstruct：初始化方法 @PreDestroy ：销毁方法 2.Bean的作用范围的注解 @Scope ：作用范围 123456位于类上作用： 指定bean的作用范围。 属性： value：指定范围的值。 取值：singleton prototype request session globalsession ​ 使用：@Scope(“prototype”) singleton 默认单例 prototype 多例 request session globalsession 3.xml和注解的比较 ​ xml可以使用任何场景 结构清晰，维护方便 ​ 注解：有些地方不能用 比如说类不是自己写的，但是开发方便 4.可以使用xml管理Bean，注解完成属性注入 5.注意事项： ​ 扫描是为了扫描类上的注解 ​ 在没有扫描的情况下，使用属性注入的注解 @Resource @Value @Autowired @Qulifier @Configuration1234567891011121314作用： 用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。 示例代码： /** * spring的配置类，相当于applicationContext.xml文件 */@Configuration public class SpringConfiguration &#123;&#125;注意： 我们已经把配置文件用类来代替了，但是如何配置创建容器时要扫描的包呢？ 请看下一个注解。 @ComponentScan123456789101112131415161718作用： 用于指定spring在初始化容器时要扫描的包。作用和在spring的xml配置文件中的： &lt;context:component-scan base-package=\"cn.itcast\"&gt;&lt;/context:component-scan&gt;属性： Value（单独使用可省略）：用于指定要扫描的包。和标签中的basePackages属性作用一样。 示例代码： /** * spring的配置类，相当于bean.xml文件 * */@Configuration@ComponentScan(\"com.qiezicy\")public class SpringConfiguration &#123;&#125; 注意： 我们已经配置好了要扫描的包，但是数据源和QueryRuner对象如何从配置文件中移除呢？ 请看下一个注解。 @Bean1234567891011121314151617181920作用： 该注解只能写在方法上，将方法的返回值作为一个bean,并且放入spring容器。 属性： name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）。示例代码：@Bean(name=\"dataSource\")public DataSource createDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/spring\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"111\"); return dataSource;&#125; 这里添加一个小贴士：其中的id可以选择不写是 因为看是否有人用到它，如果不写则这个id则默认是方法名称注意: 我们已经把数据源和QueryRunner从配置文件中移除了，此时可以删除bean.xml了。 但是由于没有了配置文件，创建数据源的配置又都写死在类中了。如何把它们配置出来呢？ 请看下一个注解。 @PropertySource123456789101112131415161718192021222324252627282930313233343536作用： 用于加载.properties文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties配置文件中，就可以使用此注解指定properties配置文件的位置。 属性： value[]：用于指定properties文件位置。如果是在类路径下，需要写上classpath:示例代码：//加载外部资源文件@PropertySource(value = &#123;\"classpath:jdbc.properties\"&#125;)public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driverClass&#125;\") private String driverClassName; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(name=\"jdbcTemplate\") public JdbcTemplate createJdbcTempalte(@Qualifier(\"dataSource\") DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125; @Bean(name=\"dataSource\") public DataSource createDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClassName); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; @Import1234567891011121314151617181920作用： 用于导入其他配置类，在引入其他配置类时，其他类上可以不用再写@Configuration注解。当然，写上也没问题。 属性： value[]：用于指定其他配置类的字节码。 示例代码：@Configuration@ComponentScan(\"cn.itcast\")@Import(value = &#123; JdbcConfig.class &#125;)public class SpringConfiguration &#123;&#125;@Configuration//写不写都行@PropertySource(value = &#123; \"classpath:jdbc.properties\" &#125;)public class JdbcConfig &#123;&#125;注意： 我们已经把要配置的都配置好了，但是新的问题产生了，由于没有配置文件了，如何获取容器呢？ go on----》 通过注解获取容器 12ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); 4.spring整合Junit1.导入坐标 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;此处需要注意的是，spring5及以上版本要求junit的版本必须是4.12及以上，否则用不了。 2.在测试类上添加如下注解 @RunWith(SpringJUnit4ClassRunner.class) 12345@RunWith(SpringJUnit4ClassRunner.class)作用： 替换掉junit的运行器,换成一个可以初始化spring容器的运行器。属性： value：单独配置时，value属性名称可以省略，配置SpringJUnit4ClassRunner.class来代替原来junit的运行器 @ContextConfiguration(locations = {“classpath:applicationContext.xml”}) 这是在有配置文件的情况下 如果没有配置文件，纯注解的情况下则使用 @ContextConfiguration(classes = {SpringConfiguration.class}) 作用： 加载配置类或者xml配置文件 属性： value[]：用来指定xml配置文件的路径 class[]: 用来指定配置类 5.注解总结5.1用于装配Bean的注解 @Component(value = “xxx”) ​ 一般用于将三层中的bean装配到容器中，value可以省略，value的属性值作为bean的id @Controller(value = “xxx”) ​ 一般用于将web层装配到容器中，使用方法和@Component(value = “xxx”)一模一样 @Service(value = “xxx”) ​ 一般用于将service层装配到容器中，使用方法和@Component(value = “xxx”)一模一样 @Repository(value = “xxx”) ​ 一般用于将dao层装配到容器中，使用方法和@Component(value = “xxx”)一模一样 5.2用于属性注入的注解 @Autowired ​ 只能安装bean类型注入，如果有多个类型匹配，默认将属性名称作为id去容器中查找 @Qualifier ​ 一般和@Autowired配合使用，用来注入指定id的bean，做方法的参数中可以独立使用 @Resource ​ 用来注入指定id的bean类型，相当于@Autowired + @Qualifier @Value ​ 只能注入基本类型等数据，不能注入bean类型，可以使用#{}在资源文件中获取数据，前提是，外部资源文件被加载 5.3作用域的注解 @Scope ​ 用于指定bean的作用域，一般是singleton和prototype 5.4与生命周期相关的注解 @PostConstruct ​ 用于指定某一个方法为初始化方法 @PreDestory ​ 用于指定某一方法为销毁方法 5.5其他配置类相关的 @Configuration ​ 声明一个类为配置类，用于代替applicationContext.xml @ComponentScan ​ 用于开启注解扫描的包 @Import ​ 用于导入其他类的 @Bean ​ 用于将方法返回的bean类型的对象装配到容器中 5.6与Junit相关的 @RunWith ​ 用于替换底层的运行器，初始化spring容器的 @ContextConfiguration ​ 用于指定配置文件或者配置类的 #AOP在软件行业中，AOP为Aspect Oriented Programming 面向切面编程，通过预编译的方式和运行时期动态代理实现程序功能的统一维护的一种技术。AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑之间的耦合度降低，提供程序的可用性，同时提高了开发效率 AOP实现原理动态代理 ​ 特点： ​ 什么时候开始功能增加了，什么时间就创建这个代理对象，然后对目标对象进行功能的增强，不可见，一开始并不存在，在使用目标对象的方法的过程中才 出现。 ​ 1.JDK动态代理（基于接口的动态代理） 只能对实现了接口的类产生代理。要求被代理类最少实现一个接口 ​ ​ 2.Cglib动态代理（基于子类的动态代理） （类似于Javassist第三方代理技术）：可以对没有实现接口的类产生代理对象。要求被代理对象不能用final修饰的类（最终类） spring底层可以自动进行切换使用这两种 AOP相关术语123456class demo&#123; public void save()&#123;&#125;; public void find()&#123;&#125;; public void update()&#123;&#125;; public void delete()&#123;&#125;;&#125; Joinpoint：连接点，可以被拦截到的点，增删改差都可以被增强，这些方法被称为连接点 Pointcut：切入点，真正被拦截到的点，，如果只对save方法的增强，save称为切入点 Advice：通知、增强 方法层面的增强 现在对save方法进行权限校验，权限校验的方法称为通知。 Introduction：引介 是类层面的增强 Target：被增强的对象 如果demo 被增强 则demo就是Target Weaving：植入，通知应用（Advice）到目标（Target）过程 将权限校验的方法的代码应用到UserDao的save方法上的过程被称为植入 Proxy：代理对象 Aspect：切面，多个通知和多个切入点组合！！！ #springAOP入门AspectJ的XMl方式spring的AOP简介 AOP思想最早由AOP联盟组织提出的，spring使用这种思想的最好的框架 1.引入jar包 2.导入配置文件 3.编写类 4. 12345// 引入spring和Junit4整合的jar @RunWith(SpringJUnit4ClassRunner.class)// 加载配置文件 直接可以调用 工厂类 不用每次都创建了@ContextConfiguration(\"classpath:applicationContext.xml\") AspectJ切入点表达式说明123456789101112131415161718192021222324252627execution:匹配方法的执行(常用) execution(表达式)表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))写法说明： 全匹配方式： public void com.qiezycy.service.impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略 void com.qiezycy.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用*号，表示任意返回值 * com.qiezycy.service.impl.AccountServiceImpl.saveAccount() 包名可以使用*号，表示任意包，但是有几级包，需要写几个* * *.*.*.*.AccountServiceImpl.saveAccount() 使用..来表示当前包，及其子包 * com..AccountServiceImpl.saveAccount() 类名可以使用*号，表示任意类 * com..*.saveAccount() 方法名可以使用*号，表示任意方法 * com..*.*() 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数 * com..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型 * com..*.*(..) 全通配方式： * *..*.*(..)注： 通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。 execution(* com.qiezycy.service.impl.*.*(..)) 常用标签 aop:config 作用：用于声明开始aop配置 2.aop:aspect 作用：用于配置切面 属性：id给切面提供一个唯一标识 ref：引用配置好的通知类bean的id 3.aop:pointcut 作用：用于配置切入点表达式 属性：expression：用于定义切入点表达式 ​ id：用于给切入点表达式提供一个唯一标识 4.aop:before 作用：用于配置前置通知 属性： ​ method：指定通知中方法的名称 ​ pointcut：定义切入点表达式 ​ pointcut-ref ：指定切入点表达式的引用 5.aop:after-returning 作用：用于配置后置通知 属性： ​ method：指定通知中放的名称 ​ pointcut：定义切入点表达式 ​ pointcut-ref：指定切入点表达式的引用 6.aop:after-throwing 作用： ​ 用于配置异常通知 属性： ​ method：指定通知中方法的名称 ​ pointcut：定义切入点表达式 ​ pointcut-ref：指定切入点表达式的引用 7.aop:after 作用： ​ 用于配置最终通知 属性： ​ method：指定通知中方法的名称 ​ pointcut：定义切入点表达式 ​ pointcut-ref：指定切入点表达式的引用 8.aop:around 作用： ​ 用于配置环绕通知 属性： ​ method：指定通知中方法的名 ​ pointcut：定义切入点表达式 ​ pointcut-ref：指定切入点表达式的引用 说明： ​ 它是spring框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 注意： 通常情况下，环绕通知都是独立使用的 注解配置AOP1.在配置文件中开启注解扫描和注解AOP 12345&lt;!--开启注解扫描--&gt;&lt;context:component-scan base-package=\"com.qiezicy\"&gt;&lt;/context:component-scan&gt;&lt;!--开启注解AOP--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 2.注解装配service实现类 3.通知上使用注解配置并声明该类是一个切面类 1234@Component(\"logger\")@Aspect//表示当前类是一个切面类（也可以称之为通知类）public class Logger &#123;&#125; 4.使用注解配置前置通知类型 123456789101112@Before 作用： 把当前方法看成是前置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 @Before(\"execution(* com.qiezicy.service.impl.*.*(..))\") //前置通知 public void beforePrintLog() &#123; System.out.println(\"前置通知执行了\"); &#125;其他方法类似 后置通知 12345@AfterReturning作用： 把当前方法看成是后置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 异常通知 12345@AfterThrowing作用： 把当前方法看成是异常通知。属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 最终通知 12345@After 作用： 把当前方法看成是最终通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 环绕通知 1234567891011121314151617181920212223242526272829@Around作用： 把当前方法看成是环绕通知。属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 /** * 环绕通知 * spring框架为我们提供了一个接口，该接口可以作为环绕通知的方法参数来使用 * ProceedingJoinPoint。当环绕通知执行时，spring框架会为我们注入该接口的实现类。 * 它有一个方法proceed()，就相当于invoke，明确的业务层方法调用 * * spring的环绕通知： * 它是spring为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ @Around(\"pt1()\") public Object around(ProceedingJoinPoint point) &#123; Object object = null; try &#123; System.out.println(\"环绕通知\"); point.proceed(); &#125; catch (Throwable throwable) &#123; System.out.println(\"异常通知\"); throwable.printStackTrace(); &#125;finally &#123; System.out.println(\"最终通知\"); &#125; return object; &#125; 配置切入点 12345678910@Pointcut作用： 指定切入点表达式属性： value：指定表达式的内容// 配置切入点 @Pointcut(\"execution(* com.qiezicy.service.impl.*.*(..))\") public void pt1() &#123; &#125; ps：如果开启全注解配置 需要创建一个配置类，与之前类似，只是多加了个AOP注解扫描 12345@Configuration//声明这是个配置类@ComponentScan(\"cn.itcast\")//配置包扫描@EnableAspectJAutoProxy//开启AOP的注解扫描public class SpringConfiguration &#123;&#125; #事务控制事务控制API介绍1.PlatformTransactionManager ​ 平台事务管理器，是spring真正管理事务的对象，是一个接口 实现类： ​ DataSourceTransactionManager：针对JDBC和Mybatis事务管理 ​ HibernateTransactionManager：针对Hibernate事务管理 涉及到的两个接口： ​ TransactionDefinition：事务定义的对象 ​ 事务的隔离级别 ​ 事务的传播行为 ​ 事务是否只读 ​ 事务超时信息 ​ TransactionStatus：事务状态信息的对象 ​ 是否有保存点 ​ 是否已经完成 ​ 等。。。 spring框架进行事务的管理，首先使用TransactionDefinition对事务进行定义，通过PlatformTransactionManager根据TransactionDefinition的定义信息进行事务的管理。在事务的管理过程中产生一系列的状态：保存到TransactionStatus中。 2.TransactionDefinition 事务的定义信息对象，里面有如下方法 获取事务对象名称 -String getName() 获取事务隔离级别 -int getlsolationLevel()获取事务的超时时间 -int getTimeout() 获取事务是否只读 -boolean isReadOnly() 读写型事务：增删该开启事务；只读型事务：执行查询时，也会开启 事务的隔离级别事务隔离反映事务提交并发访问时的处理态度 ISOLATION_DEFAULT 默认级别，归属于下列某一种 ISOLATION_READ_UNCOMMITTED 可以读取未提交数据 ISOLATION_REPEATABLE_READ 是否读取其他事务提交修改后的数据，解决不可重复读问题（MySQL默认级别） ISOLATION_SERIALIZABLE 是否读取其他事务提交添加后的数据，解决幻读问题 事务的传播行为传播行为解决的问题：一个业务层事务调用另一个业务层事务时，事务之间关系如何处理 事务传播行为PROPAGATION的取值： ​ REQUIRED支持当前事务，如果不存在，就新建一个（默认的传播行为） ​ 应用：删除客户 删除订单 处于同一个事务，如果 删除订单失败，删除客户也要回滚 ​ SUPPORTS 支持当前事务，如果不存在，就不使用事务 ​ MANDATORY支持当前事务，如果不存在，抛出异常 ​ REQUIRES_NEW：如果有事务存在，挂起当前事务，创建一个新的事务 ​ 应用：生成订单，发送通知邮件，通知会创建一个新的事务，如果邮件失败，不影响订单生成 ​ NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务 ​ NEVER：以非事务方式运行，如果有事务存在，抛出异常 ​ NESTED：如果当前事务存在，则嵌套事务执行 ​ -依赖于JDBC3.0提供SavePoint技术 ​ -删除客户 删除订单，在删除客户后，设置SavePOint执行删除订单，删除订单和删除客户在同一个事务，删除部分订单失败，事务回滚SavePoint，由用户控制是事务提交，还是回滚 小结： ​ REQUIRED：一个事务，要都成功，要么都失败 ​ REQUIRES_NEW：两个不同事务，彼此直接没有关系，一个事务失败了不影响另一个事务 ​ NESTED：一个事务，在A事务调用B过程中，B失败了，回滚事务到之前SavePoint，用户可以选择提交事务或者回滚事务 超时时间默认值是-1，没有超时限制，如果有，以秒为单位进行设置。 -建议查询时设置为只读事务 -TransactionStatus接口描述了某个时间点上事务对象的状态信息，包含有6个具体的操作 刷新事务 void flush() 获取是否存在储存点 boolean hashSavepoint() 获取事务是否完成 boolean isCompleted() 获取事务是否为新的事务 boolean isNewTransaction() 获取事务是否回滚 boolean isRollbackOnly() 设置事务回滚 void setRollbackOnly() 基于XML的声明式事务控制（配置方式）1.装配事务管理器 12345 &lt;!-- 配置一个事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入DataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;xxxxxxxxxx 2.应用事务管理器 首先需要配置tx和aop的名称空间和约束 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; 配置事务 1234567891011121314151617181920212223242526272829303132&lt;!--配置事务策略--&gt; &lt;tx:advice id=\"txAdvice\"&gt; &lt;!--配置事务的属性--&gt; &lt;tx:attributes&gt; &lt;!-- 指定对那些方法使用事务 name：方法的名称 使用通配符 * 代表对所有方法使用事务 isolation：配置事务的隔离级别，默认使用当前数据库默认的隔离级别 read-only：是否只读，一般对增删改方法使用false ，标识读写。对查询方法使用true 标识只读即可，默认读写 propagation：指定事务的传播行为，默认REQUIRED，增删改的时候使用 SUPPORTS：用于查询 no-rollback-for：指定对那种异常不会滚 rollback-for：指定那种异常进行回滚 没有默认值， 一般不用 timeout：设置事务的超时时间，单位是秒，默认是-1 永不超时 --&gt; &lt;tx:method name=\"*\"/&gt; &lt;!-- 表示只对query开头的方法使用只读事务和SUPPORTS的传播行为 相似度越高，匹配越高。因此query*代表了所有以query开头的方法都会使用它的事务配置 --&gt; &lt;tx:method name=\"query*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.qiezicy.service.impl.*.*(..))\"/&gt; &lt;!--配置事务管理器应用到切入点--&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:config&gt; 基于注解配置事务1.开启注解事务管理 1234567&lt;!--开启注解事务管理--&gt; &lt;tx:annotation-driven/&gt; &lt;!--装配事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 2.在需要开启事务的类上添加注解 123456789101112131415161718192021222324252627@Service@Transactionalpublic class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(String sourceName, String targetName, Float money) &#123; // 通过账户名称查询账户 Account source = accountDao.queryAccountByName(sourceName); Account target = accountDao.queryAccountByName(targetName); // 修改金额 source.setMoney(source.getMoney() - money); target.setMoney(source.getMoney() - money); // 执行修改 accountDao.updateAccount(source); int x = 1 / 0; accountDao.updateAccount(target); &#125;&#125; 基于配置类的方式1。创建配置类 1234567@Configuration@ComponentScan(\"cn.itcast\")@EnableTransactionManagement//声明使用注解方式的事务管理器@Import(value = &#123;JdbcConfig.class,TxConfig.class&#125;)public class SpringConfiguration &#123;&#125; 2.JdbcConfig 12345678910111213141516171819202122232425262728293031@PropertySource(&#123;\"classpath:jdbc.properties\"&#125;)public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125; @Bean public DataSource getDataSource()&#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driverClassName); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 3.TxConfig 1234567public class TxConfig &#123; @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; Spring的监听器","categories":[],"tags":[{"name":"spring初级","slug":"spring初级","permalink":"htts://cocked.github.io/tags/spring初级/"}]},{"title":"01Mybatis初探","slug":"01Mybatis初探","date":"2017-03-15T04:04:03.000Z","updated":"2018-09-16T01:23:06.093Z","comments":true,"path":"2017/03/15/01Mybatis初探/","link":"","permalink":"htts://cocked.github.io/2017/03/15/01Mybatis初探/","excerpt":"","text":"首先给大家推荐几个网页： http://www.mybatis.cn/ http://blog.csdn.net/isea533/article/category/2092001 http://www.mybatis.org/mybatis-3/zh/index.html http://www.mybatis.org/spring/zh/index.html http://www.mybatis.tk/ #什么是Mybatis？简单介绍MybatisMybatis的**前身**是iBatis，是Apache的一个开源项目，2010年这个项目从Apache迁移搭配Google改名为Mybatis之后将版本升级到3.x，文档http://www.mybatis.org/mybatis-3/，从3.2版本之后迁移到GitHubhttps://github.com/mybatis/mybatis-3，目前最新稳定版本为3.2.8 MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records. ​ Mybatis是一个类似于Hibernate的**ORM持久化框架**，支持**普通SQL查询**，**存储过程**以及**高级映射**，Mybatis通过使用**简单的XML**或**注解**用于**配置**和**原始映射**，MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索，将**接口和POJO对象**映射成数据中的的记录。 由于Mybatis是直接基于JDBC做了简单的映射包装，所以从**性能角度**来看；**JDBC&gt;Mybatis&gt;Hibemate**orm ##工具的基本思想无论是用过的hibernate,mybatis,你都可以法相他们有一个共同点： 从配置文件(通常是XML配置文件中)得到 sessionfactory. 由sessionfactory 产生 session 在session 中完成对数据的增删改查和事务提交等. 在用完之后关闭session 。 在java 对象和 数据库之间有做mapping 的配置文件，也通常是xml 文件。 Mybatis是支持定制化sql、存储过程以及高级映射的优秀的持久层框架，其主要完成2件事情： 1.封装JDBC操作 2.利用反射打通Java类与SQL语句之间的相互转换 ##特点 1.支持自定义sql。存储过程、及高级映射 2.实现自动对sql的参数设置 3.实现自动对结果集进行解析和封装 4.通过xml或者注解进行配置和映射，大大减少了代码量 5.数据源的连接信息通过配置文件进行配置 ~~Mybatis的主要设计目的就是让我们执行sql语句对输入输出的数据管理更加方便，所以方便地写出sql和方便地获取sql的执行结果才是MyBatis核心竞争力。 ##Mybatis整体架构 Mybatis配置 MybatisConfig.xml Mapper1.xml Mapper2.xml … SqlSessionFactory sqlSession Executor(执行器) SQL输入参数 —&gt;Mapped Statement —–&gt;输出结果 HashMap HashMap String、Integer String、Integer POJO POJO ###1.配置文件 **全局配置文件**：Mybatis-config.xml **作用**：配置数据源（配置数据库连接信息），引入映射文件 **映射文件**：XxxMapping.xml， **作用**：配置sql语句、参数、结果集封装类型等 ###2.SQLSessionFactory 作用：获取SqlSession 通过 newSqlSessionFactoryBuilder().build(inputStream)来构建，inputSream：读取配置文件的IO流 ###3.SqlSession 作用：执行CRUD操作 它是线程不安全的，因此最佳的使用范围是请求是请求或方法范围 4.Executor 执行器，SqlSession通过调用它来完成具体的CRUD 它是一个接口，提供了两种实现：缓存的实现、数据库的实现 5.Mapped Statement 在映射文件里面的配置，包含3部分内容 具体sql，sql执行所需的参数类型，sql执行结果的封装类型 参数类型和结果集封装类型包括三种：HashMap，基本数据类型，pojo Mybatis的主要成员 Configuration：MyBatis所有的配置信息都保存在Configuration对象中，配置文件的大部分配置都会存储到该类中 SqlSession: 作为MyBatis工作的主要顶层API，表示和数据交互时的会话，完成必要的数据库增删改查的功能 Executor:Mybatis执行器，时MyBatis调度的核心，负责sql语句的生成和查询缓存的维护 StatementHandler：封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数等 ParamHandler：负责对用户传递的参数转换成JDBC Statement所对应的数据类型 ResultSetHanler：负责JDBC返回的ResultSet结果集对象转换成List类型的集合 TypeHandler：负责java数据类型和jdbc数据类型（也可以数时数据列表类型）之间的映射和转换 MappedStatement：维护一条&lt;select|update|delete|insert&gt;节点的封装 SqlSource：负责根据用户传递的parameterObject，动态的生成SQL语句，将信息封装到BoundSql对象，并返回表示动态生成的sql语句以及相应的参数信息 #Mybatis快速入门添加依赖—–&gt;编写实体类—-&gt;编写全局配置文件——-&gt;编写配置文件——&gt;编写映射文件—-&gt;编写测试类 添加依赖通过Maven在pom.xml中添加Mybatis的依赖 123456789101112131415161718192021&lt;!--mysql驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; &lt;!--slf4j 日志文件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j2&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; ##编写POJO类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.qiezicy.pojo;import java.util.Date;public class Order &#123; private Integer id; private Integer userId; private String number; private Date createtime; private String note; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number == null ? null : number.trim(); &#125; public Date getCreatetime() &#123; return createtime; &#125; public void setCreatetime(Date createtime) &#123; this.createtime = createtime; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note == null ? null : note.trim(); &#125; @Override public String toString() &#123; return \"Order [id=\" + id + \", userId=\" + userId + \", number=\" + number + \", createtime=\" + createtime + \", note=\" + note + \"]\"; &#125;&#125; 编写全局配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 自定义别名 --&gt; &lt;typeAliases&gt; &lt;!--包扫描--&gt; &lt;package name=\"com.qiezicy.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!--environments 标签：配置多个数据库环境 default属性：默认指定使用那个环境，一般是引用某个环境的id --&gt; &lt;environments default=\"development\"&gt; &lt;!--environment 标签：配置单个环境 id属性：标识该环境的唯一标识，不能重复，一般是用来被引用的 --&gt; &lt;environment id=\"development\"&gt; &lt;!-- transactionManager标签：事务管理 type属性：jdbc标识使用jdbc的事务管理，一般不修改 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- dataSource标签：配置数据源 type：使用POOLED，表示使用连接池技术 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据源--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"111\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"urder.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 这个全局配置文件是mybatis用来建立sessionFactory用的，里面主要包含了数据库连接相关的东西，还有java类对应的别名 这里的dataSource 的类型设置为POOLED UNPOOLED：不使用连接池的数据源 POOLED：使用连接池的数据源 JNDI：使用JNDI实现的数据源 编写映射文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- mapper标签：用来配置各种sql语句以及其他更高级配置 namespace属性：名称空间,需要设置唯一 不能重复 一般用来区分不同的映射文件的 --&gt;&lt;mapper namespace=\"user\"&gt; &lt;!-- select标签：是用来专门写查询的sql语句的声明（statement） id属性：表示sql的唯一表示，一般是用来被引用的 resultType属性：结果集类型，将数据封装到那个类型中 parameterType属性：传递参数类型 --&gt;&lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"user\"&gt; SELECT `id`, `user_name`, `password`, `name`, `age`, `sex`, `birthday`, `created`, `updated` FROM `tb_user` WHERE id = #&#123;id2&#125;&lt;/select&gt;&lt;/mapper&gt; 编写测试类1234567891011121314151617@Testpublic void test() throws IOException &#123; // 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); // 读取mybatis配置文件 InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\"); // 通过输入流创建 sqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = ssfb.build(inputStream); // 打开回话，包含了访问数据库的所有api SqlSession sqlSession = sqlSessionFactory.openSession(); // 执行查询 User User = sqlSession.selectOne(\"user.getUserById\", 1); System.out.println(\"User = \" + User); sqlSession.close();&#125; 总结1.配置全局配置文件**注意：**全局配置文件讲究严格的顺序，MyBatis的配置文件包含了影响MyBatis行为的设置和属性信息，文档的顶层结构如下： **1.configuration配置** properties属性 setting设置 typeAliases类型命名 typeHandlers类型处理器 objectFactory对象工厂 plugins插件 environments环境 environment环境变量 transacManager事务管理器 dataSource数据源 databasidProvider数据库厂商标识 mappers映射器 **2.settings设置** 设置参数 描述 有效值 默认值 cacheEnabled 该配置影响的所有映射器中配置的缓存的全局开关 true\\ false true lazyLoadingEnabled 延迟加载的全局开关，当开启时，所有关联对象都会延迟加载，特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态 true\\ false false aggressiveLazyLoading 当启用时，带有延迟加载属性的对象的加载与否完全取决于对任意延迟属性的调用；反之，没种属性将会按需加载 true\\ false true mapUnderscoreToCameCase 是否开启自动命名规则（camel case）映射，即从经典数据库列名A_COLUM到经典的java属性名aColum的类似的映射 true\\ false false 开启驼峰匹配：完成经典的数据库命名到java属性的映射 经典数据库命名：如果多个单词之间，通常使用下划线进行连接。 java中命名：第二个单词首字母大写。 驼峰匹配：相当于去掉数据中的名字的下划线，和java进行匹配 查询数据的时候，查不到userName的信息，原因：数据库的字段名是user_name，POJO中的属性名字是userName，两端不一致，造成mybatis无法填充对应的字段信息。修改方法：在sql语句中使用别名 解决方案1：在sql语句中使用别名 解决方案2：参考驼峰匹配 — mybatis-config.xml **3.typeAliases** **4.typeHandlers(类处理器)** **5.plugins（插件又称拦截器）** **6.environments（环境)** 全局配置的作用： 设置环境（事务，数据源） 管理映射文件XxxMapper.xml Mapper标签：用来配置不同的statement resource：加载resource class：class扫描器：1.映射文件与接口同一目录下 2.映射文件的名必须与接口文件名相同 package包扫描器要求：1.映射文件与接口在同一目录下2.映射文件名必须和接口文件的名称保持一致 typeAliases：自定义别名 之前咱们在映射文件中用到java类型时，都是使用类的全路径，书写起来非常麻烦 解决方案： 类型别名是为 Java 类型命名的一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。（官方文档） typeAlias： package：别名扫描器，默认别名是类的全称。不区分大小写。 2.配置映射文件 NameSpace属性：用来配置名称空间，来区分不同的映射文件的statement cache：给定命名空间的缓存配置 cache-ref：其他命名空间缓存配置的引用 resultMap：是最复杂也是最强大的元素，用来描述如何从数据库结果集中加载对象 sql：可被其他语句引用的可重用的语句块 insert：映射插入语句 id：插入语句的唯一标识 parametType：插入语句的参数类型，使用动态代理之后，需要和mapper接口中的参数类型一致，可以省略 useGeneratedKeys：开启主键自增回显，将自增长的主键值回显到形参中（即封装到User对象中） keyColumn：数据库中主键的字段名称 keyProperty：pojo中主键对应的属性 update：映射更新语句 id：插入语句的唯一标识 parametType：插入语句的参数类型，使用动态代理之后，需要和mapper接口中的参数类型一致，可以省略 delete：映射删除语句 id：插入语句的唯一标识 parametType：插入语句的参数类型，使用动态代理之后，需要和mapper接口中的参数类型一致，可以省略 select：映射查询语句 id：该statement的唯一标识，一般用来被引用 resultType：结果集类型 parameterType：参数类型，可以省略，一般都省略 12&lt;mapper namespace=\"user\"&gt;&lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"com.qiezicy.pojo.User\"&gt; parameterType传入参数 每一个crud标签都有一个这样的属性，statement通过它指定接收的参数类型 接收参数的方式有两种 1.#{}预编译 单个参数时，#{}中的参数与参数名无关的。 多个参数时，#{}和${}与参数名（@Param）有关。 123456User login(@Param(\"userName\")String userName, @Param(\"password\")String password);// 映射文件中&lt;select id = \"login\" resultType=\"User\"&gt; select * from tab_user where user_name = #&#123;userName&#125; and password = #&#123;password&#125;&lt;/select&gt; &gt;将传入的数据都当成一个字符串，会自动对传入的数据加一个双引号。如：order by #{user_id},如果传入的是111，那么解析成sql的时候是order by “111” ​ 2.${}非预编译 如果你要动态传入的字段名是表名，并且sql执行是预编译的，这显然是不允许的，所以你必须改成非预编译的，也就是这样： 在一个参数的情况下必须，参数名称必须为value:即${value} 但是这并不是一种稳妥的解决方案，推荐使用@Param注解指定参数名. 12345List&lt;User&gt; queryUserListByTableName(@Param(\"tableName\") String tablepName);// 映射文件中&lt;select id = \"queryUserListByTableName\" resultType=\"User\"&gt; select * from $&#123;tableName&#125;&lt;/select&gt; $将传入的数据直接显示在生成的sql中，如：order by ${user_id},如果传入的值是111，那么解析sql的时候是order by 111 **注意：** {}这样的很大成都防止sql注入 ${}方式无法防止sql注入 $方式一般用于传入数据库对象，例如传入表名 一般能用#就别用$ MyBatis排序时使用order by 动态参数时需要注意，用$而不是# 参数类型有三种 1）.基本数据类型 2）.HashMap（使用方式和POJO类似） 3）.pojo自定义包装类型 3.使用HashMap传递参数 ​ ​123456789101112131415// UserMapper接口中的方法User loginMap(Map&lt;String,String&gt; map);// UserMapper配置文件// 将map的key作为参数名称来传递参数&lt;select id=\"loginMap\" resultType=\"User\"&gt; select * from tab_user where user_name = #&#123;userName&#125; and password = #&#123;password&#125;&lt;select&gt;// 测试用例public void testLoginMap()&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"userName\", \"zhangsan\"); map.put(\"password\", \"111\"); User user = userMapper.loginMap(map);&#125;​ ​ 4.使用pojo传递参数 12345678910111213141516// 接口中的方法User loginUser(User user);// 映射文件// 通过参数名称来调用User中的getting方法来获取参数&lt;select id=\"loginUser\" resultType=\"user\"&gt;select * from tab_user where user_name = #&#123;userName&#125; and password = #&#123;password&#125;&lt;/select&gt;// 测试public void testLoginUser()&#123; User user = new User(); user.setUserName = (\"zhangsan\"); user.setPassword = (\"123456\"); User queryUser = userMapper.loginUser(user);&#125; 5.总结 1234567891011121314151617181920212223242526在Mybatis的mapper中，参数传递有2种方式，一种是#&#123;&#125;和另一种$&#123;&#125;,两者有着很大的区别；—_—)#&#123;&#125;实现的是sql语句的预处理参数，之后执行sql中用？号代替，使用时不需要关注数据类型，Mybatis自动实现数据类型转换，并且防止sql注入—_—)$&#123;&#125;实现是sql语句的直接拼接，不做数据类型转换，需要自行判断数据类型。不能防止sql注入有些清空必须使用$&#123;&#125;，在分表存储的情况下，我们从那张表查询是不确定的，也就是说sql语句不能写死，表名是动态生成的，查询条件是固定的，这样：select * from $&#123;tableName&#125; where id = #&#123;id&#125;总结： #&#123;&#125;占位符用于参数传递 $&#123;&#125;用于sql拼接 #&#123;&#125;：1、 是预编译2、 编译成占位符3、 可以防止sql注入4、 自动判断数据类型5、 一个参数时，可以使用任意参数名称进行接收 $&#123;&#125;:1、 非预编译2、 sql的直接拼接3、 不能防止sql注入4、 需要判断数据类型，如果是字符串，需要手动添加引号。5、 一个参数时，参数名称必须是value，才能接收参数。当填写表名的时候可以用$&#123;&#125;其他的情况#&#123;&#125; 6.resultMap resultMap是Mybatis中最重要最强大的元素，使用resultMap可以解决两大问题： pojo属性名和表结构字段名不一致的问题 查询数据库的时候，查不到userName的信息，原因：数据库的字段名是user_name，而pojo中的属性名字是userName两端不一致，造成mybatis无法填充对应字段的信息。修改方法：在sql中使用别名 解决方案：1，在sql中使用别名 解决方案：2.参考驼峰匹配 -----mybatis-config.xml的时候 ​1234&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;​ **解决方案3：resultMap自定义映射** 123456789101112131415161718resultMap标签的作用：自定义结果集，自行设置结果集的封装方式 id属性：resultMap标签的唯一标识，不能重复，一般被用来被引用 type属性：结果集的封装类型 autoMapping属性：操作单表时，不配置默认为true，如果pojo对象中的属性名和表中字段名称相同，则自动映射 例子： &lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot; autoMapping=&quot;true&quot;&gt; // 配置主键映射关系 &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; // 配置用户名映射关系 &lt;result column=&quot;user_name&quot; property=&quot;userName&quot;/&gt; &lt;/resultMap&gt; notes： 上述引用：注意到 主键需要 通过id子标签配置，表字段和属性名不一致的普通字段需要通过result子标签配置，那么，字段和属性名称都匹配的字段要不要配置呢？这取决于resultMap中的autoMapping属性的值 ： 为true时：resultMap中的没有配置的字段会自动对应，如果不配置，默认为true 为false时：只针对resultMap中已经配置的字段做映射 完成高级查询，比如一对一、一对多、多对多（在后面会介绍） 7、sql片段 sql标签可以定义一个sql片段，在需要使用该sql片段的地方，通过include标签来使用。在有的时候为了提高sql语句的性能，就不能使用select * 来进行查询，把需要显示的每一个字段都声明出来，如果这是查询语句比较多的情况下，每次都手动编写比较麻烦。 123456789101112131415&lt;sql id=\"commonsql\"&gt; id, user_name, password, name, age, sex, birthday, created, updated&lt;/sql&gt;&lt;select id=\"queryUserListLikeUserName\" resultType=\"user\"&gt; select &lt;include refid=\"commonsql\"&gt;&lt;/include&gt; from tb_user where like \"%\"#&#123;username&#125;\"%\"&lt;/select&gt; 还可以将sql片段都定义在一个专门存放sql片段的映射文件中，然后由其他映射文件引用它即可。 在resource目录下可以新增一个CommonSQL.xml文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"CommonSQL\"&gt; &lt;sql id=\"commonSql\"&gt; id, user_name, password, name, age, sex, birthday, created, updated &lt;/sql&gt; &lt;/mapper&gt; 在使用sql片段时一定要先在全局配置文件中引用 最后在需要使用该sql片段的地方通过include标签的refid属性引用该sql片段： ##Mapper动态代理方式 需要遵循以下规范： 1.映射文件中的命名空间（名称空间）与Mapper接口的全路径一致：其中namespace是命名空间，用于隔离sql 1&lt;mapper namespace=&quot;com.qiezicy.mapper.UserMapper&quot;&gt; 2.映射文件中的statement的id与Mapper接口的方法名保持一致 123456789映射文件&lt;select id=\"getOrderList\" resultMap=\"order\"&gt;&lt;/select&gt;接口 /** * 获取订单列表 * @return */ List&lt;Order&gt; getOrderList(); 3.映射文件中statement的resultType必须和mapper接口中的方法返回类型一致（及时不采用动态代理，也要一致）如上：获得是List只需要填写类名order就行，因为配置过别名，并不区分大小写，类名既别名。 4.映射文件中的statement的parameterType必须和mapper接口方法的参数类型一致（不一定，该参数可省略） 动态sqlMybatis的一个强大的特效之一通常是它的动态sql能力，提供了OGNL表达式动态生成sq功能。动态sql有： if choose，when，otherwise where set foreach 常用的OGNL表达式 1234567891011121314151. e1 or e22. e1 and e23. e1 == e2,e1 eq e24. e1 != e2,e1 neq e25. e1 lt e2：小于6. e1 lte e2：小于等于，其他gt（大于）,gte（大于等于）7. e1 in e28. e1 not in e29. e1 + e2,e1 * e2,e1/e2,e1 - e2,e1%e210. !e,not e：非，求反11. e.method(args)调用对象方法12. e.property对象属性值13. e1[ e2 ]按索引取值，List,数组和Map14. @class@method(args)调用类的静态方法15. @class@field调用类的静态字段值 if标签：判断语句，用于进行逻辑判断的 test属性：用于编写表达式，支持ognl choose标签：条件选择 ​ when子标签：编写条件，不管有多少个when条件，一旦其中一个条件成立，后面的when条件都不执行。 ​ test属性：编写ognl表达式 ​ otherwise子标签：当所有条件都不满足时，才会执行该条件 ​ where标签：可以自动将动态sql中多出来的一个and或者or去除 set标签： ​ 可以自动添加一个set关键字，并且会将动态sql最好多余的逗号去除 foreach标签：遍历集合或者数组 ​ collection属性：接收的集合或者数组参数 ​ item属性：集合或者数组参数中的每一个元素 ​ separator属性：标签分隔符 ​ open属性：以什么开始 ​ close属性：以什么结束 Mybatis缓存 一级缓存 执行相同的sql语句和参数，Mybatis不再重新执行sql，而是从缓存中返回 在Mybatis中，一级缓存默认是开启的：作用域：在同一sqlSession下 但是我们可以手动清除一级缓存 使用：sqlSession.clearCashe() &gt;一级缓存的问题 在执行update，insert，delete的时候，即使操作的不是和一级缓存中的同一条记录，都会清空一级缓存 二级缓存 mybatis的二级缓存的作用域：mapper范围的（映射文件级别，多个sqlSession可以共享二级缓存数据） ​ 1.同一个mapper的namespace在同一个namespace中查询sql可以从缓存中命中 ​ 2、夸sqlSession，不同的sqlSession可以从二级缓存中命中 场景：在用户通过id查询一个商品信息，执行完查询方法之后会将sqlSession释放掉，当再次发送请求查询同一个商品信息时会再次获取一个新的sqlSession来执行查询，那么此时如果配置了二级缓存的话，就可以直接从二级缓存中获取信息，而不用再次去数据库查询了。 如何开启二级缓存： ​ 1.在映射文件中，添加标签 ​ 2.在全局配置文件中，设置CacheEnabled参数，默认已经开启 notes：由于缓存数据是在sqlSession调用close方式时，放入缓存的因此在测试二级缓存时必须先将第一个sqlSession关闭，二级缓存的对象必须序列化，例如User对象必须实现Serializable接口 二级缓存的问题 二级缓存在执行update、insert、delete的时候，也同样会清空二级缓存中的内容 关闭二级缓存 ​ 1，不要在映射文件中开启就行 ​ 2.设置全局的全局配置文件mybatis-config.xml中去关闭二级缓存 123456&lt;settings&gt; &lt;!-- 行为参数，name:参数名，value：参数值，默认为false，true：开启驼峰匹配，即从经典的数据库列名到经典的java属性名 --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!-- 关闭二级缓存，默认是开启，false：关闭 --&gt; &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt; &lt;/settings&gt; #Mybatis高级查询一对一查询注意：一旦涉及到嵌套映射，一定要设置手动设置为自动映射。不管是Order的自动映射还是User的自动映射都需要手动设置为true。 需求： ​ 根据订单编号20140921003查询出订单的信息，并查询出下订单的用户的信息 实现： ​ 1.编写接口 12345678public interface OrderMapper &#123; /** * 通过订单号查询订单和用户 * @param orderNumber * @return */ Order queryOrderAndUserByOrderNumber(@Param(\"orderNumber\")String orderNumber); ​ 2.创建pojo的Order类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 订单表 * */public class Order &#123; private Integer id; private Long userId; private String orderNumber; private User user; @Override public String toString() &#123; return \"Order&#123;\" + \"id=\" + id + \", userId=\" + userId + \", orderNumber='\" + orderNumber + '\\'' + \", user=\" + user + '&#125;'; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public String getOrderNumber() &#123; return orderNumber; &#125; public void setOrderNumber(String orderNumber) &#123; this.orderNumber = orderNumber; &#125;&#125; ​ 3.编写OrderMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.qiezicy.mapper.OrderMapper\"&gt; &lt;!--配置自定义结果集 resultMap --&gt; &lt;!-- id 属性：唯一标识符 type属性：映射java中那个pojo实体类型 autoMapping属性：设置为true自动映射，一旦涉及到嵌套映射，一定要设置手动设置为自动映射。不管是Order的自动映射还是User的自动映射都需要手动设置为true。 --&gt; &lt;resultMap id=\"orderAndUserResultMap\" type=\"order\" autoMapping=\"true\"&gt; &lt;!--配置 order 的主键映射--&gt; &lt;id column=\"id\" property=\"id\" /&gt; &lt;!-- 除了主键的其他键的映射通过result标签 其中： column 属性 是 数据库中的列名 property 属性 是 pojo类中的 变量名 --&gt; &lt;result column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"order_number\" property=\"orderNumber\"/&gt; &lt;!-- association:标签 用于 一对一 映射 property属性：类中的关联属性的名称 javaType属性：属性对应的类型 autoMapping属性：多表查询时，必须设置为true User 对象和tb_user表中的属性和字段才会进行自动映射 --&gt; &lt;association property=\"user\" javaType=\"user\" autoMapping=\"true\"&gt; &lt;id column=\"user_id\" property=\"id\"/&gt; &lt;result column=\"user_name\" property=\"userName\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!--通过订单号查询订单和用户--&gt; &lt;select id=\"queryOrderAndUserByOrderNumber\" resultMap=\"orderAndUserResultMap\"&gt; SELECT * FROM tb_order INNER JOIN tb_user u ON tb_order.user_id = u.id WHERE order_number = #&#123;orderNumber&#125;; &lt;/select&gt; &lt;/mapper&gt; ​ 4.全局配置文件管理映射文件 1&lt;mapper resource=\"OrderMapper.xml\"/&gt; ​ 可以通过测试类 进行测试 嵌套查询其实就是嵌套查询，而在使用嵌套查询的时候，那么普通结果集就无法满足我们的查询要求了，因此要使用到ResultMap标签进行自定义结果集的映射配置,并且需要手动配置autoMapping为true。 一对多查询需求： ​ 通过订单编号20140921001查询订单，并查询出单人信息以及查询出订单详情 订单：订单详情 = 1：n(体现在pojo 对象中，就是在Order对象中添加OrderDetail对象的适合) 实现 ​ 1.修改Order ​ 在Order类添加List 属性，并添加get。set方法和toString方法 ​ 2.编写接口方法 123456/** * 通过订单编号查询订单、用户和订单详情 * @param orderNumber:订单编号 * @return */Order queryOrderAndUserAndOrderdetailByOrderNumber(@Param(\"orderNumber\") String orderNumber); ​ 3.编写statement 12345678910111213141516171819202122232425262728293031&lt;!--一对多自定义结果集--&gt;&lt;resultMap id=\"orderAndUserAndOrderdetailsResultMap\" type=\"Order\" autoMapping=\"true\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;!--一对一--&gt; &lt;association property=\"user\" javaType=\"User\" autoMapping=\"true\"&gt; &lt;id column=\"uid\" property=\"id\"&gt;&lt;/id&gt; &lt;/association&gt; &lt;!-- 一对多 使用 collection 标签 property属性：类中 管理的 属性的 变量名 javaType属性：对应java 中的 类型 ofType属性 ：List中每个项 对应的 类型 --&gt; &lt;collection property=\"orderdetails\" javaType=\"List\" ofType=\"Orderdetail\" autoMapping=\"true\"&gt; &lt;id column=\"detail_id\" property=\"id\"&gt;&lt;/id&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--一对多查询--&gt;&lt;select id=\"queryOrderAndUserAndOrderdetailByOrderNumber\" resultMap=\"orderAndUserAndOrderdetailsResultMap\"&gt; SELECT *,u.id as uid,od.id as detail_id FROM tb_order o INNER JOIN tb_user u ON o.user_id = u.id INNER JOIN tb_orderdetail od on od.order_id = o.id WHERE o.order_number = #&#123;orderNumber&#125;&lt;/select&gt; 多对多查询需求： ​ 通过订单号20140921001查询订单，查询出 下订单人的信息 订单详情 以及商品数据 订单：订单详情 = 1：n(体现在pojo对象中就是在Order对象中添加OrderDetail对象的集合) 订单详情：商品 = 1：1(体现在pojo对象中就是在OrderDetail对象中添加Item对象) sql：通过订单号20140921001查询订单，查询出 下订单人的信息 并查询出订单详情中的商品数据 实现： ​ 1.修改Order ​ 在Order中添加用户配置一对一关系，在Order中添加List orderdetails配置一对多关系 ​ 并在Orderdetail中添加Item配置一对一关系 ​ 都需要添加get，set方法，并重写toString方法 ​ 2.编写接口方法 123456/** * 通过订单编号查询订单、用户和订单详情以及商品 * @param orderNumber * @return */Order queryOrderAndUserAndOrderdetailAndItemByOrderNumber(@Param(\"orderNumber\") String orderNumber); ​ 3.编写statement ​ OrderMapper配置（通过collection标签中嵌套使用association标签） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;resultMap id=\"orderAndUserAndOrderdetailsAndItemResultMap\" type=\"Order\" autoMapping=\"true\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;!--一对一 配置 User --&gt; &lt;association property=\"user\" javaType=\"User\" autoMapping=\"true\"&gt; &lt;id column=\"uid\" property=\"id\"&gt;&lt;/id&gt; &lt;/association&gt; &lt;!--一对多 配置 Orderdetails--&gt; &lt;collection property=\"orderdetails\" javaType=\"List\" ofType=\"Orderdetail\" autoMapping=\"true\"&gt; &lt;id column=\"detail_id\" property=\"id\"&gt;&lt;/id&gt; &lt;!--订单详情和商品的一对一的关系--&gt; &lt;association property=\"item\" javaType=\"Item\" autoMapping=\"true\"&gt; &lt;id column=\"iid\" property=\"id\"&gt;&lt;/id&gt; &lt;/association&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--多对多查询--&gt;&lt;select id=\"queryOrderAndUserAndOrderdetailAndItemByOrderNumber\" resultMap=\"orderAndUserAndOrderdetailsAndItemResultMap\"&gt; SELECT *,u.id as uid,od.id as detail_id,i.id as iid FROM tb_order o INNER JOIN tb_user u ON o.user_id = u.id INNER JOIN tb_orderdetail od on od.order_id = o.id INNER JOIN tb_item i on i.id = od.item_id WHERE o.order_number = #&#123;orderNumber&#125;&lt;/select&gt; resultMap继承 如果说有resultMap中的数据其他地方也要用到，那么可以使用继承的方法来复用即可 1&lt;resultMap id=\"orderAndUserAndOrderdetailsAndItemResultMap\" type=\"Order\" autoMapping=\"true\" extends=\"另一个resultMap的id\"&gt; 总结resutlType无法帮助我们自动的去完成映射，所以只有使用resultMap手动的进行映射 resultMap: ​ type：结果集对应的数据类型 ​ id：唯一表示，被引用的时候，进行指定 ​ autoMapping：开启自动映射 ​ extends：继承 子标签： ​ association ：配置一对一映射 ​ property 定义对象的属性名 ​ JavaType 属性的类型 ​ autoMapping 开启自动映射 ​ collection：配置多对多映射 ​ property：定义对象的属性名 ​ javaType：集合的类型 ​ ofType：集合中的元素类型 ​ autoMapping ：开启自动映射 延迟加载​ 使Order的查询和User或者OrderDetail的查询分开。只有当我们访问Order对象的User或者OrderDetail属性时，才去执行User或者OrderDetail的查询。 1.编写接口方法 123456/** * 延迟加载 * @param orderNumber * @return */Order queryOrderUserLazy(@Param(\"orderNumber\")String orderNumber); 2.编写statement 12345678910111213141516171819&lt;!--通过Order延迟加载User--&gt;&lt;resultMap id=\"orderUserLazyResultMap\" type=\"Order\"&gt; &lt;!-- select属性：调用指定sql语句来执行延迟加载 column属性：延迟加载的sql语句中所需的参数 --&gt; &lt;association property=\"user\" javaType=\"User\" select=\"queryUserByIdOfOrder\" column=\"&#123;id=user_id&#125;\"&gt;&lt;/association&gt; &lt;/resultMap&gt;&lt;!--通过订单编号查询订单--&gt;&lt;select id=\"queryOrderUserLazy\" resultMap=\"orderUserLazyResultMap\"&gt; select * from tb_order where order_number = #&#123;orderNumber&#125;&lt;/select&gt;&lt;select id=\"queryUserByIdOfOrder\" resultType=\"User\"&gt; select * from tb_user where id = #&#123;id&#125;&lt;/select&gt; 开启延迟加载开关 1&lt;setting name=\"lazyLoadingEnabled\" value=\"true\"&gt;&lt;/setting&gt; #特殊符号替换123456&amp;lt; &lt; 小于&amp;gt; &gt; 大于&amp;amp; &amp; 和and&amp;apos; &apos; 单引号&amp;quot; &quot; 双引号严格地讲，在xml中仅有字符&quot;&lt;&quot;&amp;&quot; 是非法的。省略号，引号和大于号是合法的 还可以使用&lt;![CDATA[ &lt; ]]&gt; CDATA 内部的所有东西都会被解析器忽略,因此只要将字符实体编写在其中，就不需要进行转义。","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"htts://cocked.github.io/tags/Mybatis/"}]},{"title":"06WEB初识Filter","slug":"06WEB初识Filter","date":"2017-02-28T06:24:11.000Z","updated":"2018-09-01T08:21:15.778Z","comments":true,"path":"2017/02/28/06WEB初识Filter/","link":"","permalink":"htts://cocked.github.io/2017/02/28/06WEB初识Filter/","excerpt":"","text":"第一章 过滤器简介1.1 过滤器是什么过滤器（filter）本质是Java中预先定义好了不同的接口，和servlet类似，可以过滤不同的内容，具体怎么过滤，需要使用者定义一个实现类，然后实现接口中的过滤方法，在方法中书写过滤的条件。filter是对客户端访问资源的过滤，符合条件放行，不符合条件不放行。简而言之，是在servlet之前执行，拦截请求，将servlet中一些共同的业务代码抽取出来，这就是过滤器作用。比如：请求乱码处理。 第二章 过滤器的应用场景1、过滤论坛中的非法字符当我们上论坛或者贴吧这类的网站浏览信息时，我们发现，很多评论有时候是携带脏词的。而这些脏词不能显示出来，使用**代替了。类似这类的脏词过滤，我们可以通过java中的过滤器，对请求参数中的脏词进行过滤。 2、登录权限检查 1.1 过滤器是什么过滤器（filter）本质是Java中预先定义好了不同的接口，和servlet类似，可以过滤不同的内容，具体怎么过滤，需要使用者定义一个实现类，然后实现接口中的过滤方法，在方法中书写过滤的条件。filter是对客户端访问资源的过滤，符合条件放行，不符合条件不放行。简而言之，是在servlet之前执行，拦截请求，将servlet中一些共同的业务代码抽取出来，这就是过滤器作用。比如：请求乱码处理。、第二章 过滤器的应用场景1、过滤论坛中的非法字符当我们上论坛或者贴吧这类的网站浏览信息时，我们发现，很多评论有时候是携带脏词的。而这些脏词不能显示出来，使用**代替了。类似这类的脏词过滤，我们可以通过java中的过滤器，对请求参数中的脏词进行过滤。2、登录权限检查当客户端浏览器发出一个请求，这个请求在访问到正真的目标资源之前，我们需要进行登录权限的检查。如果已经登录，我们就让这个请求通过，访问资源；如果没有登录，我们不能让请求访问目标资源。这样的操作需要在访问具体资源进行条件的过滤，我们可以使用过滤器来完成。第三章 过滤器开发入门1、过滤器API介绍 Filter是由Tomcat启动时创建，是javax.servlet包下面的一个接口，这个接口中定义了3个方法。 方法 说明 void init(FilterConfig filterConfig) 过滤器对象创建的时候调用的方法 void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 执行过滤的方法 void destory() 过滤器销毁的时候调用的方法 2、过滤器开发步骤 项目中如果需要使用到过滤器，使用Servlet3.0的注解方式进行创建。创建步骤如下： 第一步：新建一个普通java类，实现Filter接口； 第二步：根据提示重写Filter接口的3个方法； 第三步：在这个类上面通过注解的方式配置这个Filter； 注解@WebFilter：配置Filter的注解，这个注解有两个参数； filterName：设置过滤器的名称； urlPatterns：配置这个过滤器要拦截的资源的路径； 第四步：在doFilter（）方法中，书写过滤的业务逻辑； chain.doFilter()方法放行； 总结: doFilter()方法的作用 当不写doFilter()方法时候，jsp文件访问不到，被拦截； 当有了doFilter()方法时候，jsp文件可以访问，被放行；所以：doFilter()具有放行的作用。 第四章 过滤器的执行流程 过滤器的doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)方法中的request对象和response对象并不是过滤器自己创建的。而是，从被过滤的资源中传递过来的。过滤器的执行流程如下： 客户端（浏览器）的HttpRequest到达Servlet之前，被Filter的doFilter()方法拦截； 根据需要，我们可以获取或者修改HttpRequest对象中的数据； 在这个请求响应给浏览器之前，Filter拦截了HttpResponse对象； 根据需要，我们可以获取或者修改HttpReponse对象中的数据； 最后，由doFilter中的chain决定是否让这个请求通过； 问题：当用xml方法执行filter时候，路径配置为/*,发现，doFilter()里面的代码执行3次？ 答案：这是idea配置Tomcat时导致的，当启动Tomcat时候，doFilter()会执行2次，然后再跳出浏览器，访问localhost，还会再执行foFilter()一次。 问题：如果多个过滤器都对相同路径进行匹配，执行顺序该是什么？ 按字母照顺序执行 第五章 Filter的生命周期 我们分析了Filter的执行流程。我们有没有想过，我们并没有向Filter发送请求，请求是怎么进入到doFilter()中的呢。我们知道，能够调用一个类下面的非静态的成员方法，一定是这个类的对象。Filter类的对象是在什么时候创建的呢?创建之后又是怎么工作的呢？最后是在什么时候销毁的呢？这些问题就是Filter的生命周期问题。我们，可以通过以下代码对Filter的生命周期问题进行验证： 【结论】 Filter类的对象是在服务器启动的时候创建的； Filter类对象创建完成后会调用init()方法； 每当一个请求的路径是满足过滤器的配置路径，那么就会执行一次过滤器的doFilter方法 (类似于service方法) 当服务器停止的时候，销毁过滤器，执行过滤器的destory方法 1、doFilter()方法doFilter()方法是拦截请求的方法，只要一个请求符合Filter拦截路径，都会被doFilter()方法拦截。doFilter()方法有3个参数，这3个参数的作用分别如下： 参数 说明 ServletRequest req ServletRequest是HttpServletRequest类的父类，其中包含了被拦截的请求的信息 ServletResponse resp ServletResponse是HttpServletResponse类的父类，其中包含了被拦截的响应的信息 FilterChain chain FilterChain给Filter提供了放行的方法。chain.doFilter(); FilterChain 类是一个接口，里面有doFilter(req，resp)方法，作用是将浏览器提交请求对象和响应对象传到过滤连的资源里面去，所以doFilter()方法具有放行的作用。 2、destory()方法过滤器的销毁方法。服务器停止或者将项目从服务器中移除的时候，销毁过滤器，调用一次destory方法。 【关闭tomcat】查看结果 【结论】 过滤器是在服务器停止或者项目移除时销毁的； 过滤器销毁后会调用destory()方法； 【小结】Filter生命周期小结 当服务器启动的时候，过滤器就被初始化了，执行过滤器的init方法 每当一个请求的路径是满足过滤器的配置路径，那么就会执行一次过滤器的doFilter方法 当服务器停止的时候，销毁过滤器，执行过滤器的destory方法 第六章 Filter的映射路径映射路径指的是当前这个Filter需要拦截的路径。这个路径的配置方式有两种： 精确匹配：匹配指定的urlpattern； 模糊匹配：匹配复合条件的一类路径； 1、精确匹配精确匹配，要求访问的资源路径必须与Filter的urlPatterns中的配置一致。如下： 精确匹配 说明 urlPatterns = “/index.jsp” 拦截对index.jsp页面的请求 urlPatterns = “/loginServlet” 拦截对loginServlet的请求 urlPatterns = “/a.jpg” 拦截对a.jsp的请求 2、模糊匹配有时候，我们需要对这个服务器中的所有请求都有所特殊处理，比如处理post请求的乱码问题。我们就需要多 所有的请求都设置乱码处理。这时候，就需要对多有的请求进行拦截。如果通过上面的精确匹配模式，需要配置很多的请求，这样就比较麻烦了。如果通过urlPatterns的模糊匹配，就能够对这些请求进行统一处理。 模糊匹配主要有以下3种写法： 模糊匹配 使用示例 说明 urlPatterns = “/*” urlPatterns = “/*” 对所有的请求都进行拦截 urlPatterns = “/xxx/*” urlPatterns = “/user/*” 对映射路径中/user下的所有资源进行拦截 urlPatterns = “*.xxx” urlPatterns = “*.jsp” 对指定后缀的请求进行拦截 使用场景1 今天电商狂欢日，要求对所有购买的电脑进行打9折 http://localhost:8080/computer/dell http://localhost:8080/computer/xiaomi http://localhost:8080/computer/thinkpad 使用场景2 网站有很多种请求：浏览商品，购买商品，删除商品；用户登录，修改用户信息，注册用户信息。 我们可以将请求分为两类：xxx.action和xxx.do 这样可以分清楚网站请求的类别。 3.多个路径匹配一个过滤器可以匹配多个路径 xml 注解 温馨提示：路径没有/，Tomcat会报错！ 第七章 Filter应用案例1、Filter统一解决post请求乱码问题8.0版本以上的tomcat为我们解决了get请求的乱码问题。我们需要自己处理post请求的乱码问题，因为我们的一个项目中可能有很多的请求。当然，我们可以在每一个Servlet中都对post的乱码进行处理。但是，Filter给我们提供了一个更加便捷的方式。我们自定义一个Filter类，拦截所有的请求，然后对这些请求进行post乱码处理即可。 xml配置 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;&lt;!-- 全局参数：--&gt;&lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt;&lt;/context-param&gt;&lt;/web-app&gt; 【注意】过滤器doFilter方法默认拦截请求，如果需要经过过滤器之后，可以继续访问资源，要使用chain.doFilter()方法进行放行。 配置文件 ： 代码耦合性降低 开发繁琐 注解：嵌入了代码，耦合性高 简化开发 后期我们代码被编译class文件时候，可以通过修改配置文件，来修改配置信息 总结：如果后期代码经常修改，我们使用配置文件。代码不易变化，我么使用注解开发。 2、非法字符过滤器在逛论坛的时候，通常会发现一些敏感或者不和谐的字眼都被**给替代了。这个技术也可以使用我们的Filter来实现。 3、过滤器案例–登录权限校验","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"htts://cocked.github.io/tags/WEB/"}]},{"title":"05WEB初识JSP&EL&JSTL","slug":"05WEB初识JSP-EL-JSTL","date":"2017-02-26T10:53:44.000Z","updated":"2018-09-01T08:19:37.427Z","comments":true,"path":"2017/02/26/05WEB初识JSP-EL-JSTL/","link":"","permalink":"htts://cocked.github.io/2017/02/26/05WEB初识JSP-EL-JSTL/","excerpt":"","text":"1、概述1.1 JSP引入在Servlet中，能够直接获取后台服务器中的数据：获取数据方便 通过拼接字符串的形式，给浏览器响应html：操作麻烦，效率太低 ，阅读性差。 如果能够有一个既能直接书写html代码，又能书写Servlet代码的页面。就能够在客户端和服务端直接进行数据交互了。 1.2JSP是什么JSP全名为Java Server Pages，中文名叫java服务器页面，其本质是一个简化的Servlet 设计，它是由Sun 公司倡导、许多公司参与一起建立的一种动态网页 技术标准。其实就是一个既能书写Servlet代码又能书写HTML代码的文件。 jsp注释：不同的注释可见范围是不同 1）Html注释： —可见范围 jsp源码、翻译后的servlet、页面 显示html源码 2）java注释：//单行注释 /多行注释/ –可见范围 jsp源码 翻译后的servlet 3）jsp注释：&lt;%–注释内容–%&gt; —– 可见范围 jsp源码可见 1.3 创建JSP文件在web目录下，新建一个jsp文件 1.4 在JSP中书写代码 2、JSP的运行原理 我们通过浏览器访问到的jsp页面，最终访问的是tomcat服务器中的jsp页面。所以，我们可以到tomcat中查看一下上面案例中的jsp页面是怎么样的一种存在。IntilliJ IDEA借助tomcat发布web项目的机制是动态发布（为每一个web项目创建一个单独的发布文件）。我们可以通过tomcat其中日志中的CATALINA_BASE路径找到我们当前这个JSP页面在tomcat中的位置： 3、JSP中书写java代码的三种方式 在JSP页面的body标签中，可以直接书写html代码和JS代码。但是，如果在JSP页面中书写java代码。必须遵循固定的格式，才能够生效；JSP页面中书写java代码有三种方式：1.脚本片段；2.脚本声明；3.脚本表达式； 方式一：脚本片段脚本片段指的是一段java代码。书写格式：&lt;% java 代码 %&gt; 方式二：脚本声明 脚本片段虽然可以嵌入java代码，但是如果，我们要给当前的jsp中定义一些成员方法或者成员变量，就行需要一个新的技术——脚本声明. 脚本声明的格式：&lt;%! 书写Java代码 %&gt; 方式三：脚本表达式 虽然脚本声明和脚本片段已经可以书写Java代码了，但是如果我们要使用java代码向页面输出一些内容，还是需要 使用原来的response对象，比较繁琐，因此，我们需要一个更加简便的方式，可以代替response向页面输出内容 \\ ——这个就是脚本表达式。 脚本表达式的格式：&lt;%= 内容 %&gt; 等价于：out.print(内容) 【小结】 脚本表达式&lt;%= str %&gt; ：在页面输出内容，在service方法中起作用； 脚本片段&lt;% %&gt; ：在service方法中，原样输出的代码片段； 脚本声明：&lt;%! String str = &quot;34534ttert456&quot; %&gt; ：定义成员变量； write() 和println()区别 (1)、write()：仅支持输出字符类型数据，字符、字符数组、字符串等(2)、print()：可以将各种类型（包括Object）的数据通过默认编码转换成bytes字节形式，这些字节都通过write(int c)方法被输出 12response.getWriter().println();response.getWriter().write(&apos;c&apos;); response.getWriter().println();和out.write(65);区别 (1)、out和response.getWriter的类不一样，一个是JspWriter，另一个是java.io.PrintWriter。(2)、执行原理不同:JspWriter相当于一个带缓存功能的printWriter，它不是直接将数据输出到页面，而是将数据刷新到response的缓冲区后再输出，response.getWriter直接输出数据（response.print()），所以（out.print）只能在其后输出。 (3)、out为jsp的内置对象，刷新jsp页面，自动初始化获得out对象，所以使用out对象是需要刷新页面的，而response.getWriter()响应信息通过out对象输出到网页上，当响应结束时它自动被关闭，与jsp页面无关，无需刷新页面。形象的比喻：当我们调用response.getWriter()这个对象同时获得了网页的画笔，这时你就可以通过这个画笔在网页上画任何你想要显示的东西。 4、JSP页面常用对象我们发现，我们在JSP页面中书写的代码最终都会翻译到_jspService()方法中，我们发现这个方法中有两个入参：HttpServletRequest对象 ，HttpServletResponse对象 。所以说，JSP的本质就是一个Servlet。我们可以直接在JSP页面上使用这两个对象。 第二章 EL表达式 1、EL概述1.1 EL简介1234EL全称： Expression Language 作用：代替jsp中脚本表达式的功能，简化对java代码的操作，从【域对象】中取值。 EL表达式简化&lt;%= %&gt;方式取值 EL语法表达式的格式：$&#123;表达式内容&#125; 2、EL取值2.1 JSP的四大域对象JSP的四大域对象指的是：page域，request域，session域，application域。我们通常使用EL表达式从这4个域对象用取值。以下是这4个域对象的详细信息： 域对象 对象名称 说明 page域 pageScope page域指的是当前JSP页面，其中存储的数据只在当前页面有效 request域 requestScope request域：一次请求或请求链中request域 session域 sessionScope session域：一次会话过程中，session域 application域 applicationScope application域：服务启动后整个项目对应的ServletContext域 2.2 EL表达式从四大域中取值EL表达式从指定的域中取值的方式如下： 域对象 取值方式 page域 ${pageScope.xxx} request域 ${requestScope.xxx} session域 ${sessionScope.xxx} application域 ${applicationScope.xxx} 2.3 EL表达式搜索数据 EL表达式取值的时候也可以不指定域，如果取值的时候不指定域对象。就会按照从page域—&gt;request域—&gt;session域—&gt;servletContext域从小到大逐级根据name属性值查找。 2.4 EL表达式从cookie中取值 servlet生成cookie CreateCookieServlet.java 3、EL运算符 EL表达式获取到值之后可以直接通过运算符进行运算。EL表达式的运算符主要有以下几类：算术运算，关系运算，逻辑运算，三元运算，empty运算符。 3.1 算术运算 顾名思义，算术运算是进行算术运算的符号，主要包括：加，减，乘，除。具体使用如下表： 运算符 说明 使用示例 结果 + 加 ${n1+n2} 30 - 减 ${n1-n2} -10 * 乘 ${n1*n2} 200 /或div 除 ${n1/n2} %或mod 取余 3.2 关系运算 关系运算符是判断两个数据的大小关系的，关系运算符有：==，!=，&lt;，&lt;=，&gt;，&gt;=。具体使用方法如下： 运算符 说明 使用示例 结果 == 或 eq 等于 equal ${n1 == n2} false != 或ne 不等于 not equal ${n1 != n2} true &gt; 或 gt 大于 greater than ${n1 &gt; n2} false &gt;= 或ge 大于等于 greater than or equal ${n1 &gt;= n2} false &lt; 或 lt 小于 less than ${n1 &lt; n2} true &lt;= 或le 小于等于 less than or equal ${n1 &lt;= n2} true 3.3 逻辑运算 逻辑运算符包括：&amp;&amp; ，||，!使用方法如下： 运算符 说明 使用示例 结果 &amp;&amp; 或 and 逻辑与 ${true &amp;&amp; false} false \\ \\ 或 or 逻辑或 `${true ! 或 not 非 ${!false} true 3.4 三元运算 EL表达式也支持三元运算符：如，判断n1是否是正数， 表达式1?表达式2：表达式3 –%&gt; 三元运算符： ${n1&gt;=n2?”正确”:”错误！”} 3.5 empty运算empyt运算符对以下数据运算返回true： 字符串：””； 空集合（size=0）：List list = new ArrayList(); 空对象(null)：Student stu = null； EL表达式小结： EL：Expression Language； EL语法：${ } 作用：简化脚本表达式的取值，简化&lt;%= request.getAttribute(“name”) %&gt; ===&gt; ${name} jsp的四大域对象 page域：pageContext pageContext.setAttrubute() pageContext.getAttribute() JSP特有 作用范围：当前的JSP页面 requst域：request request.setAttribute() request.getAttribute() 作用范围：一次请求和响应之间 session域： session session.setAttribute() session.getAttribute() 作用范围：会话期间（多次请求和响应） servletContext域：application application.setAttribute() application.getAttribute() 作用范围：整个项目； jsp从四大域中取值（指定域对象）： ${pageScope.name} ${requestScope.name} ${sessionScope.name} ${applicationScope.name} JSP搜索域对象中的值：page — request — session — servletContext ${name} 运算 算术运算 关系运算 逻辑运算：&amp;&amp; || ！ 三元运算 empty运算：empty notempty 空字符串：”” 空对象：null 空集合：list.size = 0; 第三章 JSTL标签库1、JSTL概述1.1 、JSTL引入1.2、JSTL是什么 123456789101112从JSP 1.1规范开始JSP就支持使用自定义标签，使用自定义标签大大降低了JSP页面的复杂度，同时增强了代码的重用性，因此自定义标签在WEB应用中被广泛使用。许多WEB应用厂商都开发出了自己的一套标签库提供给用户使用，这导致出现了许多功能相同的标签，令网页制作者无所适从，不知道选择哪一家的好。为了解决这个问题，Apache Jakarta小组归纳汇总了那些网页设计人员经常遇到的问题，开发了一套用于解决这些常用问题的自定义标签库，这套标签库被SUN公司定义为标准标签库（The JavaServer Pages Standard Tag Library），简称JSTL。使用JSTL可以解决用户选用不同WEB厂商的自定义标签时的困惑，JSP规范同时也允许WEB容器厂商按JSTL标签库的标准提供自己的实现，以获取最佳性能 1.3、JSTL核心标签库 标签名称 作用 &lt;c:out&gt; 通常用于输出一段文本内容到客户端浏览器 &lt;c:set&gt; 用于设置各种Web域中的属性 &lt;c:remove&gt; 用于删除各种Web域中的属性 &lt;c:catch&gt; 用于捕获嵌套在标签体中的内容抛出的异常 &lt;c:if&gt; 用户java代码if(){}语句功能 &lt;c:choose&gt; 用于指定多个条件选择的组合边界，它必须与c:when和c:otherwise标签一起使用 &lt;c:forEach&gt; 用户代替java代码for循环语句 &lt;c:forTokens&gt; 用户迭代操作String字符 &lt;c:param&gt; 给请求路径添加参数 &lt;c:url&gt; 重写url，在请求路径添加sessionid &lt;c:import&gt; 用于在JSP页面中导入一个URL地址指向的资源内容 &lt;c:redirect&gt; 用于将当前的访问请求转发或重定向到其他资源 2、JSTL标签应用2.1 安装JSTL我们知道JSTL标签是将一段java代码功能封装成一个标签来使用。所以，我们使用JSTL标签之前必须导入被封装的java代码—jar包。JSTL标签库主要依赖以下两个jar包： 我们在IDEA的web项目的WEB-INF目录下创建一个lib文件夹，然后将jar包复制到这个文件夹里。选中这些jar包，右键—add as library即可将jar包导入到项目中。 2.2 将标签库资源引入JSP页面在JSP页面中通过以下标签，通过taglib标签引入JSTL资源： 【注意】 prefix：是jstl标签在使用的时候的前缀； uri：是标签库的资源路径； 2.3 在JSP页面中使用JSTL标签在JSP页面中书写”&lt;c: “，如果出现如下图的提示则说明标签库引入成功，我们可以根据提示信息使用自己需要的标签。 3、常用JSTL标签 3.1、c:if标签3.1.1 作用标签的作用相当于java中的if判断语句。 3.1.3 属性test：if的判断条件 3.1.2 使用示例【案例】完善登录案例，成功页面 【需求】在success.jsp页面上进行如下判断 使用 标签判断session中的用户信息是否为空； 如果不为空：获取session中的用户信息，并将其展示在页面上； 如果为空：提示用户登录； 3.2 c:foreach标签 3.2.1 c:foreach标签的作用标签的作用相当于java中的for循环。主要是对数据和集合进行遍历。 3.2.2 c:foreach标签的属性 123456var：在不循环对象的时候，保存的是控制循环的变量；在循环对象的时候，保存的是被循环对象中的元素items：指定要循环的对象varStatus：保存了当前循环过程中的信息（循环的开始、结束、步长、次数等）begin：设置循环的开始end：设置循环的结束step：设置步长——间隔几次循环，执行一次循环体中的内容 3.2.3 c:foreach标签的使用【案例】c：foreach遍历案例 【需求】 遍历普通数组； 遍历实体类对象list集合； 遍历map集合； 3.3choose标签 3.3.1 choose标签作用&lt;c:choose&gt;标签用于指定多个条件选择的组合边界，它必须与&lt;c:when&gt;和&lt;c:otherwise&gt;标签一起使用。 三个标 签组合发挥java代码if(){}else if(){} else{}语句的作用。 3.3.2 choose标签子标签介绍 &lt;c:when&gt;，相当于else if(){}。 &lt;c:when&gt;标签含有test属性，作用与if相同 &lt;c:otherwise&gt;，相当于else{}。 3.3.3 choose标签注意事项三个标签必须组合使用，一组标签中不能出现两个&lt;c:otherwise&gt; 3.3.4 choose标签演示第四章 JSP的发展 1、model1时代—一个JSP页面搞定前端和后台JSP技术主要用来简化动态网页的开发过程，由于它在形式上和html文档比较相似，因此与Servlet相比，用JSP来编写动态网页更加直观。 2、model2时代—弱化在JSP页面书写java代码但是，当网页非常复杂时，JSP文件中的大量的html标记和java程序片段混杂在一起，会大大削弱JSP代码的可读性和可维护性，而且会增加调试JSP文件的难度。于是，出现了EL表达式帮助我们在JSP页面上简化从容器中取值的操作。【EL表达式】—简化取值 如果是在JSP页面上处理一些业务逻辑，JSTL标签库给我们提供了一个解决思路。将java代码封装成标签。直接在JSP页面书写标签，如 即可完成相应逻辑。【JSTL标签库】—将java代码封装成标签 3、服务器渲染和前端渲染开发网站，网站页面渲染你知道吗？ 关键字： 服务器渲染（后端渲染） 1234服务器渲染（后端渲染）浏览器发送请求到服务器端，服务器端处理请求并处理好数据，然后生成html文件，并返回给浏览器。 传统的jsp、php都是属于服务器渲染。 关键字： 前端渲染 123客户端渲染（前端渲染）服务器端处理请求后将数据返回给浏览器，浏览器通过拼接html字符串或者使用js模板引擎，或者React这类框架进行页面渲染,又称作 ： 局部渲染 1234567前端渲染的优势：1. 局部更新页面，无需每次都进行完整页面请求2. 懒加载。页面初始时只加载可视区域内的数据，随着滚动等操作再加载其他数据3. 节约服务器成本4. 关注分离设计。服务器只用于访问数据库提供接口，前端关注展现。5. 富交互，使用 JS 实现各种酷炫效果 前后端分离（前端渲染）未来视图层的趋势。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"htts://cocked.github.io/tags/WEB/"}]},{"title":"04WEB初识Cookie&Session","slug":"04WEB初识Cookie-Session","date":"2017-02-24T13:30:12.000Z","updated":"2018-09-01T08:18:23.578Z","comments":true,"path":"2017/02/24/04WEB初识Cookie-Session/","link":"","permalink":"htts://cocked.github.io/2017/02/24/04WEB初识Cookie-Session/","excerpt":"","text":"1typora-copy-images-to: img 一、cookie&amp;session第一章 会话技术1、什么是会话​ 在日常生活中，从拨通电话到挂断电话之间的一连串的你问我答的过程就是一个会话。Web应用中的会话过程类似于生活中的打电话过程，它指的是一个客户端（浏览器）与Web服务器之间连续发生的一系列请求和响应过程，例如，一个用户在某网站上的整个购物过程就是一个会话。 简而言之：用户访问网站到离开网站，关闭浏览器，这个过程就叫回话。 2、会话过程要解决的问题​ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。Servlet在会话过程中保存数据使用到的技术有两种：Cookie技术和Session技术。 【小结】 Cookie和Session技术都是在会话期间产生的 ； Cookie和Session的作用都是保存数据 ； 第二章 Cookie技术1、Cookie是什么​ Cookie英文意指饼干，Cookie就是服务器暂存放在我们电脑上的一笔资料(where？打开浏览器)，使用我们电脑来保存一些服务器希望保存的内容。Cookie是由服务器端生成，发送给浏览器，浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器前提是浏览器设置为启用cookie。 2、Cookie基本API ​ Cookie的基本API包括Cookie的创建，往Cookie中添加数据，获取Cookie中的数据以及将Cookie响应给浏览器。 方法 使用示例 说明 创建 Cookie(String name,String value) Cookie c1 = new Cookie(“name”,”tom”) 获取name值 String getName() c1.getName() 获取value值 String getValue() c1.getValue() 发送cookie void addCookie(Cookie cookie) response.addCookie(c1) response 设置cookie的值 void setValue(String value) c1.setValue(“李四”) 获取所有cookie Cookie[] getCookies() rquest.getCookies() request 3、Cookie的存活时间&amp;有效路径 将浏览器关闭。然后再打开一个新的浏览器，登录页面上记录的用户名和密码消失了，查看浏览器中的cookie，发现之前保存的cookie都消失了。我们再次登录发现之前设置的Cookie的到期时间为”浏览器会话结束”。 ​ 如果，我们想让这个cookie在浏览器关闭后能够在一段时间内都存在，比如记住用户名或密码一周。我们可以通过设置Cookie的最大存活时间来对这个Cookie进行设置。 【概念】 会话级别 的Cookie：浏览器关闭后消失； 持久性 的Cookie：浏览器关闭后能够保存一段时间； 3.1 Cookie的最大存活时间​ 设置Cookie的最大存活时间的方法是： 方法 使用示例 说明 void setMaxAge(int seconds) userNameCookie.setMaxAge(60*60); 设置Cookie的有效时间： 如果没有设置，cookie只会保存在浏览器的缓存中，浏览器关闭后cookie立即被删除。 如果设置有效时间，在时间范围内，cookie被写入到浏览器端，关闭浏览器下次访问仍可活的，直到过期。 【注意事项】Cookie分类 会话级别的Cookie：浏览器关闭后销毁； 持久型的Cookie：设置最大存活时间； 3.2 Cookie的有效路径​ Cookie的有效路径指的是cookie允许被访问的路径。设置路径，以及子路径都被允许访问。方法如下： 方法 使用示例 说明 void setPath(String path) cookie.setPath(“/web”)cookie.setPath(“/“) 常见设置：cookie.setPath(“/“)指的是当前tomcat下的所有的web项目都可以访问这个cookie； cookie.setPath(“/web”)：指的是/web路径及其子路径可以访问这个cookie；【结果】 当给cookie设置有效路径”/web/a/b”后： 访问路径：/web 获取不到cookie； 访问路径：/web/a/b/c 能获取到cookie ; 访问路径：/web/a/b 能获取到cookie ； 访问路径：/web/a/d 获取不到; 【结论】 当设置cookie的有效路径后，只能在有效径或其子路径下访问这个cookie； 如果不给cookie设置有效路径，默认的有效路径为”/“ ，即在当前tomcat下的任意访问路径均可获取这个cookie； 一般情况下不必给cookie设置有效路径； 4、Cookie删除​ 通常情况下，如果浏览器中的cookie存储的太多，我们需要手动清除浏览器中的cookie。这是通过客户端的技术删除存储在浏览器中的cookie。Servlet中没有专门提供API去删除cookie。我们可以通过以下方式删除cookie； 【操作步骤】 创建与要删除的cookie同名的cookie，将其值设置成””; 将这个cookie的最大存活时间设置成0； 设置这个cookie的有效路径（与原cookie的有效路径一致）； 将这个新的cookie响应给浏览器，置换原来的cookie； 【小结】让cookie消失的几种方法 没有设置最大存活时间的cookie，浏览器关闭后cookie立即消失； 使用浏览器手动清除cookie； 浏览器禁用cookie； 通过Servlet技术将cookie删除； 5、Cookie小结 Cookie：服务器在客户端（浏览器）存储数据的技术； Cookie分类： 会话级别：没有设置最大存活时间的cookie，浏览器关闭后消失； 持久级别：设置了最大存活时间，浏览器关闭后不会消失； Cookie基本API: 创建Cookie：Cookie c = new Cookie(“name”,”zhangsan”); 获取name值：c.getName(); 获取value值：c.getValue(); 将cookie响应给浏览器：response.add(c); 获取所有的cookie：Cookie[] cookies = request.getCookies(); Cookie的有效时间： setMaxAge(int seconds)：以秒为单位设置cookie的存活时间； Cookie的有效路径： setPath(String path)：设置cookie的有效路径，在这个路径及其子路径下有效； Cookie删除： 客户端： 会话级别的cookie，关闭浏览器后cookie立即消失； 禁用cookie； 手动清除cookie； 服务端： 通过Servlet，将原来的cookie置换； Cookie的优势及弊端： 优势： 为服务端标识用户提供依据； 减轻了服务端数据存储的压力； 弊端： 数据存储在客户端不安全； 存储的数据大小受限，一个cookie存储的数据最大为4K； 二、 Session技术1、Session是什么 ​ Session是服务器为每个访问这个服务器的客户端用户创建的一个容器。这个容器中存储的数据能够在多个request之间实现共享。而且，这个容器只属于当前这个用户。 2、Session是怎么标识每一个用户的​ 表面上，我们说Session容器是属于某一个用户。其实在会话过程中，只有客户端(浏览器)和服务器两个角色。所以，Session容器标识的不是用户，而是当前用户正在使用的浏览器。浏览器与服务器交流是通过给服务器发送请求实现的，浏览器的每次请求中如果都有一个相同的标记用来标记session。服务器就能够识别这个用户了。 ​ 这个标记叫做JSESSIONID。我们重新演示，cookie的setPath练习，发现服务器启动后，浏览器的每次请求都会携带一个name属性值为”JSESSIONID”的cookie，这个cookie的值在每次请求过程中都是相同的。 3、Session的作用 为每个访问服务器的用户创建一个存储数据的容器； 容器中的数据在多个请求之间共享； 4、Session容器创建​ Session容器的创建，调用的方法是：request.getSession()。具体方法如下： 【练习】创建session对象 HttpSession session = new request.getSession(); session是用来标识用户的，所以不同用户访问网站，服务器都会创建不同的session保存在不同的内存中，所以session的内存地址不一样。我们可以通过不同浏览器访问同一个网站，模仿不同用户访问网站，从而打印的色三四年地址不同。 5、Session常用API​ Session常用API包括：往session容器中存储数据，删除数据，获取数据 方法 使用示例 说明 void setAttribute(String name,Object value) session.setAttribute(“loginUser”,user) 将一个对象与一个名称关联之后存储到session中 Object getAttribute( String name) session.getAttribute(“loginUser”) 通过名称获取session中的数据 void removeAttribute(String name) session.removeAttribute(“loginUser”) 根据指定名称删除session中的数据 String sessionId = session.getId(); session.getId() 获取session的id 6、Session的生命周期 6.1 Session创建​ 当客户端浏览器第一次访问服务器时，服务器为每个浏览器创建不同的HttpSession对象。在服务器端使用request.getSession()方法来获得HttpSession对象 当第一次执行 request.getSession()是session对象就被创建了。后续的request.getSession()只能获取已创建的session。 6.2 Session使用​ 对session中的数据进行增，删，获取… 6.3 Session销毁方式一：时间超出了session的存活时间​ session的默认存活时间是30分钟，在tomcat的全局配置文件web.xml中。(路径：tomcat/config/web.xml) ​ 我们可以在web.xml中自己设置这个存活时间。我们设置的这个时间会覆盖原来的存活时间。 【注意】 123注意：30分钟从什么时候开始计算？从用户最后一次访问时间开始计算：Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session&quot;活跃（active）&quot;了一次。 【案例】手动配置session的存活时间 ​ 将session-config这段配置复制到自己项目中的web.xml中。修改存活时间为1，测试生存时间。 方式二：在Servlet中手动销毁 ​ SessionTwoServlet.java 手动销毁session，调用的方法是：session.invalidate()方法； 方式三：服务器非正常关闭【了解】 ​ 如果正常关闭服务器，session的信息，会被序列化硬盘中，保存在tomcat的work\\Catalina\\localhost\\web，当tomcat下一次启动的时候，会把session加载回来。序列化的文件会被销毁。 6.4 浏览器关闭后，session持久化方案​ 通过上面的例子我们发现，浏览器关闭后，JSESSIONID就消失来，再次访问的时候又重新创建了一个新的session对象。这样，是比较消耗资源的。如何在浏览器关闭后，session能够继续存在呢？ 答案：session之所以重新创建是因为，浏览器关闭后JESSIONID这个cookie消失了。所以，就不能够在标识这个session了。如果能够让cookie不消失（或者存活时间长点）就能够在很长一段时间内把这个标识发送给Servlet了。此时Servlet就能够找到之前创建的session对象了。 【实现方案】 123 1. 在Servlet中手动创建JESSIONID；2. 手动设置JESSIONID的存活时间；3. 将JESSIONID相应给浏览器； 7、Servlet作用域总结 ServletContext域： 一个WEB应用（项目）对应一个ServletContext，这个对象中保存的数据正在整个WEB项目中都有效； 创建：服务器启动的时候； 销毁：服务器关闭或项目移除后； HttpSession： 一次会话给客户端（浏览器）创建一个session。这个对象中保存的数据，一次会话（多次请求）内数据有效； 创建：服务器第一次调用getSession()的时候； 销毁： 服务器非正常关闭（正常关闭：Session被序列化）； Session过期了：默认存活时间30分钟； 手动调用session的invalidate()方法； HttpServletRequest： 一次请求创建一个request。这个对象中保存的数据，一次请求（请求链）内数据有效； 创建：客户端向服务器发送一次请求； 销毁：服务器为这次请求做出响应之后，销毁request； 【API操作】操作三个作用域对象的API 存储数据：setAttribute(name,value); 获得数据：getAttribute(name); 删除数据：removeAttribute(name)；","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"htts://cocked.github.io/tags/WEB/"}]},{"title":"03WEB初识HttpServletResponse","slug":"03WEB初识HttpServletResponse","date":"2017-02-22T04:52:09.000Z","updated":"2018-09-01T08:09:46.580Z","comments":true,"path":"2017/02/22/03WEB初识HttpServletResponse/","link":"","permalink":"htts://cocked.github.io/2017/02/22/03WEB初识HttpServletResponse/","excerpt":"","text":"一、响应行【响应行】响应行格式：协议/版本 状态码 如：HTTP/1.1 200 ; 常见状态码： 状态码 状态码描述 说明 200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。 302 Move temporarily 重定向，请求的资源临时从不同的 URI响应请求。 304 Not Modified 从缓存中读取数据，不从服务器重新获取数据 404 Not Found 请求资源不存在。通常是用户路径编写错误，也可能是服务器资源已删除。 403 Forbidden 服务器已经理解请求，但是拒绝执行它 405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源 500 Internal Server Error 服务器内部错误。通常程序抛异常 【响应头】响应头也是用的键值对key:value，服务器基于响应头通知浏览器的行为。 常见的响应头 ： 响应头Key 响应头value location 指定响应的路径，需要与状态码302配合使用，完成跳转。 content-Type 响应正文的类型（MIME类型）例如：text/html;charset=UTF-8 content-disposition 通过浏览器以附件形式解析正文，例如：attachment;filename=xx.zip refresh 页面刷新，例如：3;url=www.qiezi.cn //三秒刷新页面到www.qiezi.com 【响应体】​ 响应体，就是服务器发送给浏览器的数据。当前请求的资源是hello.html，所以浏览器响应的数据是一个html页面。 二、HttpServletResponse对象HttpServletResponse对象代表服务器响应，tomcat创建HttpServletResponse对象，并将该对象作为参数传递给servlet的service方法。 这个对象的作用： 设置响应行、头、体 下面，就这几方面对HttpServletResponse对象的常用API进行详细讲解： 2、HttpServletResponse对象常用API2.1【响应行】​ 响应行：协议/版本 如：HTTP/1.1 200 。这里边的信息，我们通常只会用到状态码，操作状态码的方法setStatus(int code); 方法 说明 setStatus(int code) 向浏览器发送状态码 练习服务器重定向 123 //location+302 共同完成重定向 重定向到login.html图片`` response.setHeader(\"location\", \"login.html\");`` response.setStatus(302); //可以使用一行代码替换``response.sendRedirect(\"login.html\"); 对应的状态码响应状态码常量 说明 200 响应成功 404 资源路径错误或资源被删除 500 服务器内部错误 302 重定向 2.2 【响应头】 方法 说明 setHeader(String name,String value) 设置响应头信息 1 给浏览器设置响应头：Content-Disposition 告诉浏览器以附件的形式打开这个文件response.setHeader(\"Content-Disposition\",\"attachment;filename=\"+fileName); 【常见响应头】 响应头Key 响应头value refresh 页面刷新，例如：3;url=www.itcast.cn //三秒刷新页面到www.itcast.cn content-type 设置响应数据的类型（MIME类型）和编码格式 例如：text/html;charset=UTF-8 location 指定响应的路径，需要与状态码302配合使用，完成重定向。 content-disposition 通过浏览器以附件形式解析正文，例如：attachment;filename=xx.zip。 2.处理响应乱码乱码产生的原因​ 服务器如果需要响应给浏览器中文数据，tomcat使用getWriter()输出字符时，对于中文需要进行编码处理，而tomcat8 默认编码是ISO-8859-1,该码表是不支持中文编码的。所以响应给浏览器，出现乱码。 响应乱码解决方案​ 因为HttpServlerResponse实现类是由tomcat服务器提供的。所以服务器在向浏览器输出数据之前，对于中文要采用支持中文的编码进行编码，通过response.setContentType(&quot;text/html;charset=utf-8&quot;); ： 设置响应的数据类型（mime-type）; 设置响应的数据编码（utf-8）； 处理响应乱码的API 方法 说明 response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;); 设置响应头 response.setContentType(&quot;text/html;charset=utf-8&quot;); 简写方式 【注意事项】 开发中通常使用response.setContentType(&quot;text/html;charset=utf-8&quot;);来处理响应乱码； 处理响应乱码必须书写在响应数据之前才起作用； 3.重定向【重定向API】 方法 说明 response.setStatus(302); response.setHeader(&quot;location&quot;, &quot;/otherServlet&quot;); 通过设置响应状态码和响应头实现重定向 response.sendRedirect(&quot;/otherServlet&quot;); 重定向的简写方式 【注意事项】 开发中通常使用response.sendRedirect(&quot;/otherServlet&quot;);来实现重定向。 转发和重定向的区别 区别点 转发 重定向 实现原理 服务器内部 浏览器执行 请求次数 一次 两次 浏览器地址栏地址 不变化 变为第二次请求的地址 能否共享request域 能够共享 不能共享 作用 共享request域对象 完成跳转 转发和重定向怎么选择 如果需要共享request域，必须使用转发； 如果需要将浏览器地址栏地址变为第二次请求的地址，必须使用重定向； 2.4【响应体】 方法 说明 ServletOutputStream getOutputStream() 用于向浏览器输出二进制数据。【字节流–文件下载】 java.io.PrintWriter getWriter() 用于向浏览器输出字符数据。【字符流–给浏览器响应数据】","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"htts://cocked.github.io/tags/WEB/"}]},{"title":"02WEB初识http&request","slug":"02WEB初识http-request","date":"2017-02-19T17:50:58.000Z","updated":"2018-09-01T08:02:02.421Z","comments":true,"path":"2017/02/20/02WEB初识http-request/","link":"","permalink":"htts://cocked.github.io/2017/02/20/02WEB初识http-request/","excerpt":"","text":"一、Http协议什么是协议：网络通信中，数据以固定的格式传输数据.HTTP协议：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 简而言之：浏览器和服务器数据交换固定的格式。 请求协议：浏览器将数据以请求格式发送到服务器。 响应协议：服务器将数据以响应格式返回给浏览器。 1、什么是HTTP协议HTTP协议，全称”超文本传输协议(HyperText Transfer Protocol)”是互联网上应用最为广泛的一种网络协议。简而言之，就是一种在web中传输数据的格式。 2、HTTP协议的特点\\1. 基于请求/响应模型的协议。请求和响应必须成对，先有请求后有响应。 浏览器是通过请求协议将数据传递到服务器，浏览器访问服务器几种方式： （了解一下），其中掌握的就是get和post方式，下面我们使用抓包工具来分析get和post请求有何不同。 请求方式 请求说明 OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息 GET 向特定的资源发出请求(a href=”servlet”标签/js location.href=”servlet”) POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改 PUT 向指定资源位置上传其最新内容 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 回显服务器收到的请求，主要用于测试或诊断 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。 重点掌握：get/post 3、HTTP协议的结构HTTP协议的结构包括两部分：请求报文，响应报文； 请求报文：浏览器给服务器发送的请求数据的格式。请求报文主要包括：请求行 ，请求头 ，请求体 。 响应报文：服务器给客户端（浏览器）响应的报数据格式。响应报文主要包括：响应行 ，响应头 ，响应体 ； 4、浏览器抓包观察请求报文浏览器可以抓取请求的数据，但是现在的浏览器都对请求的参数在格式上进行了优化。如果想要看到原始的请求报文，需要使用到工具。使用Fiddler这个工具对请求数据进行抓取分析。 请求报文分析 【请求行】 请求行位于请求报文的第一行，由：请求方式 url 协议/版本 组成 POST http://localhost:63342/web/web/requestTest.html HTTP/1.1 【请求头】 位于请求行的下面，以键值对 的形式给服务器传递信息，有些请求头信息是非必须的。 Host: localhost:63342 Connection: keep-aliv Content-Length: 25 Cookie: JSESSIONID=AEE81E76BF586D353D84886D9B5E0BFD; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 【常用的请求头】： 请求头 示例 说明 User-Agent User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) 浏览器携带的用户操作系统，浏览器版本等信息 【请求体】 get请求请求体为空；post请求的请求体传递请求参数 。注意，请求体与请求头之间有一个空行。 userName=zhangsan&amp;pwd=123 5、HTTP协议小结1. HTTP：超文本传输协议，定义了浏览器与服务器之间数据传输的格式； 2. HTTP协议组成： 1. 请求报文：请求行，请求头，请求体； 1. 请求行：请求报文中的第一行数据，包括**请求方式**，**URL** ，**协议/版本** ; 2. 请求头：以键值对的数据格式，给服务器传输数据。常用的请求头：user-agent,cookie； 3. 请求体：get请求：没有请求体；post请求：请求体传递请求参数； 2. 响应报文：响应行，响应头，响应体； GET和POST请求区别 GET请求：请求行直接传递请求参数 将请求参数追加在URL后面，不安全。例如：form.html?username=jack&amp;username=1234 URL长度限制GET请求方式的数据大小，不可以传输数据量较大或者非文本数据 请求体里面没有内容 POST请求 请求参数以请求体形式发送给服务器，数据传输安全 请求数据可以为非文本数据，可以传输数据量较大的数据 只有表单设置为method=”post”才是post请求.其他的都是get请求 常见GET请求：地址栏直接访问、&lt;a href=””&gt;、&lt;img src=””&gt; 等 浏览器和服务器是以固定的格式进行通信的，采取的HTTP协议的请求协议。浏览器通过请求协议，将数据传送到服务器中。 二、request&amp;请求数据获取1，获取请求行信息 方法 说明 String getMethod() 获取请求方式的类型 StringBuffer getRequestURL() 获取客户端发出请求完整URL String getRemoteAddr() 获取IP地址 String getProtocol() 获取当前协议的名称和版本 2.获取请求头信息 方法 作用 String getHeader(String name) 根据请求头的k关键字获取请求头信息 Enumeration getHeaderNames() 返回此请求包含的所有头信息的枚举 扩展：K关键字如下 请求头key 请求头value referer 浏览器通知服务器，当前请求来自何处,如果是直接访问，则不会有这个头。常用于：防盗链 If-modified-Since 浏览器通知服务器，本地缓存的最后变更时间。与另一个响应头组合控制浏览器页面的缓存。 cookie 与会话有关技术，用于存放浏览器缓存的cookie信息。 user‐agent 浏览器通知服务器，客户端浏览器与操作系统相关信息 connection 保持连接状态。Keep-Alive 连接中，close 已关闭 host 请求的服务器主机名 content-length 请求体的长度 content-type 如果是POST请求，会有这个头，默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码 accept 浏览器可支持的MIME类型。文件类型的一种描述方式。 mime格式 浏览器请求数据的类型，例如： text/html ，html文件 text/css，css文件 text/javascript，js文件 image/*，所有图片文件 accept-encoding 浏览器通知服务器，浏览器支持的数据压缩格式。如：GZIP压缩 accept-language 浏览器通知服务器，浏览器支持的语言。各国语言（国际化i18n） …. ….. 3.请求体中获取请求参数的方法 方法名 描述 String getParameter(String name) getParameter获得指定参数名对应的值。如果没有返回null，如果只有多个获得第一个。 例如：username=jack String[] getParameterValues(name) getParameterValues[] 获取请求数据key相同的多个数据 request.getParameterMap(); 获得所有表单的数据 三、request作用域1、request的声明周期一次请求和响应的完整流程 1.浏览器向servlet发送请求 2.tomcat收到请求后，创建Request和Response两个对象，并将请求数据封装到request对象中，然后传递给servlet 3.Servlet收到请求后，调用doget和dopost方法，处理浏览器的请求信息，然后通过Response返回信息 4.tomcat接受到返回的信息，返回给浏览器 5.浏览器接收到返回信息后，tomcat销毁Request和Response两个对象，同时销毁这两个对象所获得的信息 创建：浏览器给服务器发送请求后，tomcat创建request对象封装请求数据； 销毁：服务器给浏览器响应信息结束后销毁； 特点：浏览器每次给服务器发送请求，服务器都会为这次请求创建一个request对象 2.request域对象request域对象，一个存储数据的区域对象，是把request当成一个容器存储数据，request域存储数据主要是用于在两个servlet之间传递数据。request作为域对象，常用的方法如下： 方法 说明 void setAttribute(String name, Object o) 往request域中设置值 Object getAttribute(String name) 从request域中取值 void removeAttribute(String name) 从request域中移除值 【注意】getParameter()方法和getAttribute()方法的区别 getParameter()方法获取的是浏览器提交的数据（多是表单提交的数据）；getAttribute()方法获取的是request域中的数据（通过request.setAttribute()设置的值）； 3.请求转发 方法 说明 RequestDispatcher getRequestDispatcher(String path) 获取请求转发器（request对象方法） void forward(ServletRequest request, ServletResponse response) 将请求转发到另一个资源（Servlet）上 【小结】转发 转发是服务器内部的跳转行为； 从一个Servlet转发到另一个资源（静态或动态），能够实现跳转，但是浏览器地址栏地址没有发生改变。因为对浏览器来说本质上就只有一次请求； 请求转发的作用：共享request域中的数据；","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"htts://cocked.github.io/tags/WEB/"}]},{"title":"01EB初识Tomcat&Servlet","slug":"01EB初识Tomcat-Servlet","date":"2017-02-19T13:51:39.000Z","updated":"2018-09-01T08:02:32.213Z","comments":true,"path":"2017/02/19/01EB初识Tomcat-Servlet/","link":"","permalink":"htts://cocked.github.io/2017/02/19/01EB初识Tomcat-Servlet/","excerpt":"","text":"#Tomcat简介使用Tomcat-8.5.31 Tomcat目录： bin：脚本目录 启动脚本：startup.bat 停止脚本：shutdown.bat conf：配置文件目录 (config /configuration) 核心配置文件：server.xml 用户权限配置文件：tomcat-users.xml 所有web项目默认配置文件：web.xml lib：依赖库，tomcat和web项目中需要使用的jar包 logs：日志文件. localhost_access_log..txt tomcat记录用户访问信息，..表示时间。 例如：localhost_access_log.2017-04-28.txt ​ temp：临时文件目录，文件夹内内容可以任意删除。 webapps：默认情况下发布WEB项目所存放的目录。 work：tomcat处理JSP的工作目录。 启动与结束： 双击tomcat解压目录/bin/startup.bat 文件即可启动tomcat。[http://ip:8080即可访问tomcat服务器](http://ip:8080即可访问tomcat服务器) 启动报错原因： (1) JAVA_HOME 配置 如果没有配置JAVA_HOME环境变量，在双击“startup.bat”文件运行tomcat时，将一闪立即关闭。 解决方式：需要正确配置JAVA_HOME环境变量，指向JDK的bin目录的上一级目录； （2）端口号冲突 一台拥有ip地址的主机上可以提供多个服务(启动多个软件)，每一个服务都有一个唯一的端口号。所以端口号不能 重复。 使用IDEA创建一个WEB项目： #Servlet入门\\1. 客户端（浏览器）发送的数据会被提交到服务器； \\2. 服务器必须具备：1.接收请求数据；2.处理请求数据(业务逻辑的处理)；3.给浏览器生成响应信息的能力； \\3. tomcat服务器遵从了JavaEE规范，Sun公司制定的动态资源规范Servlet实现这个功能；（运行在服务器端，能够接收用户请求，处理请求数据和给浏览器生成响应信息） \\4. 在java的世界里制定规范往往是接口来实现的，所以Servlet是一个接口，里边只是定义了一些方法； \\5. 如果，我们对这个接口进行具体的实现，就能够完成对用户数据的接收，处理和生成响应信息； 1、什么是ServletServlet 运行在服务端的Java小程序，是sun公司提供一套规范，用来处理客户端请求、响应给浏览器的动态web资源。 Servlet是JavaWeb三大组件之一（Servlet、Filter、Listener），是最重要的组件。 Servlet 的作用 \\1. 接收请求 ：接收客户端发送的请求数据； \\2. 业务逻辑的处理； \\3. 响应结果 ：将处理结果响应给客户端（浏览器）； 2、Servlet入门开发步骤\\1. 创建一个普通java类实现Servlet接口； \\2. 重写Servelt接口中的所有抽象方法； \\3. 注册这个类； 在web.xml中配置这个类的信息； 配置这个类的映射路径； \\4. 在service方法中处理请求和响应的业务逻辑； \\5. 发布项目，启动项目之后，通过映射路径访问这个类； 3、Servlet入门例子【例】Servlet入门例 需求分析 ： \\1. 编写一个Servlet，接收客户端（浏览器）的请求； \\2. 接收到请求之后给浏览器响应数据”Hello Servlet!”； 技术分析 ： servletResponse.getWriter().print(&quot;Hello World!&quot;); 实现步骤： \\1. 创建一个普通java类HelloServlet实现Servlet接口，并重写Servlet接口的所有抽象方法； 123456789101112131415161718192021222324252627public class HelloServlet implements Servlet&#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125; &#125; \\2. 在web.xml中配置这个HelloServlet的类路径和映射路径，配置信息如下； 12345678910【注意】 url-pattern 映射路径前面必须添加\"/\"； &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qiezi.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; \\3. 在HelloServlet的service方法中书写响应的代码逻辑； 123456789 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(\"请求进来了................\"); servletResponse.getWriter().print(\"Hello Servlet!\"); &#125;启动tomcat，根据web.xml中的配置访问HelloServlet。访问路径为：http://ip:8080/hello【注意事项】 使用idea创建的web项目，可以通过配置，访问路径中不需要添加项目名，具体配置如下： 4、Servlet编程优化我们发现在上述的HelloServlet中，实现Servlet接口后能够接收浏览器发送的请求并能够响应数据给浏览器。但是Servlet是一个接口，我们实现接口后必须重写接口中所有的方法。但是，我们在接口请求和响应数据的时候只需要一个service方法就足够了。所以，我们需要有选择地实现父类的方法。 子类继承父类时，可以根据子类的需求选择性地重写父类的方法。 4.1 方案一：GenericServlet优化方案 1) GenericServlet简介 GenericServlet类是一个抽象类，它实现了多个接口，其中有一个是Servlet，所以它重写了Servlet接口中的所有方法。我们只需要继承GenericServlet类，重写其中的service方法即可。 2）为什么要继承GenericServlet \\1. GenericServlet实现了Servlet接口，我们继承GenericServlet之后相当于间接实现了Servlet接口； \\2. GenericServlet中给我们提供了很多通用方法，这些方法已经帮我们实现了很多功能，继承GenericServlet之后可以直接调用这些方法，所以说，GenericServlet相对于Servlet，进行了功能的扩展和衍生； \\3. GenericServlet是一个抽象类，里边只有一个抽象方法service()，我们继承GenericServlet之后只需要重写service()方法处理具体的业务逻辑即可，减少了直接实现Servlet接口带来的代码冗余； 3） 案例：使用GenericServlet优化Servlet接口编程 需求分析 ：使用GenericServlet重写入门案例 技术分析 ： 1. 创建一个普通的java类继承GenericServlet； 2. 在web.xml中配置这个GenericServlet的子类； 3. 重写service方法，在service方法中完成向浏览器响应数据的功能； 实现步骤 ： \\1. 编写一个普通的java类，ServletDemo1，继承GenericServlet； 1234567891011121314package com.qiezi.servlet; import javax.servlet.GenericServlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException; public class ServletDemo1 extends GenericServlet &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; &#125; &#125; \\2. 在web.xml配置ServletDemo1； 12345678&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qiezi.servlet.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; \\3. 重写service方法，并在service方法中书写以下代码，完成向页面响应数据； 1234 @Overridepublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; res.getWriter().print(\"Hello GenericServlet!!!!\"); &#125; \\4. 启动tomcat并访问： 4.2 方案二：HttpServlet优化方案 问题： 在实际的生活中，客户端（浏览器）给我们发送的请求往往是HTTP协议下的请求，所以我们只需要处理HTTP的请求和响应即可。也就是说我们需要的知识一个与HTTP协议相关的Servlet。 解决方案： Sun公司为我们提供了HttpServlet,对GenericServlet再次进行扩展和功能加强。 实际开发中：我们编写Servlet就可以采用 继承HttpServlet来完成servlet的开发,这样的Servlet我们可以获取更多的业务功能。 1）HttpServlet简介： HttpServlet是GenericServlet的一个子类。这个类是专门帮我们处理与HTTP协议相关的请求与响应的一个Servlet类，它里边的方法如下： 因为，在我们的日常生活中最常用的HTTP请求只有get请求和post请求。所以我们在继承了HttpServlet之后只需要重写里边的doGet()方法和doPost()方法即可满足我们的需求： 2）为什么要继承HttpServlet \\1. HttpServlet继承了GenericServlet，功能比GenericServlet更强大； \\2. GenericServlet中处理不同的请求都使用service()方法，HttpServlet根据不同的请求方式提供了不同的方法进行处理。等于是细化了service()方法； \\3. HttpServlet类中的方法参数为HttpServletRequest对象和HttpServletResponse对象。使用这两个对象的好处在于： HttpServletRequest继承了ServletRequest，HttpServletResponse继承了ServletResponse。功能更强大； HttpServletRequest和HttpServletResponse为我们提供了很多处理HTTP协议相关的API，HTTP协议正是我们日常生活中使用得比较多的一种协议； （3）HttpServlet编程 123456789101112【Servlet优化二】HttpServlet编程 public class FormServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"处理get请求提交的数据.................\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"处理post请求提交的数据..................\"); &#125; &#125; （4）请求是怎么到达doGet（）和doPost()的 在我们继承HttpServlet之后，重写了doGet()和doPost()方法。浏览器发送的get请求会被doGet()接收并处理，浏览器发送的post请求会被doPost()请求接收并处理。服务器端是怎么辨别我的请求是get还是post请求的呢？下面，我们看一下HttpServlet的源码中的service方法： \\1. 实际处理请求的还是HttpServlet的service()方法； \\2. service方法中，接收请求之后获取了请求方式， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取数据的请求方式 String method = req.getMethod(); //根据请求方式的不同，调用不同的方法 if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; //调用doGet()方法 doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); &#125; catch (IllegalArgumentException iae) &#123; // Invalid date header - proceed as if none was set ifModifiedSince = -1; &#125; if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); //调用doPost()方法 &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; 4.3 Servlet编程优化小结 \\1. Servlet编程的作用：接收浏览器的请求，处理请求数据，给浏览器响应数据； \\2. Servlet接口： Sun公司规定如果想要在服务端接收和响应客户端的数据，必须实现Servlet接口； 由于Servlet是一个接口，实现Servlet接口后必须重写其中所有的方法； \\3. GenericServlet： GenericServlet：是一个抽象类，它实现了Servlet接口，与协议无关； 继承GenericServlet，只需要重写service方法即可接收和响应数据； \\4. HttpServlet： HttpServlet：是一个抽象类，它继承了GenericServlet，为HTTP请求定制的； 继承HttpServlet，重写doGet和doPost方法，能够更加方便地处理不同请求的数据； 5、Servlet生命周期生命周期指的是一个对象从创建到销毁的过程。我们的Servlet是由谁创建的，何时创建的，创建之后做了哪些工作，工作完成之后又是何时销毁的呢？下面我们就来看一下Serlvet的生命周期。 谁创建：tomcat创建； 何时创建：第一次访问这个Servlet的时候，只创建一次，创建完成后会调用init()方法； 如何工作：每次请求到这个Servlet时，由service方法处理请求和响应信息； 何时销毁：服务器正常关闭，销毁前会调用destory()方法； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859【测试代码】 public interface Servlet &#123; /* * Servlet对象创建的时候会调用init()方法 */ public void init(ServletConfig config) throws ServletException; /* * Servlet对象创建后，每次的请求都由service方法处理 */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; /* * Servlet对象销毁前会调用destory方法。主要是用于释放一些资源。 */ public void destroy(); &#125;【实现类】 package com.qiezi.user.web; import javax.servlet.*; import java.io.IOException; public class LifeCycleTestServlet implements Servlet &#123; public LifeCycleTestServlet() &#123; System.out.println(\"LifeCycleTestServlet对象被创建了...........\"); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(\"init方法被调用了.............\"); &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(\"service方法被调用了............\"); &#125; @Override public void destroy() &#123; System.out.println(\"destory方法被调用了........\"); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public String getServletInfo() &#123; return null; &#125; &#125; 【小结】 Servlet对象的创建： 创建者：tomcat；创建时机：在Servlet第一次被访问的时候； 特点： 只会创建一次（单例）； 对象创建完成之后，会调用init()方法； Servlet运行： service()方法接收用户的请求，和处理响应； 特点： 每次对这个Servlet的访问都会由service()方法来处理； service()方法的两个参数：request和response对象专门用来处理请求和响应； Servlet销毁： Servlet对象在服务器正常关闭的时候销毁； 特点： 销毁的时候会调用destory()方法； 【注意】Servlet对象是单例的，会不会产生线程安全问题？ 答：线程安全问题的产生是因为要争夺共同的资源，所以只要不在Servlet类中设置成员变量就可以避免。 6、 Servlet映射路径配置规范url-pattern中的映射路径配置存在以下几种方式： 1. 完全匹配 /user/hello 资源路径为/user/hello时可以访问 2. 目录匹配 /user/* 资源路径中含有/user目录均可访问 3. 后缀名匹配 *.do 资源路径中以.do结尾的均可访问 4. 缺省路径 / 访问的路径找不到，就会去找缺省路径 tomcat获得匹配路径时，优先级顺序：1 &gt;2 &gt; 3 &gt; 4 开发中一般使用完全匹配，即一个Servlet对应一个映射路径。 \\1. 配置servlet的实现类信息： 12345&lt;!--1.配置HelloServlet的类路径--&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.heima.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; \\2. 配置这个实现类的映射路径： 12345&lt;!--2.配置映射路径，映射到HelloServlet--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; \\3. url-pattern配置规则 1234567891011&lt;!--1.配置HelloServlet的类路径--&gt;&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qiezi.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;!--2.配置映射路径，映射到HelloServlet--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 【关于缺省路径】web.xml URL输入http://localhost:8080/ 如何读取文件？ 1）到当前WEB应用下的web.xml文件查找是否有匹配的url-pattern。 2）如果没有匹配的url-pattern，则交给tomcat的内置的DefaultServlet处理。 3）DefaultServlet程序到WEB应用的根目录下查找是否存在一个名称为index.html的静态文件。 4）如果找到该文件，则读取该文件内容，返回给浏览器。 5）如果找不到该文件，则返回404错误页面。 7.服务器启动，立刻加载Servlet对象 问题：普通的Servlet对象在我们第一次访问的时候创建， 开发中，如果我们需要在服务器启动的时候，初始化Servlet对象应该如何编写呢？ 需求：服务器tomcat启动，立刻加载配置文件，获取配置文件信息，为项目后续代码提供数据支持。 解决：此时的业务场景，我们需要在web.xml文件中给指定的Servlet添加一个标签 实现步骤:在web.xml中在标签内部中配置: 2 — 传入正整数,整数越小,被创建的优先级就越高。12345 #Servlet3.0注解开发在我们上面创建的Servlet中，Servlet的配置信息都是在web.xml中完成的。如果，我们创建的Servlet非常多，就会导致web.xml中的配置非常臃肿，不便于管理。Servlet3.0为我们提供了注解支持，创建Servlet的时候。在这个Servlet类上面添加注解就可以完成Servlet的配置。Servlet3.0除了提供注解支持，还提供了以下新特性： 1、Servlet3.0新特性- 注解支持 该版本新增了若干注解，用于简化 Servlet、过滤器（Filter）和监听器（Listener）的声明，这使得 web.xml 部署描述文件从该版本开始不再是必选的了。 - 支持web模块(servlet filter Listener) - 支持Servlet异步处理 - 文件上传API简化 【注意】详细信息请参考Servlet3.0新特性全解 2、为什么要使用注解\\1. web.xml中配置过多servlet不便于管理，容易出错； \\2. 注解开发使得开发更敏捷，效率更高； \\3. 注解开发是一种趋势； 3、使用IDEA创建3.0版本的Servlet新版的IDEA（2017版本）创建的Servlet默认是3.0版本的，所以我们只需要新建一个Servlet，然后用注解配置即可。具体步骤如下： 第一步：新建一个Servlet； 在包上面点击鼠标右键New--&gt;Servlet 给这个Servlet取个名，然后点击OK 第二步：配置Servlet 创建完成后，Servlet类上面会默认添加一个注解@WebServlet(name=&quot;Servlet3Demo&quot;) 。这个@WebServlet注解就是用来配置当前这个Servlet的。这个注解中常用的有两个属性： \\1. name属性： 相当于web.xml的 ； \\2. urlPatterns属性： 编写访问servlet的路径 类似于 所以，我们需要手动在@WebServlet 注解中添加urlPatterns属性，来设置映射路径。 123456789101112131415161718192021222324package com.qiezi.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /* * 1. name属性： 相当于web.xml的 &lt;servlet-name&gt;； * 2. urlPatterns属性： 编写访问servlet的路径 类似于 &lt;url-pattern&gt; */ @WebServlet(name = \"Servlet3Demo\",urlPatterns = \"/servlet3\") public class Servlet3Demo extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; &#125; 4、优化4.1 优化一 我们继承HttpServlet之后，重写doGet()方法处理get请求，重写doPost()方法处理post请求。但是，浏览器发送的请求到底是get请求还是post请求，我们在书写Servlet代码的时候并不知道。所以，需要在doPost()方法中调用doGet()方法，或者是在doGet()方法中调用doPost()方法。这样我们只需要在一个方法中处理请求了。 4.2 优化二 基于IDEA的模板，快速创建Servlet。 【模板配置代码】 123456789101112131415#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != \"\")package $&#123;PACKAGE_NAME&#125;;#end#parse(\"File Header.java\")@javax.servlet.annotation.WebServlet(urlPatterns=\"/$&#123;Entity_Name&#125;\")public class $&#123;Class_Name&#125; extends javax.servlet.http.HttpServlet &#123; @Override protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, java.io.IOException &#123; doPost(request, response); &#125; @Override protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, java.io.IOException &#123; &#125;&#125; 5、Servlet开发最终版本12345678910@WebServlet(\"/lastDemo\")public class LastDemoServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125;","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"htts://cocked.github.io/tags/WEB/"}]},{"title":"19JavaSE操作数据库总结","slug":"19JavaSE操作数据库总结","date":"2017-02-17T02:58:36.000Z","updated":"2018-08-27T03:20:14.350Z","comments":true,"path":"2017/02/17/19JavaSE操作数据库总结/","link":"","permalink":"htts://cocked.github.io/2017/02/17/19JavaSE操作数据库总结/","excerpt":"","text":"一、JDBC JDBC有关的类：都在java.sql 和 javax.sql 包下. 1.数据准备这里假设已经在数据库中新建立了mydb4数据库，并且也插入了一些数据， 并且还需要导入一个jar包mysql-connector-java-5.1.17jar(可从官网下载) 2.JDBC 编程步骤**步骤1：**装载驱动 DriverManager.registerDriver(new Driver()); tips：在装载驱动的时候推荐使用**Class.forName(“com.mysql.jdbc.Driver”);** ​ 一、查看Driver的源代码可以看到，如果采用此种方式，会导致驱动程序注册两次，也就是在内存中会有两个Driver对象。 二、程序依赖mysql的api，脱离mysql的jar包，程序将无法编译，将来程序切换底层数据库将会非常麻烦。** **步骤2：建**立连接 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb4&quot;, &quot;root&quot;, &quot;111&quot;); 步骤3：操作数据库 1234567891011 Statement statement = conn.createStatement();ResultSet rs = statement.executeQuery(sql);while (rs.next()) &#123; System.out.println(rs.getString(\"username\")); System.out.println(rs.getString(\"email\"));&#125; 步骤4：释放资源 12345rs.close();statement.close();conn.close(); 3.一步到位的操作方式（更加面向对象&amp;&amp;解决SQL注入问题）： 将重复的内容 提取到JDBCUtils工具类中： 提供两种版本分别是硬编码和软编码 硬编码（信息写入到程序中）： JDBCUtils工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class JDBCUtils &#123; private static final String driverClass = \"com.mysql.jdbc.Driver\"; // 当时本地默认3306 可以省略，也可写成 \"jdbc:mysql://localhost:3306/mydb4?\" private static final String url = \"jdbc:mysql:///mydb4?\"; private static final String user = \"root\"; private static final String password = \"111\"; // 加载驱动 public static void loadDriver() &#123; // 1. 加载驱动 try &#123; Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); throw new RuntimeException(\"驱动加载失败!\"); &#125; &#125; // 获取连接 public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829@Testpublic void test_query() &#123; // 1. 加载驱动 JDBCUtils.loadDriver(); Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; // 2. 建立连接 conn = JDBCUtils.getConnection(); // 3. 操作数据 String sql = \"select * from user;\"; // 这里有可能引起sql注入问题，换成prepareStatement（sql） stmt = conn.createStatement(); rs = stmt.executeQuery(sql); while (rs.next()) &#123; String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); System.out.println(username + \" = \" + password); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125;&#125; 软编码：从配置文件中读取（配置文件名字jdbc.properties） 1234567#配置文件#jdbc.properties#mysqldriverClass=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:///mydb4?user=rootpasswrod=111 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class JDBCUtils &#123; // 属性 private static String driverClass; private static String url; private static String username; private static String password; // 请问 : 什么时候加载外部配置文件最合适 ??? // 特点1 : 随着类的加载而加载. // 特点2 : 静态代码块只在类加载的被执行一次. 仅一次. static &#123; Properties prop = new Properties(); try &#123; prop.load(new FileReader(\"jdbc.properties\")); // 这里直接放在项目的目录下，具体要切合实际 // 如果程序执行到这里, 说明外部资源文件加载成功, 需要给我们的静态属性赋值 driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); // 直接执行加载驱动 loadDriver(); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(\"文件资源加载失败!\"); &#125; &#125; // 加载驱动 public static void loadDriver() &#123; try &#123; // 1. 加载驱动 Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; // e.printStackTrace(); // 驱动加载失败! throw new RuntimeException(\"驱动加载失败!\"); &#125; &#125; // 建立连接 public static Connection getConnection() throws SQLException &#123; // 2. 建立连接 return DriverManager.getConnection(url, username, password); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; // 4. 释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; // 将 rs 清空 rs = null; &#125; // 直接调用 release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; // 4. 释放资源 if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829303132333435@Test public void test_query() &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"select * from user where username = ? and password = ?;\"; // 预编译sql stmt = conn.prepareStatement(sql); // 设置sql语句的参数 stmt.setString(1, username); stmt.setString(2, password); // 执行sql语句 rs = stmt.executeQuery(); // 判断返回的结果 if (rs.next()) &#123; // 登录成功 int id = rs.getInt(\"id\"); String u_name = rs.getString(\"username\"); String u_pwd = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + u_name + \" : \" + u_pwd + \" : \" + email); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125; &#125; JDBCUtils中避免sql注入问题之后最终版总结： PreparedStatement的CRUD 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 @Test public void test_update() &#123; Connection conn = null; PreparedStatement stmt = null; try &#123; // 2. 建立连接 conn = JDBCUtils.getConnection(); // U 修改 // 3. 操作数据 String sql = \"update user set username = ?, password = ?, email = ? where id = ?;\"; stmt = conn.prepareStatement(sql); // 设置参数 stmt.setString(1, \"张三\"); stmt.setString(2, \"888\"); stmt.setString(3, \"zs@qiezi.cn\"); stmt.setInt(4, 1); // 执行 int affectedRowNum = stmt.executeUpdate(); System.out.println(affectedRowNum);// 删除 // 2. 操作数据 String sql = \"delete from user where id = ?;\"; stmt = conn.prepareStatement(sql); stmt.setInt(1, 4); int affectedRowNum = stmt.executeUpdate(); System.out.println(affectedRowNum); // 增加 // 2. 操作数据 String sql = \"insert into user values(?,?,?,?);\"; stmt = conn.prepareStatement(sql); // 设置参数 stmt.setInt(1, 4); stmt.setString(2, \"赵六\"); stmt.setString(3, \"888\"); stmt.setString(4, \"zl@qiezi.cn\"); int affectedRowNumber = stmt.executeUpdate(); System.out.println(affectedRowNumber); // 查询 // 2. 操作数据 String sql = \"select * from user where username = ? and password = ?;\"; stmt = conn.prepareStatement(sql); // 设置sql语句的参数 stmt.setString(1, username); stmt.setString(2, password); // 执行sql语句 rs = stmt.executeQuery(); // 判断返回的结果 if (rs.next()) &#123; // 登录成功 int id = rs.getInt(\"id\"); String u_name = rs.getString(\"username\"); String u_pwd = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + u_name + \" : \" + u_pwd + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125; 二、JdbcTemplate1.JdbcTemplate 介绍JDBC已经能够满足大部分用户最基本的需求，但是在使用JDBC时，必须自己来管理数据库资源如：获取PreparedStatement，设置SQL语句参数，关闭连接等步骤。JdbcTemplate就是Spring对JDBC的封装，目的是使JDBC更加易于使用。JdbcTemplate是Spring的一部分 JdbcTemplate处理了资源的建立和释放。他帮助我们避免一些常见的错误，比如忘了总要关闭连接。他运行核心的JDBC工作流，如Statement的建立和执行，而我们只需要提供SQL语句和提取结果。 在JdbcTemplate中执行SQL语句的方法大致分为3类： \\1. execute：可以执行所有SQL语句，一般用于执行DDL语句。 \\2. update：用于执行INSERT、UPDATE、DELETE等DML语句。 \\3. queryXxx：用于DQL数据查询语句。 **新增加，新复习 1234567891011121314151617181920212223242526272829303132333435DDL （数据定义语言）数据定义语言 - Data Definition Language用来定义数据库的对象，如数据表、视图、索引等create drop alter truncateDML （数据操纵语言）数据处理语言 - Data Manipulation Language在数据库表中更新，增加和删除记录如 update， insert， delete 不包含查询DCL （数据控制语言）数据控制语言 – Data Control Language指用于设置用户权限和控制事务语句如grant，revoke，if…else，while，begin transactionDQL （数据查询语言）（★★★★★）数据查询语言 – Data Query Language数据表记录的查询。select 2.JDBCTemplate使用：API介绍： 1.org.springframework.jdbc.core.JdbcTemplate类方便执行SQL语句 123456789101112131415161718192021222324252627282930313233public JdbcTemplate(DataSource dataSource)创建JdbcTemplate对象，方便执行SQL语句public void execute(final String sql)execute可以执行所有SQL语句，因为没有返回值，一般用于执行DML语句。public int update(final String sql)用于执行`INSERT`、`UPDATE`、`DELETE`等DML语句。public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args): 传入参数, 执行查询语句，返回一个指定类型的数据。 public Map&lt;String, Object&gt; queryForMap(String sql, Object... args)传入参数，执行查询语句，将一条记录放到一个Map中。public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args)传入参数，执行查询语句，返回一个List集合，List中存放的是Map类型的数据。public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper)执行查询语句，返回一个List集合，List中存放的是RowMapper指定类型的数据。public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper)执行查询语句，返回一个List集合，List中存放的是RowMapper指定类型的数据。public class BeanPropertyRowMapper&lt;T&gt; implements RowMapper&lt;T&gt;BeanPropertyRowMapper类实现了RowMapper接口 1.数据准备： 这里采用c3p0数据流连接池，集成到JDBCUtils 工具类中,需要将c3p0的配置文件放入到src目录下 导入依赖的jar包 2.创建JdbcTemplate对象，传入c3p0连接池 3.调用 execute、update、queryXxx等方法 c3p0-config.xml 配置文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置，c3p0框架默认加载这段默认配置 --&gt; &lt;default-config&gt; &lt;!-- 配置JDBC 四个基本属性 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb4?&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 可以自定义配置，为这段配置起一个名字，c3p0指定名称加载配置 --&gt; &lt;named-config name=\"zidingyimingzi\"&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb4?&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; JDBCUtils 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class JDBCUtils &#123; // 核心连接池类 private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static DataSource getDataSource() &#123; return dataSource; &#125; // 获取连接 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 测试类（实现增改） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class JDBCTemplateExecute &#123; public static void main(String[] args) &#123; // 查询语句 // 1. 创建表的SQL语句 String sql = \"create table product (\" + \"pid int primary key auto_increment,\" + \"pname varchar(20),\" + \"price double\" + \");\"; // 2. 创建 jdbcTemplate 对象, 并将数据库连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 3. 使用 jdbcTemplate 对象调用 execute 方法, 执行 sql 语句, 创建数据库表. jdbcTemplate.execute(sql); // 增加数据 // 2. 编写 sql 语句 String sql = \"insert into product values(null, ?, ?);\"; // 3. 执行 update 方法. jdbcTemplate.update(sql, \"iPhone3GS\", 3333); jdbcTemplate.update(sql, \"iPhone4\", 5000); // 修改数据 // 2. 执行 update 语句 String sql = \"update product set pname = ?, price = ? where pid = ?;\"; int count = jdbcTemplate.update(sql, \"XVIII\", 18888, 10); System.out.println(\"count = \" + count); // 删除数据 // 2. 执行 delete 操作 String sql = \"delete from product where pid = ?;\"; int count = jdbcTemplate.update(sql, 7); System.out.println(\"count = \" + count); &#125;&#125; 总结：JdbcTemplate的update方法用于执行DML语句。同时还可以在SQL语句中使用？占位，在update方法的Object… args可变参数中传入对应的参数。 测试类（实现查询） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 @Test public void test1() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // queryForObject 方法 // 2. 执行 queryForObject 方法 String sql = \"select pname from product where price = 7777\"; String pname = jdbcTemplate.queryForObject(sql, String.class); System.out.println(\"pname = \" + pname); // queryForMap 方法 // 2. 执行 queryForMap 方法 String sql = \"select * from product where pid = ?;\"; Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 6); System.out.println(\"map = \" + map); // objectForList // 2. 执行 objectForList 方法 String sql = \"select * from product where pid &lt; ?;\"; List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql, 8); for (Map&lt;String, Object&gt; map : list) &#123; System.out.println(map); &#125; // 使用RowMapper做映射返回对象 1. 定义Product类2. 创建JdbcTemplate对象3. 编写查询的SQL语句4. 使用JdbcTemplate对象的query方法，并传入RowMapper匿名内部类5. 在匿名内部类中将结果集中的一行记录转成一个Product对象 // 2. 执行 query 方法 String sql = \"select * from product;\"; List&lt;Product&gt; list = jdbcTemplate.query(sql, new RowMapper&lt;Product&gt;() &#123; @Override public Product mapRow(ResultSet rs, int i) throws SQLException &#123; Product product = new Product(); int pid = rs.getInt(\"pid\"); String pname = rs.getString(\"pname\"); double price = rs.getDouble(\"price\"); product.setPid(pid); product.setPname(pname); product.setPrice(price); return product; &#125; &#125;); // 遍历 list 集合 for (Product product : list) &#123; System.out.println(product); &#125;1. 定义Product类2. 创建JdbcTemplate对象3. 编写查询的SQL语句4. 使用JdbcTemplate对象的query方法，并传入BeanPropertyRowMapper对象 // 2. 执行 query 方法 String sql = \"select * from product;\"; List&lt;Product&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Product.class)); // 3. 遍历 list 集合 for (Product product : list) &#123; System.out.println(product); &#125; &#125; 总结： JDBCTemplate的query方法用于执行SQL语句，简化JDBC的代码。同时还可以在SQL语句中使用？占位，在query方法的Object... args可变参数中传入对应的参数。 三、c3p01234567891011121314151617181920212223242526272829303132在Hibernate和Spring 都提供对C3P0连接池支持.导入2个包基本操作 // 核心连接池类 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); // 设置四个JDBC基本连接属性 comboPooledDataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); comboPooledDataSource.setJdbcUrl(\"jdbc:mysql:///mydb4?\"); comboPooledDataSource.setUser(\"root\"); comboPooledDataSource.setPassword(\"111\");常用基本连接池属性acquireIncrement 如果连接池中连接都被使用了，一次性增长3个新的连接initialPoolSize 连接池中初始化连接数量默认:3maxPoolSize 最大连接池中连接数量默认：15连接maxIdleTime 如果连接长时间没有时间，将被回收默认：0 连接永不过期 minPoolSize 连接池中最小连接数量 默认：3 通过c3p0创建数据库连接池对象方式提取到JDBCUtils中 12345678910111213141516171819202122232425262728293031323334353637383940414243public class JDBCUtils &#123; // c3p0 数据库连接池对象属性 // 这里会自动读取 位于src目录下的c3p0-config.xml 数据库连接池配置文件 private static final ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 获取连接 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; c3p0-config.xml 数据库连接池配置文件 位于src 目录下 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置，c3p0框架默认加载这段默认配置 --&gt; &lt;default-config&gt; &lt;!-- 配置JDBC 四个基本属性 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb4&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 可以自定义配置，为这段配置起一个名字，c3p0指定名称加载配置 --&gt; &lt;named-config name=\"zidingyi\"&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb4&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 测试类： @Test public void test_jdbcUtils() { // 需求 : 查询 user 表中的所有数据 Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try { // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = &quot;select * from user;&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) { int id = rs.getInt(&quot;id&quot;); String username = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); String email = rs.getString(&quot;email&quot;); System.out.println(id + &quot; : &quot; + username + &quot; : &quot; + password + &quot; : &quot; + email); } } catch (SQLException e) { e.printStackTrace(); } finally { // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); } } 四、druidDruid (德鲁伊) 是阿里巴巴开发的号称为监控而生的数据库连接池，Druid是目前最好的数据库连接池。在功能、性能、扩展性方面，都超过其他数据库连接池，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况。Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。Druid地址：https://github.com/alibaba/druid DRUID连接池使用的jar包： 参数 说明 url 连接数据库的url：jdbc:mysql://localhost:3306/mydb username 数据库的用户名 password 数据库的密码 driverClassName 驱动类名。根据url自动识别，这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 最大连接池数量 maxIdle 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。 API介绍 com.alibaba.druid.pool.DruidDataSourceFactory类有创建连接池的方法 12public static DataSource createDataSource(Properties properties)创建一个连接池，连接池的参数使用properties中的数据 tips：我们可以看到DRUID连接池在创建的时候需要一个Properties对象来设置参数，所以我们使用properties文件来保存对应的参数。 DRUID连接池的配置文件名称随便，因为该配置文件需要我们手动实现加载。 druid.properties文件内容： 123456789driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/mydbusername=rootpassword=111initialSize=5maxActive=10maxWait=3000maxIdle=6minIdle=3 1.使用步骤:\\1. 在src目录下创建一个properties文件，并设置对应参数 \\2. 加载properties文件的内容到Properties对象中 \\3. 创建DRUID连接池，使用配置文件中的参数 \\4. 从DRUID连接池中取出连接 \\5. 执行SQL语句 \\6. 关闭资源 JDBCUtils 工具类集成 Druid 数据库连接池 public class JDBCUtils { 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 属性private static final DataSource dataSource;static &#123; Properties prop = new Properties(); try &#123; // 加载配置文件 // 配置文件的位置无所谓，这里放的是项目的目录下，因为Druid数据库连接池需要手动加载配置文件 prop.load(new FileReader(\"druid.properties\")); // 创建数据库连接池 dataSource = DruidDataSourceFactory.createDataSource(prop); &#125; catch (Exception e) &#123; throw new RuntimeException(\"连接池初始化失败!\"); &#125;&#125;public static DataSource getDataSource() &#123; return dataSource;&#125;// 建立连接public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection();&#125;// 释放资源public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt);&#125;public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // e.printStackTrace(); ignore 忽略. &#125; conn = null; // 目的: 让 conn 对象尽早被回收. &#125;&#125;&#125; 测试类 1234567891011121314151617181920212223242526272829 @Test public void test3() &#123; Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"select * from user;\"; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"18JavaSEJDBC_事务&JDBCTemplate","slug":"18JavaSEJDBC-事务-JDBCTemplate","date":"2017-02-15T13:39:10.000Z","updated":"2018-08-27T02:23:20.494Z","comments":true,"path":"2017/02/15/18JavaSEJDBC-事务-JDBCTemplate/","link":"","permalink":"htts://cocked.github.io/2017/02/15/18JavaSEJDBC-事务-JDBCTemplate/","excerpt":"","text":"一、JDBC_事务通过JDBC来操作银行转账的事务 1.API介绍Connection接口中与事务有关的方法 123456void setAutoCommit(boolean autoCommit) throws SQLException;false：开启事务， ture：关闭事务void commit() throws SQLException;提交事务void rollback() throws SQLException;回滚事务 案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class JDBCTransactionTest &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement stmt = null; try &#123; // 1. 获取连接对象 conn = JDBCUtils.getConnection(); // 第一步 : 开启事务 conn.setAutoCommit(false); // 2. 操作数据 // 2.1 账户转出 String outSql = \"update account set money = money - ? where name = ?;\"; stmt = conn.prepareStatement(outSql); stmt.setInt(1, 1000); stmt.setString(2, \"tom\"); stmt.executeUpdate(); // 模拟异常 ... // int num = 10 / 0; // 2.2 账户转入 String inSql = \"update account set money = money + ? where name = ?;\"; stmt = conn.prepareStatement(inSql); stmt.setInt(1, 1000); stmt.setString(2, \"jery\"); stmt.executeUpdate(); // 第二步 : 提交事务 conn.commit(); System.out.println(\"转账成功!\"); &#125; catch (Exception e) &#123; // 如果出现异常, 需要进行事务回滚. // 第三步 : 回滚事务 try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; System.out.println(\"转账失败!\"); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125;&#125; 二、jdbcTemplate1.API介绍org.springframework.jdbc.core.JdbcTemplate类方便执行SQL语句 1234public JdbcTemplate(DataSource dataSource)创建JdbcTemplate对象，方便执行SQL语句public void execute(final String sql)execute可以执行所有SQL语句，因为没有返回值，一般用于执行DML语句。 2.使用步骤1. 准备DruidDataSource连接池 \\2. 导入依赖的jar包 spring-beans spring-core spring-jdbc spring-tx com.springsource.org.apache.commons.logging.jar \\3. 创建JdbcTemplate对象，传入c3p0连接池 \\4. 调用execute、update、queryXxx等方法 3.案例（1）c3p0-config.xml配置文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置，c3p0框架默认加载这段默认配置 --&gt; &lt;default-config&gt; &lt;!-- 配置JDBC 四个基本属性 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb?&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 可以自定义配置，为这段配置起一个名字，c3p0指定名称加载配置 --&gt; &lt;named-config name=\"xxxxx\"&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/mydb?&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;111&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; (2)JDBCUtils工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class JDBCUtils &#123; // 核心连接池类 private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static DataSource getDataSource() &#123; return dataSource; &#125; // 获取连接 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; jdbcTemplate的exeucte方法 1234567891011121314151617public class JDBCTemplateExecute &#123; public static void main(String[] args) &#123; // 1. 创建表的SQL语句 String sql = \"create table product (\" + \"pid int primary key auto_increment,\" + \"pname varchar(20),\" + \"price double\" + \");\"; // 2. 创建 jdbcTemplate 对象, 并将数据库连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 3. 使用 jdbcTemplate 对象调用 execute 方法, 执行 sql 语句, 创建数据库表. jdbcTemplate.execute(sql); &#125;&#125; 4通过jdbcTemplate实现增删改API介绍 123// org.springframework.jdbc.core.JdbcTemplate类方便执行SQL语句public int update(final String sql)用于执行`INSERT`、`UPDATE`、`DELETE`等DML语句 使用步骤： 1.创建JdbcTemplate对象 2.编写SQL语句 3.使用JdbcTemplate对象的update方法进行增删改 1.insert 增加数据 :123456789101112131415161718192021@Test public void insert() &#123; // 1. 创建一个 JdbcTemplate 对象, 并将连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 编写 sql 语句 String sql = \"insert into product values(null, ?, ?);\"; // 3. 执行 update 方法. jdbcTemplate.update(sql, \"iPhone3GS\", 3333); jdbcTemplate.update(sql, \"iPhone4\", 5000); jdbcTemplate.update(sql, \"iPhone4S\", 5001); jdbcTemplate.update(sql, \"iPhone5\", 5555); jdbcTemplate.update(sql, \"iPhone5C\", 3888); jdbcTemplate.update(sql, \"iPhone5S\", 5666); jdbcTemplate.update(sql, \"iPhone6\", 6666); jdbcTemplate.update(sql, \"iPhone6S\", 7000); jdbcTemplate.update(sql, \"iPhone6SP\", 7777); jdbcTemplate.update(sql, \"iPhoneX\", 8888); &#125; 2.update 修改数据 :1234567891011@Test public void update() &#123; // 1. 创建一个 JdbcTemplate 对象, 并将数据库连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 update 语句 String sql = &quot;update product set pname = ?, price = ? where pid = ?;&quot;; int count = jdbcTemplate.update(sql, &quot;XVIII&quot;, 18888, 10); System.out.println(&quot;count = &quot; + count); &#125; 3.delete 删除数据 :12345678910@Testpublic void delete() &#123; // 1. 创建一个 JdbcTemplate 对象, 并将数据库连接池作为参数传入 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 delete 操作 String sql = \"delete from product where pid = ?;\"; int count = jdbcTemplate.update(sql, 7); System.out.println(\"count = \" + count);&#125; 小结：JdbcTemplate的update方法用于执行DML语句。同时还可以在SQL语句中使用？占位，在update方法的Object… args可变参数中传入对应的参数。 5 jdbcTemplate实现查询API介绍 queryForObject返回一个指定类型 12345678910111213141516171819// 单行单列的查询public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args): 传入参数, 执行查询语句，返回一个指定类型的数据。// 单行多列public Map&lt;String, Object&gt; queryForMap(String sql, Object... args)传入参数，执行查询语句，将一条记录放到一个Map中。// 多行多列public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args)传入参数，执行查询语句，返回一个List集合，List中存放的是Map类型的数据。// 返回一个List 存放对象数据public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper)执行查询语句，返回一个List集合，List中存放的是RowMapper指定类型的数据。// 提供了一个上述方法的一个实现类 RowMapper 行映射接口 BeanPropertyRowMapper 实体类属性行映射public class BeanPropertyRowMapper&lt;T&gt; implements RowMapper&lt;T&gt;BeanPropertyRowMapper类实现了RowMapper接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@Testpublic void test1() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 queryForObject 方法 String sql = \"select pname from product where price = 7777\"; String pname = jdbcTemplate.queryForObject(sql, String.class); System.out.println(\"pname = \" + pname);&#125;@Testpublic void test2() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 queryForMap 方法 String sql = \"select * from product where pid = ?;\"; Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 6); System.out.println(\"map = \" + map);&#125;@Testpublic void test3() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 objectForList 方法 String sql = \"select * from product where pid &lt; ?;\"; List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql, 8); for (Map&lt;String, Object&gt; map : list) &#123; System.out.println(map); &#125;&#125;@Testpublic void test4() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 query 方法 String sql = \"select * from product;\"; List&lt;Product&gt; list = jdbcTemplate.query(sql, new RowMapper&lt;Product&gt;() &#123; @Override public Product mapRow(ResultSet rs, int i) throws SQLException &#123; Product product = new Product(); int pid = rs.getInt(\"pid\"); String pname = rs.getString(\"pname\"); double price = rs.getDouble(\"price\"); product.setPid(pid); product.setPname(pname); product.setPrice(price); return product; &#125; &#125;); // 遍历 list 集合 for (Product product : list) &#123; System.out.println(product); &#125;&#125;@Testpublic void test5() &#123; // 1. 创建一个 JdbcTemplate 对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource()); // 2. 执行 query 方法 String sql = \"select * from product;\"; List&lt;Product&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Product.class)); // 3. 遍历 list 集合 for (Product product : list) &#123; System.out.println(product); &#125;&#125; 三、小结：JDBCTemplate的query方法用于执行SQL语句，简化JDBC的代码。同时还可以在SQL语句中使用？占位，在query方法的Object... args可变参数中传入对应的参数。","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"17JavaSE数据库连接池","slug":"17JavaSE数据库连接池","date":"2017-02-12T04:20:52.000Z","updated":"2018-08-27T02:23:15.174Z","comments":true,"path":"2017/02/12/17JavaSE数据库连接池/","link":"","permalink":"htts://cocked.github.io/2017/02/12/17JavaSE数据库连接池/","excerpt":"","text":"一、c3p0连接池1.导包(lib 下)数据库连接池 c3p0 machange-commons-java MySQL驱动 mysql-connector-java 2.核心方法12345678910111213// 核心连接池类 ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); // 设置四个JDBC基本连接属性 comboPooledDataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); comboPooledDataSource.setJdbcUrl(\"jdbc:mysql:///test\"); comboPooledDataSource.setUser(\"root\"); comboPooledDataSource.setPassword(\"111\"); 3.jdbc.properties配置文件1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mysqlusername=rootpassword=111 4.JDBCUtils工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.io.FileReader;import java.io.IOException;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static final String driverClass; private static final String url; private static final String username; private static final String password; static &#123; Properties prop = new Properties(); try &#123; prop.load(new FileReader(\"jdbc.properties\")); driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); // 加载驱动 loadDriver(); &#125; catch (IOException e) &#123; // e.printStackTrace(); throw new RuntimeException(\"配置文件加载失败!\"); &#125; &#125; // 加载驱动 public static void loadDriver() &#123; try &#123; Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; // e.printStackTrace(); throw new RuntimeException(\"驱动加载失败!\"); &#125; &#125; // 获取连接 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, username, password); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 5.测试123456789101112131415161718192021222324252627282930313233343536373839404142// 测试类public class JDBCTemplateTest1 &#123; @Test public void test1() throws SQLException, PropertyVetoException &#123; // 需求 : 查询 user 表中的所有数据 // 核心连接池类 ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 设置四个JDBC基本连接属性 dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydb?serverTimezone=UTC&amp;characterEncoding=utf-8\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"111\"); Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = dataSource.getConnection(); // 2. 操作数据 String sql = \"select * from user;\"; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125; &#125;&#125; 6.通过xml 获取配置信息ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); 会自定加载配置文件 #常用基本连接池属性 acquireIncrement 如果连接池中连接都被使用了，一次性增长3个新的连接 maxPoolSize 最大连接池中连接数量默认：15连接 maxIdleTime 如果连接长时间没有时间，将被回收默认：0 连接永不过期 minPoolSize 连接池中最小连接数量 默认：3 initialPoolSize 连接池中初始化连接数量默认:3 1234567891011121314151617181920212223242526272829303132@Testpublic void test_c3p0() throws PropertyVetoException &#123; // 需求 : 查询 user 表中的所有数据 // 核心连接池类 ComboPooledDataSource dataSource = new ComboPooledDataSource(); Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = dataSource.getConnection(); // 2. 操作数据 String sql = \"select * from user;\"; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125;&#125; 7.优化JDBCUtils12345678910111213141516171819202122232425262728293031323334353637383940414243优化版的JDBCUtils 中的getConnectio 使用数据库连接池对象方式实现 public class JDBCUtils &#123; // c3p0 数据库连接池对象属性 private static final ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 获取连接 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 测试 123456789101112131415161718192021222324252627282930@Testpublic void test_jdbcUtils() &#123; // 需求 : 查询 user 表中的所有数据 Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"select * from user;\"; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"03MySQL3","slug":"03MySQL3","date":"2017-02-01T06:11:08.000Z","updated":"2018-08-27T02:34:16.154Z","comments":true,"path":"2017/02/01/03MySQL3/","link":"","permalink":"htts://cocked.github.io/2017/02/01/03MySQL3/","excerpt":"","text":"一、内外连接全连接，左右连接 通过两张表查找其对应的记录. 隐式 内连接 select * from a,b where a.列名 = b.列名 #左连接select * from a left outer join b on a.id = b.id #右连接select * from a right outer join b on a.id = b.id #全连接可以使用union来达到全外连接的查询效果。 union ：可以将左外连接查询和右外连接查询两条sql语句使用union合并起来进行查询，去掉重复的数据。 select * from a left outer join b on a.id = b.id union select * from a right outer join b on a.id = b.id 小结内连接：1、 隐式内连接：Select from a,b where a.id = b.id;结果：C2、 显示内连接：Select from a inner join b on a.id = b.id;结果：C 外连接：1、 左外连接select from a left outer join b on a.id = b.id结果：A+C2、 右外连接select from a right outer join b on a.id = b.id结果：B+C3、 union:相当于全外连接select from a left outer join b on a.id = b.idunionselect from a right outer join b on a.id = b.id 结果：A+B+C,会自动虑重 select from a left outer join b on a.id = b.idunion allselect from a right outer join b on a.id = b.id结果：A+B+C,有重复数据","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"htts://cocked.github.io/tags/mysql/"}]},{"title":"01MySQL1","slug":"01MySQL1","date":"2017-01-18T10:21:43.000Z","updated":"2018-08-27T02:35:05.623Z","comments":true,"path":"2017/01/18/01MySQL1/","link":"","permalink":"htts://cocked.github.io/2017/01/18/01MySQL1/","excerpt":"","text":"一、数据库的基本概念1.1 常用的关系型数据库123数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。 1.2 sql语言SQL是Structured Query Language(结构化查询语言)的缩写。SQL是专为数据库而建立的操作命令集。SQL功能强大、简单易学、使用方便，已经成为了数据库操作的基础，并且现在几乎所有的关系型数据库均支持SQL。 特点：1非过程性语言。一条语句一个结果。多条语句之间没有影响。每一条SQL执行完都会有一个具体的结果出现。 SQL是用来操作关系数据库的语言，具有查询、操纵、定义和控制关系型数据库的四方面功能 11.3 sql分类 DDL （数据定义语言）数据定义语言 - Data Definition Language用来定义数据库的对象，如数据表、视图、索引等create drop alter truncate DML （数据操纵语言）数据处理语言 - Data Manipulation Language在数据库表中更新，增加和删除记录如 update， insert， delete 不包含查询 DCL （数据控制语言）数据控制语言 – Data Control Language指用于设置用户权限和控制事务语句如grant，revoke，if…else，while，begin transaction DQL （数据查询语言）（★★★★★）数据查询语言 – Data Query Language数据表记录的查询。select 二、对数据库进行操作的语句1.1 数据库中默认自带有4个库：123 1.information_schema 数据库：其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据的表，表栏的数据类型与访问权限等。 2.performance_schema 数据库： 存储引擎：命名PERFORMANCE_SCHEMA，主要用于手机数据库服务器性能参数。 1233.mysql 数据库：mysql库是系统库，里面保存有账户信息，权限信息，存储过程，event,时区等信息4.test 数据库: 这个是安装时候创建的一个测试数据库，和它的名字一样，是一个完全的空数据库，没有任何表，可以删除。 1.2 查看所有数据库1.1 查询当前所有的数据库show databases；1.2 查看当前数据的创建方式：查看数据库的编码表show create database 库名；1.3 创建数据库create database 数据库名： 由于创建数据库时没有指定编码表，因此会使用安装数据库时默认的编码表create database 数据库名 character set 编码表名；创建数据库会使用指定的编码表1.4 删除数据库drop database 数据库名；1.5 修改数据库编码集alter database 数据库名称 character set 字符集； 1.3 数据表结构的sql语句 121.1 数据表的创建语句create table 表名( 列名 数据类型， 列名 数据类型， …… 列名 数据类型 (最后一个列不需要逗号) 1)； 1.2 查看表 1234show tables : 查看该数据库的所有的表 show create table 表名 ：查看建表语句以及字符集 desc emp 查看表的详细信息 show columns from emp ；查看表的列信息 1.4 约束 123451.1 主键约束 primary key varchar 类型的主键不可以自增长. 示例： 【示例】 create table 表名 ( id int primary key auto_increment, name varchar(20), ………….)； 121.2 唯一约束 unique 内容不允许重复，可以为null（null不算重复）。 一个表里可以添加多个唯一约束。【示例】create table 表名 ( id int primary key auto_increment, name varchar(20) unique, ………….)；唯一约束和主键约束的区别1、唯一约束可以是空(null)。 但是主键约束不能为空2、一张表中只能有一个主键，但是唯一约束可以有多个 12 1.3 非空约束not null 不允许为空 表示该列的内容 不允许为空。 约束的目的。目的：保证数据的正确性。约束列。限制列的内容。1.5 数据表结构的修改 1234561.修改数据表 可以对表名、表中的列名、列的类型、列的约束进行增删改 语法 ：alter table 表名 add/drop/modify 改名 类型长度 约束； 2. 修改现有列的类型，长度和约束 用modify3. 修改现有列名称 语法 alter table 表名 change 旧列名 新列名 类型（长度） 约束； · 4. 删除现有列 12345 语法 alter table 表名 drop 列名；5. 修改表名 语法 ：rename table 旧表名 to 新表名6. 修改表的字符集 语法 ： alter table 表名 character set 编码集； 1.6 数据表的删除 1语法 ： drop table 表名： 三、数据记录的增删改1在java代码中对数据库操作最频繁的就是对表中数据的CRUD操作：create read / retrive update delete 数据记录存储位置​ 12345增： 语法：insert into 表名 （列名，列名，列名。。。） values（ 值，值，值。。。）；改：update 表名 set 列名 = 值 ， 列名 = 值 .. . [where 条件语句]； notes：如果不加条件 则修改整列删：delete ：delete from 表名 [where 条件语句] notes：如果没有where 删除表中所有的记录 delete 删除的是行 truncate table 表名 是删除一个表，之后在根据你 的表结构在给你创建一张新表","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"htts://cocked.github.io/tags/mysql/"}]},{"title":"02MySQL2","slug":"02MySQL2","date":"2017-01-10T09:10:23.000Z","updated":"2018-08-27T02:34:44.792Z","comments":true,"path":"2017/01/10/02MySQL2/","link":"","permalink":"htts://cocked.github.io/2017/01/10/02MySQL2/","excerpt":"","text":"一、数据库的查询用法1、 数据表记录的查询: 运算符、虑重、列运算、别名、排序、聚合函数、分组 1.1数据准备 create table exam( id int primary key auto_increment, name varchar(20) not null, chinese double, math double, english double ); insert into exam values(null,’关羽’,85,76,60); insert into exam values(null,’张飞’,70,75,70); insert into exam values(null,’赵云’,90,65,95); insert into exam values(null,’刘备’,97,50,50); insert into exam values(null,’曹操’,90,89,80); insert into exam values(null,’司马懿’,90,67,65); insert into exam values（null，’刘阿斗’）； 1.2 数据查询 文件结构： 名字： 语法： █▓ 查询所有信息 select * from 表名 █▓ 查询指定列的信息 select 列名，列名... from 表名； █▓ 条件查询 select * from表名 where 条件 █▓ 运算符 比较运算符 &gt; &lt;&lt;= &gt;= =&lt;&gt; 大于、小于、大于/小于等于、不等于 between 1 and 10 显示某一区间的值:1—10之间 in(1,2,3) 显示在in列表中的值：1、2、3任意一个 Like ‘张_’Like ‘张%’ 模糊查询：%表示零或任意多个字符，表示一个字符.例子1：张三丰 like ‘张%’例子2：张三 like ‘张’ is null、is not null 是否为空 逻辑运算符 and&amp;&amp; 多个条件同时成立 or\\ \\ 多个条件任意一个成立 not! 不成立，例如：where not(age&gt;18) █▓ 虑重 查询排重：select distinct 列名 from 表名 where 条件； █▓ 别名以及列运算 select 列名 as 别名， 列名 as 别名 ... from 表名 where 条件； █▓ order by 排序 select * from 表名 order by 列名 asc desc； █▓ 关于null 问题 通过 ifnull（values，default）解决 █▓ SQL中聚合 / 聚集函数 聚集函数：多个数据进行运算，运算出一个结果。例如，求和，平均值，最大值，最小值。 语法：select avg(列名) from 表名；都是位于 select 后 █▓ █▓ █▓ group by 分组查询 select ... from ... group by 列名； █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ 重点总结 select 语句执行顺序 █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ █▓ select …要显示的内容.. from …表名.. where 条件…. group by …分组的列 …having …分组后的条件… order by …排序 select …4… from …1.. where …2.. group by ..3…having ..5… order by …6. 二、数据备份和恢复1.备份语法：mysqldump -u **用户名 -p 数据库名 &gt; 磁盘SQL**文件路径 2.恢复恢复方式1： 1.创建数据库 备份的时候，没有备份创建数据库的语句，当需要恢复某个具体数据的时候需要手动创建 1. 导入数据 source D://mydb.sql 恢复方式2： 1.创建数据库 2.语法：mysql -u 用户名 -p 导入库名 &lt; 硬盘SQL文件绝对路径 三、外键约束 添加外键需要注意的问题 l 如果从表要去添加一个外键约束。要求主表被引用的字段是主键或者唯一的。通常使用主键。 l 如果要删除主表中的数据。要求在从表中这个数据，要没有被引用，才可以去删除。 l 如果要向从表中去添加数据。要求在主表中，要有对应的数据。才可以去添加。 l 如果要删除表。要先删除从表。然后去删除主表。 l 新建表的时候。需要先去创建主表，然后去创建从表。 作用：保持数据的完整性，和有效性。 1.添加外键约束的语法创建表之后添加外键 █▓ █▓ alter table 从表名称 add foreign key （外键列的名称）references 主表名称（主键） 创建表的时候添加外键 /*创建部门表*/ create table dept( id int primary key auto_increment, name varchar(20) ); /创建员工表/ create table employee( id int primary key auto_increment, name varchar(20), age int , salary double, dept_id int, foreign key (dept_id) references dept(id) ); #总结：1.库的操作创建库：create database 库名 character set 编码表; 删除库：drop database 库名; 查询库：show databases; 查看库的编码表：show create database 库名; 更改库：use 库名; 查看当前正在使用的库：select database(); 修改库的编码表：alter database 库名 character set 编码表; 2.表本身的操作创建表：create table 表名( 列名 列的类型(长度) 类的约束 ,列名 列的类型(长度) 类的约束…… ); 删除表：drop table 表名; 查询表：show tables; 查看表的结构：desc 表名; 查看表的编码表：show create table 表名; 修改表：alter table 表名 增/删/改 列名 列的类型(长度) 约束; add/drop/change/modify 修改表名：rename table 旧表名 to 新表名； 3.表中数据的操作增：insert into 表名(列名) values(值); 删：delete from 表名 where 条件; truncate 改：update 表名 set 列名=值 ，列名=值 where 条件 ； 查：select 列名 as 别名 ,列名 as 别名… from 表名 where 条件 group by 列名 having 条件 order by 排序. 查询排重：select distinct 列名 from 表名 where 条件; 4.聚合函数：count 统计个数、sum求和、avg 平均值、max、min 在使用这几个函数进行数据的统计分析时，有时需要对数据表中的列进行数据的分组处理。group by 分组 group by : 排序：order by 列名 asc | desc；","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"htts://cocked.github.io/tags/mysql/"}]},{"title":"16JavaSEJDBC初体验","slug":"16JavaSEJDBC初体验","date":"2016-12-26T02:32:29.000Z","updated":"2018-08-27T02:23:09.962Z","comments":true,"path":"2016/12/26/16JavaSEJDBC初体验/","link":"","permalink":"htts://cocked.github.io/2016/12/26/16JavaSEJDBC初体验/","excerpt":"","text":"一、JDBC常用类和接口JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API。JDBC是Java访问数据库的标准规范，可以为不同的关系型数据库提供统一访问，它由一组用Java语言编写的接口和类组成。 JDBC**与数据库驱动的关系：接口与实现类的关系。** 二、JDBC常用类和接口JDBC有关的类：都在java.sql 和 javax.sql 包下. 接口在Java中是用来定义 行为规范的. 接口必须有实现类. JDBC规范（四个核心对象）： DriverManager:用于注册驱动 Connection: 表示与数据库创建的连接 Statement: 操作数据库sql语句的对象 ResultSet: 结果集或一张虚拟表 特别注意： Mysql驱动的driverClass 和url 的写法 com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/text 1.JDBC 初体验1234567891011121314151617181920212223// JDBC 初体验 @Testpublic void demo01() throws SQLException &#123; // 1. 装载驱动 DriverManager.registerDriver(new Driver()); // 2. 建立连接 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"111\"); // 3. 操作数据 String sql = \"select * from user;\"; Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql); while (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String password = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + username + \" : \" + password + \" : \" + email); &#125; // 4. 释放资源 rs.close(); stmt.close(); conn.close();&#125; 2.JDBC工具类的提取（）方式一、 –src下放连接数据库的配置文件 |--properties 1234567 // 配置文件的名字 jdbc.properties#mysqldriverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mydbuser=rootpassword=111 –util包 |--JDBCUtils 类 | 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class JDBCUtils &#123; // 属性 private static String driverClass; private static String url; private static String username; private static String password; // 什么时候加载外部配置文件最合适 ??? // 特点1 : 随着类的加载而加载. // 特点2 : 静态代码块只在类加载的被执行一次. 仅一次. static &#123; Properties prop = new Properties(); try &#123; prop.load(new FileReader(\"jdbc.properties\")); // 如果程序执行到这里, 说明外部资源文件加载成功, 需要给我们的静态属性赋值 driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); // 直接执行加载驱动 loadDriver(); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(\"文件资源加载失败!\"); &#125; &#125; // 加载驱动 public static void loadDriver() &#123; try &#123; // 1. 加载驱动 Class.forName(driverClass); &#125; catch (ClassNotFoundException e) &#123; // e.printStackTrace(); // 驱动加载失败! throw new RuntimeException(\"驱动加载失败!\"); &#125; &#125; // 建立连接 public static Connection getConnection() throws SQLException &#123; // 2. 建立连接 return DriverManager.getConnection(url, username, password); &#125; // 释放资源 public static void release(Connection conn, Statement stmt, ResultSet rs) &#123; // 4. 释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; // 将 rs 清空 rs = null; &#125; // 直接调用 release(conn, stmt); &#125; public static void release(Connection conn, Statement stmt) &#123; // 4. 释放资源 if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125;&#125; 3.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 @Test public void test_update() &#123; Connection conn = null; Statement stmt = null; try &#123; // 2. 建立连接 conn = JDBCUtils.getConnection(); // 3. 操作数据 String sql = \"update user set username = 'zhaoliu', password = '123', email = 'zhaoliu@youjian.cn' where id = 4;\"; stmt = conn.createStatement(); int affectedRowNum = stmt.executeUpdate(sql); System.out.println(affectedRowNum); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125; @Test public void test_delete() &#123; Connection conn = null; Statement stmt = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"delete from user where id = 5;\"; stmt = conn.createStatement(); int affectedRowNum = stmt.executeUpdate(sql); System.out.println(affectedRowNum); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125; @Test public void test_insert() &#123; Connection conn = null; Statement stmt = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"insert into user values(null, 'xiaoqi', '123', 'xiaoqi@youjian.cn');\"; stmt = conn.createStatement(); int affectedRowNumber = stmt.executeUpdate(sql); System.out.println(affectedRowNumber); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4. 释放资源 JDBCUtils.release(conn, stmt); &#125; &#125;// 以上使用时 在进行查询的操作时 有可能会出现 sql注入问题// 解决SQL注入：使用PreparedStatement 取代 Statement // PreparedStatement 解决SQL注入原理，运行在SQL中参数以?占位符的方式表示// select * from user where username = ? and password = ? ;// 将带有?的SQL 发送给数据库完成编译 （不能执行的SQL 带有?的SQL 进行编译 叫做预编译），在SQL编译后发现缺少两个参数// PreparedStatement 可以将? 代替参数 发送给数据库服务器，因为SQL已经编译过，参数中特殊字符不会当做特殊字符编译，无法达到SQL注入的目的 /************ JDBC 数据库连接操作 ***************/ Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try &#123; // 1. 建立连接 conn = JDBCUtils.getConnection(); // 2. 操作数据 String sql = \"select * from user where username = ? and password = ?;\"; stmt = conn.prepareStatement(sql); // 设置sql语句的参数 stmt.setString(1, username); stmt.setString(2, password); // 执行sql语句 rs = stmt.executeQuery(); // 判断返回的结果 if (rs.next()) &#123; // 登录成功 int id = rs.getInt(\"id\"); String u_name = rs.getString(\"username\"); String u_pwd = rs.getString(\"password\"); String email = rs.getString(\"email\"); System.out.println(id + \" : \" + u_name + \" : \" + u_pwd + \" : \" + email); System.out.println(\"登录成功!\"); &#125; else &#123; // 登录失败 System.out.println(\"登录失败! 用户名或密码错误!\"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 释放资源 JDBCUtils.release(conn, stmt, rs); &#125; &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"15JavaSE动态代理、XML、正则","slug":"15JavaSE动态代理、XML、正则","date":"2016-12-12T15:31:58.000Z","updated":"2018-08-27T02:23:05.194Z","comments":true,"path":"2016/12/12/15JavaSE动态代理、XML、正则/","link":"","permalink":"htts://cocked.github.io/2016/12/12/15JavaSE动态代理、XML、正则/","excerpt":"","text":"15.1 动态代理学习Spring框架时，Spring框架有一大核心思想，就是AOP，(Aspact-Oriented-Programming 面向切面编程) 而AOP的原理就是Java的动态代理机制，在Java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的 15.1.1 动态代理的基础动态代理的基础 : 必须有接口Java中使用接口来定义统一的行为规范 : 接口. 接口必须有实现类：interface SuperStar 超级明星行为规范 :void sing(int money);void liveShow(int moeny);void sleep();​// 接口必须有实现类 : L implements SuperStar B implements SuperStarProxy 代理类 : Class Proxy 代理类 是在运行时创建的实现指定的接口列表（称为代理接口）的类 。 代理实例是代理类的一个实例。 每个代理实例都有一个关联的调用处理程序对象，它实现接口InvocationHandler 。 通过其代理接口之一的代理实例上的方法调用将被分派到实例调用处理程序的invoke方法 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 返回指定接口的代理实例，该代理实例将方法调用分派给指定的调用处理程序。 15.1.2 动态代理作用：拦截和控制 被代理对象 的所有行为 15.1.3 InvocationHandler 调用处理器Interface InvocationHandler 每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。 15.2 XML简介 : XML全称为Extensible Markup Language，意思是可扩展的标记语言。 标记 -&gt; 用标记来修饰文本信息. 可扩展 -&gt; 标记可随意定义. XML技术 : 与数据相关技术, 在企业中xml技术常用来存储数据和传输数据, xml之所以流行的原因在于xml语言与任何编程语言无关, xml可用于 php, java, .net任何编程语言. 15.2.1 书写一个xml配置文件xml编写时也要符合一定的规则 : 1）xml文件的后缀名是.xml2）xml有且只有一个根标签3）xml的标签是尖括号包裹关键字成对出现的，有开始标签有结束标签，关键字是自定义的, xml也可以有空标签/自关闭标签4）xml允许有属性，属性也是根据需要自定义的，属性格式：属性= “属性值”，多个属性之间使用空格隔开5）xml是区分大小写的 xml 的组成1）文档声明：&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt; 2）根标签，例如: 3）其他标签，例如： 4）属性，例如：category=”手机数码” 5）文本，例如：华为手机 6）注释，例如： 15.2.2 约束介绍 DTD ，Schema15.2.3 xml 解析：XML的实际应用场景 : 实际开发中，我们一般会使用各种各样的框架进行企业开发，而这些框架一般都会将某些公共的功能都已经写好，我们需要做的只需要按照框架提供的约束进行框架的配置就可以了，当我们使用XML配置好框架后，再运行时，框架底层会解析我们配置XML文档获取有用的信息，从而根据我们的需求实现某些功能。 所以，实际开发中我们很少会自己编写XML约束和解析XML. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141 @Test public void test1() throws DocumentException &#123; // 1. 创建一个 saxReader 解析器 SAXReader saxReader = new SAXReader(); // 2. 调用 read 方法读取 xml 配置文件, 并获取一个 document 对象 Document document = saxReader.read(\"books.xml\"); // 3. 调用 getRootElement 方法, 获取根标签对象 Element root = document.getRootElement(); // 4. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; bookElements = root.elements(); // 5. 遍历 bookElements 数组 for (Element book : bookElements) &#123; // 6. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String author = book.attributeValue(\"author\"); System.out.println(\"author = \" + author); // 7. 获取子标签 List&lt;Element&gt; elements = book.elements(); // 8. 遍历子标签 for (Element e : elements) &#123; // 9. 获取标签名称, 和标签体数据 String name = e.getName(); String text = e.getText(); System.out.println(name + \" = \" + text); &#125; &#125; &#125;输出结果 :author = 张三丰name = Java从入门到精通price = 98author = 灭绝师太name = Java编程思想price = 998 @Test public void test2() throws DocumentException &#123; // 1. 创建一个 saxReader 解析器 SAXReader saxReader = new SAXReader(); // 2. 调用 read 方法读取 xml 配置文件, 并获取一个 document 对象 Document document = saxReader.read(\"beans.xml\"); // 3. 调用 getRootElement 方法, 获取根标签对象 Element root = document.getRootElement(); // 4. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; beanElements = root.elements(); // 5. 调用 elements 方法, 获取子标签数组 for (Element bean : beanElements) &#123; // 6. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String id = bean.attributeValue(\"id\"); String className = bean.attributeValue(\"className\"); System.out.println(id + \" = \" + className); // 7. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; propElements = bean.elements(); // 8. 调用 propElements 方法, 获取子标签数组 for (Element prop : propElements) &#123; // 9. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String name = prop.attributeValue(\"name\"); String value = prop.attributeValue(\"value\"); System.out.println(name + \" = \" + value); &#125; &#125; &#125;输出结果 :001 = cn.itcast.bean.Userusername = ZhangSanpassword = 123456002 = cn.itcast.bean.Userusername = LiSipassword = 654321 15.3 正则表达式15.3.1 正则概念 egular Expression 正则表达式 : 在Java中, 正则主要使用在 String 类的方法参数为 regex 的名称上 String 类的三个带 regex 参数的方法 :split(String regex) 切割.matches(String regex) 匹配.replaceAll(String regex, String replacement) 替换. 15.3.2 符号介绍12345678910[] 取值的范围. 0-9 数值0到9都成立. 说明 : [0-9] 可以使用 \\d 表示1. &#123;&#125;表示前一个条件中 值 / 字符 可以出现的次数. 说明 : &#123;4,11&#125; 至少4次, 最多11次. &#123;0,1&#125;至少0次,最多一次.可以使用 ? 表示. &#123;1,&#125;至少1次,最多无限次可以使用 + 表示. &#123;0,&#125;至少0次,最多无限次.可以使用 * 表示.2. ()表示分组. 在replaceAll方法的第二个参数上可以使用 $ 符号来引用之前的分组,分组编号自动从1开始. 15.3.3 案例123456789101112131415161718192021public class ReplaceAllTest4 &#123; public static void main(String[] args) &#123; // 13311111946 -&gt; 133**1946 String phone = &quot;13311111946&quot;; /* 源数据 : 13311111946 第一部分 : 133 规则一 : 1[34578]\\d 第二部分 : 1111 规则二 : \\d&#123;4&#125; 第三部分 : 1946 规则三 : \\d&#123;4&#125; */ String result = phone.replaceAll(&quot;(1[34578]\\d)(\\d&#123;4&#125;)(\\d&#123;4&#125;)&quot;, &quot;1****3&quot;); System.out.println(&quot;result = &quot; + result); &#125;&#125;输出结果 :result = 133**1946","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"14JavaSE反射、注解、Junit","slug":"14JavaSE反射、注解、Junit","date":"2016-12-08T14:19:56.000Z","updated":"2018-08-27T02:22:59.935Z","comments":true,"path":"2016/12/08/14JavaSE反射、注解、Junit/","link":"","permalink":"htts://cocked.github.io/2016/12/08/14JavaSE反射、注解、Junit/","excerpt":"","text":"14Junit、反射、注解14.1.1 Junit的概述一般IDE都内置了junit,若需要自行下载jar包,可以访问官网,官网地址如下：http://www.junit.org 特点 方法命名规则：以test开头，使用驼峰命名法。 方法声明上：必须使用注解：@Test，必须使用public修饰符，没有返回值，方法没有参数。 运行测试方法 选中方法名：右键 –&gt; Run 测试方法名，则运行选中的测试方法比如测试方法名为testSum，则右键 --&gt; Run testSum 选中类名：右键 –&gt; Run 类名，则运行该类的所有测试方法比如类名为TestCalculte，则右键 --&gt; Run TestCalculte 选中模块名或项目名：右键 –&gt; Run ‘All Tests’，则运行整个模块中所有类的所有测试方法。 查看测试结果 绿色：表示测试通过， 红色：表示失败或出现错误， 14.1.2 常用注解 @Before：在每个测试方法之前都会运行一次 @After：在每个测试方法运行以后运行的方法 @BeforeClass：在所有的测试方法运行之前，只运行一次，而且必须用在静态方法上面。 @AfterClass：所有的测试方法运行以后，只运行一次，必须用在静态方法上面。 业务类​ 1234567891011121314151617181920- /** 业务类 */ public class Calculate &#123; /* 求a和b之和 */ public int sum(int a,int b)&#123; return a + b; &#125; /** 求a和b之差 */ public int sub(int a,int b)&#123; return a - b; &#125; &#125; ​ 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879- import org.junit.*; public class Test2 &#123; @BeforeClass public static void testBeforeClass() &#123; System.out.println(\"类加载时, 只运行一次.\"); &#125; @Before public void testBefore() &#123; System.out.println(\"测试方法运行前被执行 ...\"); &#125; @Test public void testSum() &#123; Calculator calculator = new Calculator(); int sum = calculator.sum(10, 20); System.out.println(\"sum = \" + sum); &#125; @Test public void testSub() &#123; Calculator calculator = new Calculator(); int sub = calculator.sub(100, 20); System.out.println(\"sub = \" + sub); &#125; @After public void testAfter() &#123; System.out.println(\"每个测试方法被执行后执行 ...\"); &#125; @AfterClass public static void testAfterClass() &#123; System.out.println(\"类结束前, 只执行一次.\"); &#125; &#125;输出结果 : 类加载时, 只运行一次. 测试方法运行前被执行 ... sub = 80 每个测试方法被执行后执行 ... 测试方法运行前被执行 ... sum = 30 每个测试方法被执行后执行 ... 类结束前, 只执行一次. 14.2 反射2.1 反射的基本概念反射是一种机制，利用该机制可以在程序运行过程中对类进行解剖并操作类中的方法，属性，构造方法等成员。 2.2 使用反射机制解剖类的前提必须先要获取到该类的字节码文件对象，即Class类型对象。关于Class描述字节码文件如下图所示： tips： 1）Java中使用Class类表示某个class文件. 2）任何一个class文件都是Class这个类的一个实例对象. 2.3 获取Class对象的三种方式 创建测试类： 1234567- Student public class Student &#123; // 属性 // 行为 &#125; 12345678910112.2.1 方式1：通过类名.class获取 @Test public void test1() &#123; // 方式一 : 通过类名获取 class 对象 // 格式 : 类名.class 属性 // 常用场景 : 反射获取方法时, 确定方法的形参列表类型 Class&lt;Student&gt; cls = Student.class; System.out.println(&quot;cls = &quot; + cls); &#125; 输出结果 : cls = class cn.qiezicy.test2.Student ​ 123456789101112131415161718192021222324252627282.2.2 方式2：通过Object类的成员方法getClass()方法获取 @Test public void test2() &#123; // 1. 创建一个 Student 类型的对象 Student stu = new Student(); // 2. 调用方法, 并传入 stu 对象 showInfo(stu); &#125; public void showInfo(Object obj) &#123; // 方式二 : 使用对象名调用 getClass() 方法. // 格式 : 对象名.getClass() 方法. // 使用场景 : 在方法内部, 确定传入形参的真实类型. Class&lt;?&gt; cls = obj.getClass(); System.out.println(&quot;cls = &quot; + cls); &#125; 输出结果 : cls = class cn.qiezicy.test2.Student2.2.3 方式3：通过Class.forName(&quot;全限定类名&quot;)方法获取 @Test public void test3() throws ClassNotFoundException &#123; // 方式三 : 使用 Class 调用静态方法 forName(全限定类名); 包名+类名 // 使用场景 : 加载外部的配置文件时使用 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); System.out.println(&quot;cls = &quot; + cls); &#125; 输出结果 : cls = class cn.qiezicy.test2.Student 2.3 获取Class对象的信息知道怎么获取Class对象之后，接下来就介绍几个Class类中常用的方法了。 2.3.1 Class对象相关方法 String getSimpleName(); 获得简单类名，只是类名，没有包 String getName(); 获取完整类名，包含包名+类名 T newInstance() ;创建此 Class 对象所表示的类的一个新实例。要求：类必须有public的无参数构造方法 public class TestDate { @Test public void testDate1() throws Exception { // 1. 获取 Date 表示的 Class 对象. Class&lt;?&gt; cls = Class.forName(&quot;java.util.Date&quot;); // 2. 获取简单类名 String simpleName = cls.getSimpleName(); System.out.println(&quot;simpleName = &quot; + simpleName); // 3. 获取完成名称 (包名 + 类名) String name = cls.getName(); System.out.println(&quot;name = &quot; + name); // 3. 创建一个日期对象 // cls.newInstance(); 已过时. Object obj = cls.getDeclaredConstructor().newInstance(); System.out.println(&quot;obj = &quot; + obj); } } ​​ 2.4 获取Class对象的Constructor信息一开始在阐述反射概念的时候，我们说到利用反射可以在程序运行过程中对类进行解剖并操作里面的成员。而一般常操作的成员有构造方法，成员方法，成员变量等等，那么接下来就来看看怎么利用反射来操作这些成员以及操作这些成员能干什么，先来看看怎么操作构造方法。而要通过反射操作类的构造方法，我们需要先知道一个Constructor类。 1234567891011121314151617182.4.1 Constructor类概述 Constructor是构造方法类，类中的每一个构造方法都是Constructor的对象，通过Constructor对象可以实例化对象。2.4.2 Class类中与Constructor相关方法1. Constructor getConstructor(Class... parameterTypes) 根据参数类型获取构造方法对象，只能获得public修饰的构造方法。 如果不存在对应的构造方法，则会抛出 java.lang.NoSuchMethodException 异常。2. Constructor getDeclaredConstructor(Class... parameterTypes) 根据参数类型获取构造方法对象，包括private修饰的构造方法。 如果不存在对应的构造方法，则会抛出 java.lang.NoSuchMethodException 异常。3. Constructor[] getConstructors()获取所有的public修饰的构造方法4. Constructor[] getDeclaredConstructors()获取所有构造方法，包括privat修饰的 2.4.3 Constructor类中常用方法1. T newInstance(Object... initargs)根据指定参数创建对象。2. void setAccessible(true)暴力反射，设置为可以直接访问私有类型的构造方法。 2.5 获取Class对象的Method信息操作完构造方法之后，就来看看反射怎么操作成员方法了。同样的在操作成员方法之前我们需要学习一个类：Method类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687882.5.1 Method类概述 Method是方法类，类中的每一个方法都是Method的对象，通过Method对象可以调用方法。 2.5.2 Class类中与Method相关方法1. Method getMethod(&quot;方法名&quot;, 方法的参数类型... 类型) 根据方法名和参数类型获得一个方法对象，只能是获取public修饰的2. Method getDeclaredMethod(&quot;方法名&quot;, 方法的参数类型... 类型) 根据方法名和参数类型获得一个方法对象，包括private修饰的3. Method[] getMethods() (了解) 获取所有的public修饰的成员方法，包括父类中。4. Method[] getDeclaredMethods() (了解) 获取当前类中所有的方法，包含私有的，不包括父类中。2.5.3 Method类中常用方法1. Object invoke(Object obj, Object... args) 根据参数args调用对象obj的该成员方法 如果obj=null，则表示该方法是静态方法2. void setAccessible(boolean flag) 暴力反射，设置为可以直接调用私有修饰的成员方法2.5.4 示例代码测试一 : @Test public void testMethod1() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.itcast.test2.Student&quot;); // 2. 调用 getMethod 方法 Method eat = cls.getMethod(&quot;eat&quot;, String.class); // 3. 调用 invoke 方法 Object obj = cls.getDeclaredConstructor().newInstance(); eat.invoke(obj, &quot;牛肉&quot;); &#125; 输出结果 : 正在吃牛肉测试二 : @Test public void testDeclaredMethod2() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); // 2. 调用 declaredMethod 方法 Method sleep = cls.getDeclaredMethod(&quot;fallInLove&quot;); // 3. 暴力反射 (设置可访问权限) sleep.setAccessible(true); // 4. 调用 invoke 执行 Object obj = cls.getDeclaredConstructor().newInstance(); sleep.invoke(obj); &#125; 输出结果 : 正在谈恋爱 ...测试三 : @Test public void testStaticMethod3() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); // 2. 调用 getMethod 方法 Method study = cls.getMethod(&quot;study&quot;); // 3. 调用 invoke 方法 study.invoke(null); &#125; 输出结果 : 正在学习中 ...测试四 : @Test public void tesMethods4() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); // 2. 调用 getMethods 方法 Method[] methods = cls.getMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125;测试五 : @Test public void tesDelcaredMethods5() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.test2.Student&quot;); // 2. 调用 getDeclaredMethods 方法 Method[] methods = cls.getDeclaredMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125; 2.6 获取Class对象的Field信息(了解)2.6.1 Field类概述 Field是属性类，类中的每一个属性(成员变量)都是Field的对象，通过Field对象可以给对应的成员变量赋值和取值。 2.6.2 Class类中与Field相关方法 Field getDeclaredField(String name)根据属性名获得属性对象，包括private修饰的 Field getField(String name)根据属性名获得属性对象，只能获取public修饰的 Field[] getFields()获取所有的public修饰的属性对象，返回数组。 Field[] getDeclaredFields()获取所有的属性对象，包括private修饰的，返回数组。 2.6.3 Field类中常用方法 void set(Object obj, Object value) Object get(Object obj) void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。 Class getType(); 获取属性的类型，返回Class对象。 2.6.4 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263测试一 : @Test public void testField1() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(\"cn.itcast.test2.Student\"); // 2. 调用 getField 方法 Field description = cls.getField(\"description\"); // 3. 设置属性 Object obj = cls.getDeclaredConstructor().newInstance(); description.set(obj, \"这就是那个神奇的学生.\"); // 4. 获取属性 Object desc = description.get(obj); System.out.println(\"desc = \" + desc); &#125; 输出结果 : desc = 这就是那个神奇的学生.测试二 : @Test public void testDeclaredField2() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(\"cn.qiezicy.test2.Student\"); // 2. 调用 getDeclaredField 方法 Field name = cls.getDeclaredField(\"name\"); // 3. 暴力反射 name.setAccessible(true); // 4. 设置属性 Object obj = cls.getDeclaredConstructor().newInstance(); name.set(obj, \"111\"); // 5. 查看 System.out.println(obj); &#125; 输出结果 : Student&#123;name='111', age=0, gender= &#125;测试三 : @Test public void testFields3() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(\"cn.qiezicy.test2.Student\"); // 2. 调用 getFields 方法 Field[] fields = cls.getFields(); // 3. 遍历 fields 数组 for (Field field : fields) &#123; System.out.println(field); &#125; &#125; 输出结果 : public java.lang.String cn.qiezicy.test2.Student.description测试四 : @Test public void testDeclaredFields4() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName(\"cn.qiezicy.test2.Student\"); // 2. 调用 getDeclaredFields 方法 Field[] fields = cls.getDeclaredFields(); // 3. 遍历 fields 数组 for (Field field : fields) &#123; System.out.println(field); &#125; &#125; 2.7 反射案例编写一个工厂方法可以根据配置文件产任意类型的对象。 例如有配置文件stu.properties，存储在当前项目下，内容如下：​ 1234 className=cn.qiezicy.reflect.Student name=rose age=18 gender=女 ​ 根据配置文件信息创建一个学生对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081- Student 类 : public class Student &#123; // 属性 private String name; private int age; private char gender; // 公开构造方法 : public Student(String name, int age, char gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; // 公开无参构造方法 public Student() &#123; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", gender=\" + gender + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getGender() &#123; return gender; &#125; public void setGender(char gender) &#123; this.gender = gender; &#125; &#125; CreateObject 类 : import java.io.FileReader; import java.io.IOException; import java.lang.reflect.Field; import java.util.Properties; import java.util.Set; public class CreateObject { // 属性 private static Properties prop; // 静态方法 : 加载配置文件 static { // 初始化 : prop = new Properties(); try { prop.load(new FileReader(&quot;stu.properties&quot;)); } catch (IOException e) { // e.printStackTrace(); throw new RuntimeException(&quot;配置文件加载失败!&quot;); } } // 方法 : 根据配置文件, 创建对象 public static Object createObject() throws Exception { // 1. 获取 class 名称 String className = prop.getProperty(&quot;className&quot;); // 2. 获取 class 对象 Class&lt;?&gt; cls = Class.forName(className); // 3. 创建一个 cls 表示的对象 Object obj = cls.getDeclaredConstructor().newInstance(); // 4. 获取属性集对象的所有 键集 Set&lt;String&gt; keys = prop.stringPropertyNames(); // 5. 遍历 for (String key : keys) { // 判断 : if (&quot;class&quot;.equals(key)) continue; // 6. 根据 key 获取对应的 value String value = prop.getProperty(key); // 7. 获取所有的 fields 数组 Field field = cls.getDeclaredField(key); // 8. 设置访问权限 field.setAccessible(true); // 9. 获取属性的类型 Class&lt;?&gt; type = field.getType(); // 10. 判断类型 if (type == int.class) { int v = Integer.parseInt(value); // 设置属性 field.set(obj, v); } else if (type == char.class) { char c = value.charAt(0); // 设置属性 field.set(obj, c); } else { field.set(obj, value); } } // 11. 返回对象 return obj; } } 测试类 : public class Test { public static void main(String[] args) throws Exception { Object obj = CreateObject.createObject(); System.out.println(&quot;obj = &quot; + obj); } } 输出结果 : obj = Student{name=&apos;rose&apos;, age=18, gender=女} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426 # 14.3 注解## 3.1 注解的概述3.1.1 注解的概念- 注解是JDK1.5的特性。- 注解相当一种标记，是类的组成部分，可以给类携带一些额外的信息。- 标记(注解)可以加在包，类，字段，方法，方法参数以及局部变量上。- 注解是给编译器或JVM看的，编译器或JVM可以根据注解来完成对应的功能。 注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。3.1.2 注解的作用 注解的作用就是给程序带入参数。以下几个常用操作中都使用到了注解：1. 生成帮助文档：@author和@version- @author：用来标识作者姓名。- @version：用于标识对象的版本号，适用范围：文件、类、方法。- 使用@author和@version注解就是告诉Javadoc工具在生成帮助文档时把作者姓名和版本号也标记在文档中。如下图：1. 编译检查：@Override- @Override：用来修饰方法声明。- 用来告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。如下图1. 框架的配置(框架=代码+配置)- 具体使用请关注框架课程的内容的学习。3.1.3 常见注解1. @author：用来标识作者名。2. @version：用于标识对象的版本号。3. @Override ：用来修饰方法声明，告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。4. @Deprecated: 用来表示不赞成使用.## 3.2 自定义注解3.2.1 定义格式 public @interface 注解名 &#123; &#125; 如：定义一个名为 Student 的注解 public @interface Student &#123; &#125;- 以上定义出来的注解就是一个最简单的注解了，但这样的注解意义不大，因为注解中没有任何内容，就好像我们定义一个类而这个类中没有任何成员变量和方法一样，这样的类意义也是不大的，所以在定义注解时会在里面添加一些成员来让注解功能更加强大，这些成员就是属性。接下来就看看怎么给注解添加属性。3.2.2 注解的属性1. 属性的作用- 可以让用户在使用注解时传递参数，让注解的功能更加强大。1. 属性的格式- 格式1：数据类型 属性名();- 格式2：数据类型 属性名() default 默认值;1. 属性定义示例 // 该注解拥有三个属性 (name, age, gender) public @interface Student &#123; String name(); int age() default 18; char gender() default &apos;男&apos;; &#125;1. 属性适用的数据类型- 八种基本数据类型（byte, short, int, long, float, double, char, boolean)- String类型，Class类型，枚举类型，注解类型- 以上所有类型的一维数组## 3.3 使用自定义注解3.3.1 定义注解1. 定义一个注解：Book- 包含属性：String value() 书名- 包含属性：double price() 价格，默认值为 100- 包含属性：String[] authors() 多位作者 说明 : 当注解中只有一个属性且名称是value，在使用注解时给value属性赋值可以直接给属性值，无论value是单值元素还是数组类型。1. 代码实现 public @interface Book &#123; // 书名 String value(); // 价格 int price() default 100; // 多位作者 String[] authors(); &#125; 3.3.2 使用注解2. 定义类在成员方法上使用Book注解 public class BookShelf &#123; @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;白求恩&quot;&#125;) public void show() &#123; &#125; &#125;​使用注意事项- 如果属性有默认值，则使用注解的时候，这个属性可以不用赋值。- 如果属性没有默认值，那么在使用注解时一定要给属性赋值。## 3.4 注解之元注解3.4.1 元注解的概述- Java API 提供的注解- 专门用来定义注解的注解。- 任何 Java 官方提供的非元注解的定义中都使用到了元注解。 3.4.2 常用元注解- @Target 注释的使用位置.- @Retention 注解的声明周期. 3.4.2.1 元注解之@Target- 作用：指明此注解用在哪个位置，如果不写默认是任何地方都可以使用。- 可选的参数值在枚举类ElemenetType中包括： TYPE： 用在类,接口上 FIELD：用在成员变量上 METHOD： 用在方法上 PARAMETER：用在参数上 CONSTRUCTOR：用在构造方法上 LOCAL_VARIABLE：用在局部变量上 3.4.2.2 元注解之@Retention- 作用：定义该注解的生命周期(有效范围)。- 可选的参数值在枚举类型RetentionPolicy中包括 SOURCE：注解只存在于Java源代码中，编译生成的字节码文件中就不存在了。 CLASS：注解存在于Java源代码、编译以后的字节码文件中，运行的时候内存中没有，默认值。 RUNTIME：注解存在于Java源代码中、编译以后的字节码文件中、运行时内存中，程序可以通过反射获取该注解。3.4.3 元注解使用示例 // (书名, 价格, 作者) import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // 元注解 : Target 目标 (注解使用的位置) @Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) // 元注解 : Retention 保留策略 (SOURCE, CLASS, RUNTIME) @Retention(RetentionPolicy.RUNTIME) public @interface Book &#123; String value(); // 说明 : 如果注解只有一个属性, 最好取名为 value, 因为书写时, 可以省略. int price() default 100; String[] authors(); // 多位作者 &#125;​​​BookShelf 类​ @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;xxx&quot;&#125;) public class BookShelf &#123; // 属性 // @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;xxx&quot;&#125;) private int id; @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;xxx&quot;&#125;) public void show() &#123; String value = &quot;&quot;; int price = 0; String[] authors = &#123;&#125;; System.out.println(&quot;书名为 : &quot; + value); System.out.println(&quot;价格为 : &quot; + price); System.out.println(&quot;作者为 : &quot; + Arrays.toString(authors)); &#125; &#125;​​​## 3.5 注解解析3.5.1 什么是注解解析- 通过Java技术获取注解数据的过程则称为注解解析。3.5.2 与注解解析相关的接口- Anontation：所有注解类型的公共接口，类似所有类的父类是Object。- AnnotatedElement：定义了与注解解析相关的方法，常用方法： boolean isAnnotationPresent(Class annotationClass); 判断当前对象是否有指定的注解，有则返回true，否则返回false。 T getAnnotation(Class&lt;T&gt; annotationClass); 获得当前对象上指定的注解对象。3.5.3 获取注解数据的原理- 注解作用在那个成员上，就通过反射获得该成员的对象(Filed)来得到它的注解。- 如注解作用在方法上，就通过方法(Method)对象得到它的注解*- 如注解作用在类上，就通过Class对象得到它的注解3.5.4 使用反射获取注解的数据3.5.4.1 需求说明1. 定义注解Book，要求如下：- 包含属性：String value() 书名- 包含属性：double price() 价格，默认值为 100- 包含属性：String[] authors() 多位作者 - 限制注解使用的位置：类和成员方法上- 指定注解的有效范围：RUNTIME1. 定义BookStore类，在类和成员方法上使用Book注解2. 定义TestAnnotation测试类获取Book注解上的数据3.5.4.2 代码实现1.注解Book import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) public @interface Book &#123; // 书名 String value(); // 价格 int price() default 100; // 作者 (多位作者) String[] authors(); &#125;​2.BookShelf 类​ import java.lang.reflect.Method; import java.util.Arrays; @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;白求恩&quot;&#125;) public class BookShelf &#123; // 属性 // @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;白求恩&quot;&#125;) private int id; @Book(value = &quot;西游记&quot;, price=998, authors = &#123;&quot;吴承恩&quot;, &quot;白求恩&quot;&#125;) public void show() &#123; // 定义变量 String value = &quot;&quot;; int price = 0; String[] authors = &#123;&#125;; // 获取当前类的 Class 对象 Class&lt;? extends BookShelf&gt; cls = this.getClass(); try &#123; // 获取当前方法对象 Method show = cls.getMethod(&quot;show&quot;); // 判断当前方法上是否有注解信息 if (show.isAnnotationPresent(Book.class)) &#123; // 条件成立, 获取到当前注解对象 Book book = show.getAnnotation(Book.class); // 取出信息, 并实现赋值 value = book.value(); price = book.price(); authors = book.authors(); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; // 输出查看 System.out.println(&quot;书名为 : &quot; + value); System.out.println(&quot;价格为 : &quot; + price); System.out.println(&quot;作者为 : &quot; + Arrays.toString(authors)); &#125; &#125;​3.TestBookShelf 类​ public class TestBookShelf &#123; public static void main(String[] args) &#123; BookShelf bookShelf = new BookShelf(); bookShelf.show(); &#125; &#125; 输出结果 : 书名为 : 西游记 价格为 : 998 作者为 : [吴承恩, 白求恩] 书名为 : 价格为 : 0 作者为 : []​​​补充 : 解析类上的注解​ import java.util.Arrays; public class TestBookShelf2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 1. 获取类 Class&lt;?&gt; cls = Class.forName(&quot;cn.itcast.annotation.BookShelf&quot;); // 2. 判断该类上是否有 Book 注解信息 if (cls.isAnnotationPresent(Book.class)) &#123; // 3. 获取 Book 注解对象 Book book = cls.getAnnotation(Book.class); // 4. 取出注解信息 String value = book.value(); int price = book.price(); String[] authors = book.authors(); // 5. 输出查看 System.out.println(&quot;value = &quot; + value); System.out.println(&quot;price = &quot; + price); System.out.println(&quot;authors = &quot; + Arrays.toString(authors)); &#125; &#125; &#125; 输出结果 : value = 西游记 price = 998 authors = [吴承恩, 白求恩]## 3.6 注解案例3.5.1 案例说明 模拟Junit测试的@Test3.5.2 案例分析1. 模拟Junit测试的注释@Test，首先需要编写自定义注解@MyTest，并添加元注解，保证自定义注解只能修饰方法，且在运行时可以获得。2. 然后编写目标类（测试类），然后给目标方法（测试方法）使用 @MyTest注解，编写三个方法，其中两个加上@MyTest注解。3. 最后编写调用类，使用main方法调用目标类，模拟Junit的运行，只要有@MyTest注释的方法都会运行。 3.5.3 案例代码4. 注解MyTest ​ import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyTest &#123; &#125;​1. 目标类MyTestClass ​ public class MyTestClass &#123; @MyTest public void test01() &#123; System.out.println(&quot;测试方法一被执行 ...&quot;); &#125; public void test02() &#123; System.out.println(&quot;测试方法二被执行 ...&quot;); &#125; @MyTest public void test03() &#123; System.out.println(&quot;测试方法三被执行 ...&quot;); &#125; &#125;​1. 调用类ParseAnnotation ​ import java.lang.reflect.Method; // 解析注解类 : public class ParseAnnotation &#123; public static void main(String[] args) throws Exception &#123; // 1. 获取 MyTestClass 的 Class 对象 Class&lt;?&gt; cls = Class.forName(&quot;cn.qiezicy.practice.MyTestClass&quot;); Object obj = cls.getDeclaredConstructor().newInstance(); // 2. 调用 getMethods 获取所有方法 Method[] methods = cls.getMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; // 4. 判断当前方法上是否存在 MyTest 注解 if (method.isAnnotationPresent(MyTest.class)) &#123; // 5. 执行当前方法 method.invoke(obj); &#125; &#125; &#125; &#125; 输出结果 : 测试方法一被执行 ... 测试方法三被执行 ...","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"13JavaSE函数式编程&Stream流","slug":"13JavaSE函数式编程-Stream流","date":"2016-12-04T11:10:08.000Z","updated":"2018-08-27T02:22:54.653Z","comments":true,"path":"2016/12/04/13JavaSE函数式编程-Stream流/","link":"","permalink":"htts://cocked.github.io/2016/12/04/13JavaSE函数式编程-Stream流/","excerpt":"","text":"13.1常用的函数式接口总结 接口名称 方法名称 抽象/默认 延迟/终结 方法描述 Supplier get 抽象 终结 供给型接口，无参有返回值，主要用于 Consumer accept 抽象 终结 消费型接口，有参数无返回值 andThen 默认 延迟 Function apply 抽象 终结 函数型接口，有参数有返回值 andThen 默认 延迟 compose 默认 延迟 Predicate test 抽象 终结 断言型接口，元芳你怎么看 and 默认 延迟 or 默认 延迟 negate 默认 延迟 notes： 延迟方法：只是在拼接Lambda函数模型的方法，并不立即执行得到结果。 终结方法：根据拼好的Lambda函数模型，立即执行得到结果值的方法。 13.2 Stream流13.2.1 获取流的三种方式1234567891011121314151617public static void main(String[] args) &#123; // Collection 集合 Collection c = new ArrayList&lt;String&gt;(); Stream stream1 = c.stream(); System.out.println(\"stream1 = \" + stream1); // List 集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream2 = list.stream(); System.out.println(\"stream2 = \" + stream2); // Set 集合 HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); Stream&lt;String&gt; stream3 = set.stream(); System.out.println(\"stream3 = \" + stream3);&#125; Map集合 1234567891011121314151617public static void main(String[] args) &#123; // Map 集合 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 获取流 // 1. keySet Stream&lt;String&gt; stream1 = map.keySet().stream(); // 2. values Stream&lt;Integer&gt; stream2 = map.values().stream(); // 3. entrySet Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream3 = map.entrySet().stream(); System.out.println(\"stream1 = \" + stream1); System.out.println(\"stream2 = \" + stream2); System.out.println(\"stream3 = \" + stream3);&#125; 13.2.2 流的常用方法** 终结方法**：返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用。本小节中，终结方法包括count和forEach方法。 非终结方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。） 终结方法：逐一处理：forEach，统计个数：count 非终结方法：过滤：filter，取用前几个：limit，跳过前几个：skip，映射：map 组合： 使用Stream接口的静态方法concat 方法名 方法作用 方法种类 是否支持链式调用 count 统计个数 终结 否 forEach 逐一处理 终结 否 filter 过滤 函数拼接 是 limit 取用前几个 函数拼接 是 skip 跳过前几个 函数拼接 是 map 映射 函数拼接 是 concat 组合 函数拼接 是 并发流： 1234567891011121314151617181920转换为并发流 1. Stream的父接口java.util.stream.BaseStream中定义了一个parallel方法： 2.在通过集合获取流时，也可以直接调用parallelStream方法来直接获取支持并发操作的流 default Stream&lt;E&gt; parallelStream() &#123;... 收集集合三种： 收集到集合中 Stream流提供collect方法，其参数需要一个java.util.stream.Collector&lt;T,A, R&gt;接口对象来指定收集到哪种集合中。幸运的是，java.util.stream.Collectors类提供一些方法，可以作为Collector接口的实例：- public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()：转换为List集合。- public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()：转换为Set集合。 收集到数组中 Stream提供toArray方法来将结果放到一个数组中，由于泛型擦除的原因，返回值类型是Object[]的： 扩展：解决泛型数组问题有了Lambda和方法引用之后，可以使用toArray方法的另一种重载形式传递一个IntFunction&lt;A[]&gt;的函数，继而从外面指定泛型参数。方法签名： &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);有了它，上例代码中不再局限于Object[]结果，而可以得到String[]结果","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"11Java网络编程","slug":"11Java网络编程","date":"2016-11-28T12:30:18.000Z","updated":"2018-08-27T02:22:44.139Z","comments":true,"path":"2016/11/28/11Java网络编程/","link":"","permalink":"htts://cocked.github.io/2016/11/28/11Java网络编程/","excerpt":"","text":"第一章 网络编程入门1.1软件结构C/S结构：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络通信协议 网络通信协议：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守，最终完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 1.3 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。 1.4 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。有资料显示，全球IPv4地址在2011年2月分配完毕。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 被称为 本机回环地址. ​ 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 第二章 TCP通信程序2.1 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： 1Socket client = new Socket(\"127.0.0.1\", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类 ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 2.4 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动, 等待连接 ...\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取 socket 通道输入流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // 4. 解析数据 String str = new String(buf, 0, len); System.out.println(\"服务端读取的数据为 : \" + str); &#125; // 5. 关闭资源 serverSocket.close(); System.out.println(\"服务端关闭, 结束连接.\"); &#125;&#125;输出结果 :服务端启动, 等待连接 ...服务端读取的数据为 : 在吗?服务端关闭, 结束连接. 客户端实现： 1234567891011121314151617181920import java.io.IOException;import java.io.OutputStream;import java.net.Socket;public class ClientTCP &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字, 尝试连接服务器 Socket socket = new Socket(\"127.0.0.1\", 8888); // 2. 获取 socket 通道输出流 OutputStream out = socket.getOutputStream(); // 3. 输出数据 out.write(\"在吗?\".getBytes()); // 4. 关闭资源 socket.close(); &#125;&#125; 服务器向客户端回写数据服务端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动, 等待连接 ...\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取 socket 通道输入流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // 4. 解析数据 String str = new String(buf, 0, len); System.out.println(\"服务端读取的数据为 : \" + str); &#125; /*************** 服务端实现数据回写 ****************/ // 5. 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 6. 回写数据 out.write(\"在\".getBytes()); // 注意 : 需要调用 socket.shutdown(); 方法, 向 socket 通道中写出结束符 socket.shutdownOutput(); // 7. 关闭资源 serverSocket.close(); System.out.println(\"服务端关闭, 结束连接.\"); &#125;&#125;输出结果 :服务端启动, 等待连接 ...服务端读取的数据为 :在吗?服务端关闭, 结束连接. 客户端实现： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class ClientTCP &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字, 尝试连接服务器 Socket socket = new Socket(\"127.0.0.1\", 8888); // 2. 获取 socket 通道输出流 OutputStream out = socket.getOutputStream(); // 3. 输出数据 out.write(\"在吗?\".getBytes()); // 注意 : 需要调用 socket.shutdown(); 方法, 向 socket 通道中写出结束符 socket.shutdownOutput(); /*************** 客户端解析回写数据 ****************/ // 4. 获取 socket 通道的输入流 InputStream in = socket.getInputStream(); // 5. 读取, 并解析回写数据 byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; String str = new String(buf, 0, len); System.out.println(\"客户端读写服务端的回写数据为 : \" + str); &#125; // 6. 关闭资源 socket.close(); &#125;&#125;输出结果 :客户端读写服务端的回写数据为 : 在 第三章 综合案例3.1 文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 基本实现服务端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端已启动, 等待客户端连接.\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File(\"D:/upload\"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 String ip = socket.getInetAddress().getHostAddress(); File file = new File(parentFile, ip + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write(\"上传成功!\".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); // 6. 关闭资源 serverSocket.close(); System.out.println(\"文件保存成功!\"); &#125;&#125;输出结果 :服务端已启动, 等待客户端连接.文件保存成功! 客户端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.net.Socket;public class FileUploadClient &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字对象, 尝试连接服务端 Socket socket = new Socket(\"127.0.0.1\", 8888); // 2. 复制文件 (先读后写) // 2.1 创建一个高效的字节缓冲输入流, 关联硬盘路径文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"D:/柳岩.jpg\")); // 2.2 创建一个高效的字节缓冲输出流, 关联 socket 通道输出流 BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); // 3. 读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 注意 : 向通道中写入一个结束符 socket.shutdownOutput(); // 4. 读取服务端的反馈信息 // 4.1 获取 socket 通道的输入流 InputStream in = socket.getInputStream(); byte[] readBuf = new byte[1024]; int readLen = -1; while ((readLen = in.read(readBuf)) != -1) &#123; String str = new String(readBuf, 0, readLen); System.out.println(str); &#125; // 5. 关闭资源 socket.close(); &#125;&#125;输出结果 :上传成功! 文件上传优化分析 :问题1 : 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+\".jpg\") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 使用 UUID 类解决图片名称的问题 : 1234for (int i = 0; i &lt; 10; i++) &#123; String name = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); System.out.println(name + \".jpg\");&#125; 输出结果 : 12345678910345154742a884d0c8d38a981b06d0f51.jpg828cade0a69b485983efa2efb6c2edf8.jpg2522a1462142450195a32997aa00968b.jpg0fb24406d79b40dcbefdd99298224d8f.jpg8d9f7ed4cf12430ba4b9904bc17541a3.jpg558fc7d91f614ae6845958cc81f9cfb6.jpg5ede501fbd624f9d8d021f582da73219.jpg5b51a105b3cf473ba0e2751029411ec9.jpg42ea3479a85b4c7db915335302661515.jpg89e58cb12a014c5faa83b6bb99a33ca6.jpg 问题2 : 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 问题3 : 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现 : 实现类完成123456789101112131415161718192021222324252627282930313233343536import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端已启动, 等待客户端连接.\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 UploadTask uploadTask = new UploadTask(socket); new Thread(uploadTask, \"上传线程\").start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125;输出结果 :服务端已启动, 等待客户端连接.文件保存成功!文件保存成功! 实现类 : UploadTask 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.*;import java.net.Socket;public class UploadTask implements Runnable &#123; // 属性 private Socket socket; // 构造方法 public UploadTask(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File(\"D:/upload\"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write(\"上传成功!\".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"文件保存成功!\"); &#125;&#125; 匿名内部类实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端已启动, 等待客户端连接.\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File(\"D:/upload\"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write(\"上传成功!\".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"文件保存成功!\"); &#125; &#125;, \"上传线程\").start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125; Lambda 表达式实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端已启动, 等待客户端连接.\"); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 new Thread(() -&gt; &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File(\"D:/upload\"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write(\"上传成功!\".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"文件保存成功!\"); &#125;).start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125; 3.2 模拟服务器模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 准备页面数据，web文件夹。 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910111213141516171819202122232425import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个服务端套接字对象, 绑定端口号为 8888 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取通道输出流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String str = new String(buf, 0, len); System.out.println(str); // 4. 关闭服务端套接字 serverSocket.close(); &#125;&#125; 返回数据内容 : 1234567GET / HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299Accept-Encoding: gzip, deflateHost: localhost:8888Connection: Keep-Alive 返回数据内容 : 1234567GET /web/index.html HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299Accept-Encoding: gzip, deflateHost: localhost:8888Connection: Keep-Alive GET /web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个服务端套接字对象, 绑定端口号为 8888 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取通道输出流, 读取数据 InputStream in = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); // 读取数据的第一行 String line = reader.readLine(); System.out.println(\"line = \" + line); // GET /web/index.html HTTP/1.1 // 切割字符 String[] split = line.split(\" \"); // 取出需要的一部分 String path = split[1].substring(1); System.out.println(\"path = \" + path); // 4. 关闭服务端套接字 serverSocket.close(); &#125;&#125;输出结果如下 :line = GET /web/index.html HTTP/1.1path = web/index.html","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"10JavaSE缓冲流、转换流、序列化流、Files","slug":"10JavaSE缓冲流、转换流、序列化流、Files","date":"2016-11-28T00:04:33.000Z","updated":"2018-08-27T02:22:39.100Z","comments":true,"path":"2016/11/28/10JavaSE缓冲流、转换流、序列化流、Files/","link":"","permalink":"htts://cocked.github.io/2016/11/28/10JavaSE缓冲流、转换流、序列化流、Files/","excerpt":"","text":"第一章 属性集1.1 概述java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 1.2 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Properties;import java.util.Set;public class PropertiesTest1 &#123; public static void main(String[] args) &#123; // 1. 创建属性集对象 Properties prop = new Properties(); // 2. 添加键值对元素 prop.setProperty(\"filename\", \"a.txt\"); prop.setProperty(\"length\", \"1024\"); prop.setProperty(\"location\", \"D:/a.txt\"); // 3. 打印属性集对象 System.out.println(\"prop = \" + prop); // 4. 通过键,获取属性值 String filename = prop.getProperty(\"filename\"); String length = prop.getProperty(\"length\"); String location = prop.getProperty(\"location\"); System.out.println(\"filename = \" + filename); System.out.println(\"length = \" + length); System.out.println(\"location = \" + location); // 5. 遍历属性集,获取所有键的集合 Set&lt;String&gt; keys = prop.stringPropertyNames(); System.out.println(\"--------------\"); // 6. 打印键值对 for (String key : keys) &#123; String value = prop.getProperty(key); System.out.println(key + \" = \" + value); &#125; &#125;&#125;输出结果：prop = &#123;filename=a.txt, length=1024, location=D:/a.txt&#125;filename = a.txtlength = 1024location = D:/a.txt--------------filename = a.txtlength = 1024location = D:/a.txt 与流相关的方法 public void load(InputStream inStream)： 从字节输入流中读取键值对。 参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式: 123filename=a.txtlength=209385038location=D:\\\\a.txt 加载代码演示： 123456789101112131415161718192021222324252627import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;import java.util.Set;public class PropertiesTest2 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个属性集对象 Properties prop = new Properties(); // 2. 加载数据到 prop 对象中 prop.load(new FileInputStream(\"a.txt\")); // 3. 获取所有的 key, 然后实现遍历 Set&lt;String&gt; keys = prop.stringPropertyNames(); for (String key : keys) &#123; String value = prop.getProperty(key); System.out.println(key + \" = \" + value); &#125; &#125;&#125;输出结果：filename = a.txtlength = 209385038location = D:\\a.txt 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。 第二章 转换流2.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集 字符集 Charset：是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 2.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 12345678910111213141516171819202122232425262728import java.io.FileReader;import java.io.IOException;public class Test1 &#123; public static void main(String[] args) throws IOException &#123; // FileReader reader = new FileReader(\"a.txt\"); FileReader reader = new FileReader(\"D:/a.txt\"); int read = -1; while ((read = reader.read()) != -1) &#123; System.out.println((char) read); &#125; reader.close(); &#125;&#125;输出结果：�������Ա. 那么如何读取GBK编码的文件呢？ 2.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\"); 指定编码读取12345678910111213141516171819202122232425262728293031323334353637import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class Test3 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符转换流对象 (默认为项目编码 UTF-8) InputStreamReader reader1 = new InputStreamReader(new FileInputStream(\"D:/a.txt\")); // 2. 创建一个字符转换流对象 (指定编码为 GBK) InputStreamReader reader2 = new InputStreamReader(new FileInputStream(\"D:/a.txt\"), \"GBK\"); // 读取数据 int read = -1; while ((read = reader1.read()) != -1) &#123; System.out.print((char)read); &#125; System.out.println(); System.out.println(\"-------------\"); read = -1; while ((read = reader2.read()) != -1) &#123; System.out.print((char) read); &#125; // 关闭资源 reader2.close(); reader1.close(); &#125;&#125;输出结果 :�Ұ��Ϻ�������.-------------爱尔兰大白鲨 2.4 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\"); 指定编码写出12345678910111213141516171819202122import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符转换流对象 (默认编码: UTF-8) OutputStreamWriter writer1 = new OutputStreamWriter(new FileOutputStream(\"D:/b.txt\")); // 2. 创建一个字符转换流对象 (执行编码: GBK) OutputStreamWriter writer2 = new OutputStreamWriter(new FileOutputStream(\"D:/c.txt\"), \"GBK\"); // 3. 写入数据 writer1.write(\"爱尔兰大白鲨.\"); // b.txt 22个字节 writer2.write(\"爱尔兰大白鲨.\"); // c.txt 15个字节 // 4. 关闭资源 writer2.close(); writer1.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 2.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现1234567891011121314151617181920212223import java.io.*;public class Test5 &#123; public static void main(String[] args) throws IOException &#123; // 1. 使用 GBK 编码读取 Windows 系统上创建的文件 InputStreamReader reader = new InputStreamReader(new FileInputStream(\"D:/a.txt\"), \"GBK\"); // 2. 创建一个 UTF-8 编码的写入字符转换流, 按照指定编码格式将读取的数据重新写入到文件中 OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"D:/aa.txt\"), \"UTF-8\"); int read = -1; while ((read = reader.read()) != -1) &#123; // 写入 writer.write(read); // System.out.println((char) read); &#125; writer.close(); reader.close(); &#125;&#125; 第三章 序列化3.1 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的数据等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。 3.2 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream(\"employee.txt\");ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 条件一 : 序列化接口 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 条件二 : 序列版本号 格式 : private static final long serialVersionUID = 1L; Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 如此，当JVM反序列化对象时，能找到class文件，如果class文件在序列化对象之后发生了修改，那么反序列化操作也不会失败，如果没有序列化版本号, 则反序列化会抛出一个InvalidClassException异常。 Employee 类定义 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.Serializable;public class Employee implements Serializable &#123; // 需要为序列化的类添加一个 `序列版本号` 属性 private static final long serialVersionUID = 1L; // 属性 private String name; private String address; private transient int age; // 被 transient 修饰的属性不参与序列化 @Override public String toString() &#123; return \"Employee&#123;\" + \"name='\" + name + '\\'' + \", address='\" + address + '\\'' + \", age=\" + age + '&#125;'; &#125; // 行为 public void checkAddress() &#123; System.out.println(name + \" = \" + address); &#125; public Employee(String name, String address, int age) &#123; this.name = name; this.address = address; this.age = age; &#125; public Employee() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 1234567891011121314151617181920212223242526272829import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class ObjectOutputStreamTest &#123; public static void main(String[] args) &#123; // 序列化 : 将一个Java对象存储到文件中. // 1. 创建一个 Employee 对象, 并初始化数值 Employee emp = new Employee(\"张三\", \"爱尔兰大白鲨\", 30); // 2. 创建一个对象输出流 try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"D:/emp.txt\"))) &#123; oos.writeObject(emp); &#125; catch (IOException e) &#123; // e.printStackTrace(); // 将一个编译时期的异常转换为运行时期的异常抛出. throw new RuntimeException(\"序列化对象失败.\"); &#125; System.out.println(\"序列化成功!\"); &#125;&#125;输出结果：序列化成功! 3.3 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728293031import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class ObjectInputStreamTest &#123; public static void main(String[] args) &#123; // 反序列化 : 将文件中的数据读取为一个 Java 对象 // 1. 创建一个对象读取流 try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"D:/emp.txt\"))) &#123; // 2. 读取文件中的数据为 Java 对象 Object obj = ois.readObject(); System.out.println(obj); // 3. 将 obj 类型强转为 Employee 类型, 并实现方法的调用 Employee emp = (Employee) obj; emp.checkAddress(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;输出结果 :Employee&#123;name='张三', address='爱尔兰大白鲨', age=0&#125;张三 = 爱尔兰大白鲨 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 第四章 打印流4.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 4.2 PrintStream类构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： 1PrintStream ps = new PrintStream(\"ps.txt\")； 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。 12345678910111213141516import java.io.FileNotFoundException;import java.io.PrintStream;public class PrintStreamTest &#123; public static void main(String[] args) throws FileNotFoundException &#123; PrintStream ps = new PrintStream(\"D:/ps.txt\"); // 技巧 : 设置系统的打印流方向 System.setOut(ps); // 输出数据 System.out.println(\"Who are you？\"); System.out.println(\"你是谁？\"); &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"09JavaSE字节流与字符流","slug":"09JavaSE字节流与字符流","date":"2016-11-26T12:03:53.000Z","updated":"2018-08-27T02:22:33.754Z","comments":true,"path":"2016/11/26/09JavaSE字节流与字符流/","link":"","permalink":"htts://cocked.github.io/2016/11/26/09JavaSE字节流与字符流/","excerpt":"","text":"一、IO概述1.1 什么是IO Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 1.2 IO的分类 根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 1.3 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 二、 字节流2.1 一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 2.2 字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.3 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 数据追加续写 public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 写出换行Windows系统里，换行符号是\\r\\n 。把 以指定是否追加续写了，代码使用演示： 回车符\\r和换行符\\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n； Unix系统里，每行结尾只有 换行 ，即\\n； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 2.4 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 2.5 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 三、 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 3.1 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 3.2 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public abstract void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public abstract void flush() ：刷新此输出流并强制任何缓冲的输出字符被写出。 public void write(int c) ：写出一个字符。 public void write(char[] cbuf)：将 b.length字符从指定的字符数组写出此输出流。 public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。 public void write(String str) ：写出一个字符串。 3.4 续写和换行与读取：字符缓冲流代码演示 : 1234// 创建字节缓冲输入流BufferedReader br = new BufferedReader(new FileReader(\"br.txt\", true));// 创建字节缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\", true)); 特有方法 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 notes：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 四、 IO异常的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用 try...catch...finally 代码块，处理异常部分，代码使用演示： 123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class Test6 &#123; public static void main(String[] args) &#123; // 1. 定义一个 writer 对象 BufferedWriter writer = null; try &#123; // 2. 初始化 writer 对象 writer = new BufferedWriter(new FileWriter(\"d.txt\")); // 写入三部曲 : writer.write(\"茄子创意\"); writer.newLine(); writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 关闭 writer 对象 if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;写入结果 :茄子创意 JDK7的处理还可以使用JDK7优化后的try-with-resources 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 1234567891011121314151617181920212223import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class Test6 &#123; public static void main(String[] args) &#123; // () 括号中解决的是 `流` 资源关闭的问题. try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"d.txt\"))) &#123; // 写入三部曲 : writer.write(\"茄子创意\"); writer.newLine(); writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;写出结果 :茄子创意 JDK9的改进(了解内容)JDK9中try-with-resources 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。 改进前格式： 12345678910111213141516171819202122import java.io.*;public class Test7 &#123; public static void main(String[] args) &#123; // () 小括号中定义需要释放的资源对象. try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"D:/1.jpg\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"1.jpg\"))) &#123; // 读写操作 : byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 改进后格式： 123456789101112131415161718192021222324import java.io.*;public class Test7 &#123; public static void main(String[] args) throws FileNotFoundException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"D:/1.jpg\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"1.jpg\")); // () 小括号中定义需要释放的资源对象. try (bis; bos) &#123; // 读写操作 : byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"03JavaSE异常处理","slug":"03JavaSE异常处理","date":"2016-11-01T12:00:59.000Z","updated":"2018-08-27T02:22:23.992Z","comments":true,"path":"2016/11/01/03JavaSE异常处理/","link":"","permalink":"htts://cocked.github.io/2016/11/01/03JavaSE异常处理/","excerpt":"","text":"一、 异常概念总结：练习一：异常的体系 问题： 请描述异常的继承体系 2.请描述你对错误(Error)的理解 3.请描述你对异常(Expection的理解) 4.请描述你对运行时异常(RuntimeException)的理解 答： 异常继承体系为：异常的根类是 java.lang.Throwable，其下有两个子类： java.lang.Error 与 java.util.Exception 。而Exception又分为编译时期异常：checked异常，与运行时期异常：runtime异常。 Error:表示不可修复的恶性的错误，只能通过修改代码规避错误的产生，通常是系统级别的，所以很严重。 3.Exception:表示可修复的良性（相对于错误）的异常，异常产生后程序员可以并且应该通过代码的方式纠正，使程序继续运行，是必须要处理的。 4.运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。 练习二：throw与throws的区别 问题： 请描述throw的使用位置,作用是什么? 请描述throws的使用位置,作用是什么? 答： throw关键字通常用在方法体中，并且抛出一个异常对象。程序在执行到throw语句时立即停止，它后面的语句都不执行。 2.throws关键字通常被应用在声明方法时，用来指定可能抛出的异常。多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会将异常对象抛给方法调用处。 练习三：异常的处理方式 问题： 异常处理方式有几种,分别是什么? 详细阐述每种方式对异常是如何处理的 答： 异常的处理方式有两种,分别是使用throws和try…catch…finally 2.throws用在方法的声明上后接异常类名,是把异常抛给调用者进行处理 3.try…catch…finally是捕获异常,自己处理,处理完毕后面的程序可以继续运行 a)try代码块中是可能出现异常的代码 b)catch代码块,是遇到异常,对异常进行处理的代码 c)finally代码块是无论是否发生异常,都必须执行的代码,用于释放资源. 练习四：常见异常，及产生原因 问题：请列举常见异常，并说明产生原因。 答： NullPointerException:空指针异常。 当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度等等。 ArrayIndexOutOfBoundsException:数组索引越界异常。 当对数组的索引值为负数或大于等于数组大小时抛出此异常。 ArithmeticException:算术运算异常。 程序中出现了除以零这样的运算就会出这样的异常，对这种异常，大家就要好好检查一下自己程序中涉及到数学运算的地方，公式是不是有不妥了。 NumberFormatException:数字格式异常。 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 二.异常 介绍：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理 notes: 异常指的并不是语法错误，语法错误的话 编译不通过，不会产生字节码文件，根本不能运行。 ①异常体系：API： 异常机制其实就是帮助我们找到程序中的问题， 异常的根类是 java.lang.Throwable,下面有两个子类， -java.lang.Error (工程师不能处理，只能尽量避免) -java.util.Exception (由于使用不当导致，可以避免的) 平常所说的异常就是java.util.Exception ②Throwable中的常用方法：⑴打印异常的详细信息 public void printStackTrace(): 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 ⑵获取发生异常的原因 public String getMessage(): 提示给用户的时候,就提示错误原因。 ⑶获取异常的类型和异常描述信息(不用) public String toString(): ​ ③异常的分类 ⑴编译时期的异常:checked异常.在编译时期,就会检查,如果没有处理异常,则编译失败(如日期格式化异常) ⑵运行时期异常:runtime异常.在运行时期,检查异常,在编译时期,运行异常不会编译器检测(不报错)(如数学异常) ​ 三.处理异常五大关键字: try catch finally throw throws ①抛出异常throw⑴格式: throw new 异常类名(参数) ⑵抛出异常告诉调用者 : 步骤1:创建一个异常对象.封装好一些提示信息(信息可以自己编写) throw new NullPointerException(&quot;要访问的arr数组不存在&quot;); 步骤2:告知调用者,通过throw抛出一个异常对象,传递到调用者处,并结束当前方法的执行 例子: public static void main(String[] args) { int[] arr = {2,4,52,2}; int index = 4; int element = getElement(arr, index); System.out.println(&quot;element = &quot; + element); System.out.println(&quot;over&quot;); } private static int getElement(int[] arr, int index) { // 判断 索引是否越界 if (index&lt;0||index&gt;arr.length-1){ // 如果越界 当执行完 throw 抛出异常随心后，方法无法继续运算 // 这时就会结束当前方法的执行，并将异常 告知 调用者 这时就需要通过异常来解决 throw new ArrayIndexOutOfBoundsException(&quot;数组越界&quot;); } int element = arr[index]; return element; } 结果: Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 数组越界l~~~ at DemoThread.ThrowTest.getElement(ThrowTest.java:22) at DemoThread.ThrowTest.main(ThrowTest.java:7) ②Objects非空判断 还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成， 这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的）， 那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static T requireNonNull(T obj):查看指定引用对象不是null。 public static T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } ③声明异常throws 说明: 将问题标识出来,报告给调用者,如果方法内通过throw抛出了编译时异常,而没有捕获处理,那么必须同throws进行声明 让调用者去处理. 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常 格式: 修饰符 返回值类型 方法名(参数) throws 异常类名1 ,异常类名2...{} 例子: public static void main(String[] args) throws FileNotFoundException { read(&quot;a.txt&quot;); } // 如果定义功能时 有问题 发生需要报告给调用者，可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException{ if (!path.equals(&quot;a.txt&quot;)){ // 假设 如果不是a.txt认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); } } ④捕获异常try catch 捕获异常: Java中对异常有针对性的语句进行捕获,可以对出现的异常进行指定方式处理 格式: try{ // 编写可能出现异常的代码 }catch(异常类型 e){ 处理异常的代码 // 可以是记录日志、打印异常信息、继续抛出异常 } try：该代码块中编写可能产生的异常代码 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理 例子： public static void main(String[] args) { try { read(&quot;a12.txt&quot;); }catch (FileNotFoundException e){ // 打印异常 e.printStackTrace(); } System.out.println(&quot;over&quot;); } private static void read(String path) throws FileNotFoundException { if (!path.equals(&quot;a.txt&quot;)){ throw new FileNotFoundException(&quot;文件不存在&quot;); } /* if (!path.equals(&quot;a.txt&quot;)){ throw new IOException(); }*/ } 捕获的异常常用的方法： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 在开发中呢也可以在catch将编译期异常转换成运行期异常处理。 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式， 格式如下： try{ 编写可能会出现异常的代码 }catch(异常类型A e){ 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 }catch(异常类型B e){ 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 } notes： 注意:这种异常处理方式，要求多个catch中的异常不能相同， 并且若catch中的多个异常之间有子父类异常的关系， 那么子类异常要求在上面的catch处理， 父类异常在下面的catch处理 ⑤finally代码块 说明： 有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。 而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 打开一些物理资源（比如磁盘文件/网络链接/数据库链接等）我们都得在使用完之后，最终关闭打开的资源 用法： try catch finally：自身需要处理异常，最终还得关闭资源。 notes： finally不能单独使用。 例子： public static void main(String[] args) { try { read(&quot;a11.txt&quot;); }catch (FileNotFoundException e){ e.printStackTrace(); }finally { System.out.println(&quot;不管怎么样我都要执行&quot;); } System.out.println(&quot;over&quot;); } private static void read(String path) throws FileNotFoundException { if (!path.equals(&quot;a.txt&quot;)){ throw new FileNotFoundException(&quot;文件不存在！&quot;); } } tips: 只有在try或者catch中调用退出JVM的相关方法时，此时finally才不会执行，否则finally用远会执行 结果： 不管怎么样我都要执行 java.io.FileNotFoundException: 文件不存在！ over at DemoThread.finallyTest01.read(finallyTest01.java:19) at DemoThread.finallyTest01.main(finallyTest01.java:8) ⑥异常注意事项 ⑴运行时期异常被 抛出可以不处理，既不捕获也不声明抛出 ⑵如果父类抛出多个异常，子类覆盖父类方法时，只能抛出相同的异常或者他的子集 ⑶父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常，此时子类产生该异常，只能捕获处理，不能声明抛出 ⑷当多异常处理时，捕获处理，前边的类不能时后边类的父类 ⑸当try/catch后可以主机finally代码块，其中的代码一定会被执行，通常用于资源回收 ⑹如果finally有return语句，永远返回finally中的结果，避免该情况 四、自定义异常123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 说明： 为什么需要自定义异常类: Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: LoginException。一个登陆异常类。 异常类如何定义: 1. 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 2. 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException 例子： public class DiyETest &#123; private static String[] names= &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; // 模拟登录 try&#123; // 可能出现异常的代码 checkUsername(\"bill\"); // 如果没有就是注册成功 System.out.println(\"注册成功\"); &#125;catch (LoginException e)&#123; e.printStackTrace(); &#125; &#125; private static boolean checkUsername(String uname) throws LoginException &#123; for (String name:names)&#123; if (name.equals(uname))&#123; // 如果名字在其中 则抛出 登录异常 throw new LoginException(\"禁止登录\"); &#125; &#125; return true; &#125; &#125; class LoginException extends Exception&#123; public LoginException() &#123; &#125; /** * * @param name 表示异常提示 */ public LoginException(String name)&#123; super(name); &#125; &#125;","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"02JavaSE基本语法总结","slug":"02JavaSE基本语法总结","date":"2016-10-26T11:59:02.000Z","updated":"2018-08-27T02:22:13.192Z","comments":true,"path":"2016/10/26/02JavaSE基本语法总结/","link":"","permalink":"htts://cocked.github.io/2016/10/26/02JavaSE基本语法总结/","excerpt":"","text":"一、StringBuffer1.类介绍1234①线程安全的可变字符串序列，一个类似于String的字符串缓冲区，但是不能修改（就是不能通过加号+连接，String就可以）②StringBuffer和String类的区别 String是一个可改变的字符序列 StringBuffer是一个可变的字符序列 2.构造方法12345StringBuffer() 构造一个没有字符的字符串缓冲区，初始容量为16个字符StringBuffer(int capacity) 构造一个没有字符的字符串缓冲区和指定初始容量StringBuffer(CharSequence seq) 构造一个字符串缓冲区,其中包含与指定的 CharSequence相同的字符。StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。 Notes：从jdk5开始,为该类补充了一个单个线程使用的等价类,即StringBuilder类,通常优先使用StringBuilder类,因为他支持所有相同操作,但是由于它不执行同步,所有速度更快 3.增删,替换翻转,截取()123456789101112131415161718StringBuffer sb = new StringBuffer(&quot;abcd&quot;);①添加sb.append(&quot;str12&quot;); //在末尾添加一个字符串sb.insert(3,&quot;hhh&quot;); //在指定位置添加指定字符串②删除sb.deleteCharAt(3); //删除指定1位置的字符 并返回本身sb.delete(1,3); //左闭右开③清空缓冲区sb.delete(0,sb.length());④替换sb.replace(0,3,&quot;bai&quot;) // 包含头不包含尾⑤翻转sb.reverse();⑥截取sb.substring(int start) //从指定位置截取到末尾sb.substring(int start,int end) //从指定位置开始到结束位置，包括开始位置，不包括结束位置// 截取 返回值不再是StringBuffer而是String 4.StringBuffer –&gt; String1234567891011121314151617181920String --》 StringBuffer a.通过构造方法 StringBuffer stringBuffer = new StringBuffer(&quot;woai&quot;); System.out.println(stringBuffer); // 通过构造方法完成转换成String b.通过append()方法 StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;woai&quot;); System.out.println(stringBuffer); // 通过append()方法完成转换成StringStringBuffer --》 String StringBuffer sb = new StringBuffer(&quot;woai1&quot;); a.通过构造方法 String s = new String(sb); // 通过构造方法 System.out.println(s); b.通过toString()方法 String string = sb.toString(); //通过toString()方法 System.out.println(&quot;string = &quot; + string); c.通过subString(0,length); String substring = sb.substring(0, sb.length()); System.out.println(substring); 5.数组 –&gt; 字符串12345678910111213141516举例： int [] arr = &#123;1,2,3,&#125;; 输出结果: &quot;[1,2,3]&quot; 用StringBuff的功能实现： int[] arr = &#123;1, 2, 3&#125;; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; stringBuffer.append(arr[i]).append(&quot;]&quot;); // 使用这样的添加方式会减少垃圾的存在 &#125;else &#123; stringBuffer.append(arr[i]).append(&quot;,&quot;); &#125; &#125; System.out.println(stringBuffer); 6.字符串翻转1通过StringBuffer进行翻转 7.StringBuffer和StringBuilder区别123456StringBuffer是jdk1.0版本的，是线程安全的，效率低的 (对于用户访问量大的bat 保证其稳定性，对于金融要求，保证其稳定，其他都不存在) StringBuilder是jdk1.5版本的，是线程不安全的，效率高的 String和StringBuffer，StringBuilder的区别 String是一个不可变的字符序列 StringBuffer，StringBuilder是可变的字符序列 8.String和StringBuffer作为参数传递123456789101112基本数据类型的值传递，不改变其值引用数据类型的值传递，改变其值 // 因为传递的是内存地址，String s = &quot;heihei&quot;; System.out.println(s); change(s); System.out.println(s); // heihei System.out.println(&quot;------------------&quot;); StringBuffer sb = new StringBuffer(); sb.append(&quot;hhhhhh&quot;); change(sb); System.out.println(&quot;sb = &quot; + sb); // heiheihhhhhh 9.数组-冒泡,选择,二分排序12345(1)冒泡 // 数据元素：&#123;24,69,80,57,13&#125; 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处(2)选择(3)二分排序 10.Arrays类12 11.Interger类12 12.String –&gt; int12 13.Interger面试题12 二、正则表达式1234567891011121314151617181920212223241.概述和简单使用 * [abc] a,b或c(简单类) * [^abc] 任何字符,除了a,b,或c (否定) * [a-zA-Z] a到 z 或 A 到 Z, 两头的字母包括在内（范围） * [a-d[m-p]] a到 d 或 m到p ; [a-dm-p] (并集) * [a-z&amp;&amp;[def]] d,e,或 f (交集) * [a-z&amp;&amp;[^bc]] a 到 z ，除了b和c; [ad-z](减去) * [a-z&amp;&amp;[^m-p]] a 到 z 而非 m 到 p; [a-lq-z](减去) 2.预定义字符类 \\d 数字:[0-9] \\D 非数字:[^0-9] \\s 空白字符:[\\t\\n\\x0B\\f\\r] \\S 非空白字符:[^\\s] \\w 单词字符:[a-zA-Z_0-9] \\W 非单词字符：[^\\w] 3.常见对象(数量词) X? X,一次或一次也没有 X* X,零次或多次 X+ X,一次或多次 X&#123;n&#125; X,恰好n次 X&#123;n,&#125; X,至少n次 X&#123;n,m&#125; X,至少n次,但是不超过m次 ​ 二、Collection三、List四、Set五、Map1********** 总结 ************* 1Collection 12345678910111213141516171819* List (存取有序，有索引，可以重复) -ArrayList 底层是数组实现的，线程不安全，查找和修改快，增和删比较慢 -LinkedList 底层是链表实现的，线程不安全，增删快，查找和修改比较慢 -Vector 底层是数组实现的，线程安全，无论增删 查找都慢 notes： 如果查找和修改多，用ArrayList 如果增和删多，用LinkedList 如果都多，用ArrayList* Set (存取无序，无需索引，不可以重复) -HashSet 底层是哈希算法实现的 LinkedHashSet 底层是链表实现，但是也可以保证元素的唯一性，和HasSet原理一样 -TreeSet 底层是二叉树算法实现的 12345678910111213141516 notes： 一般在开发的时候不需要对存储的元素排序，所以在开发的时候大多用HashSet , HashSet的效率比较高 TreeSet在面试的时候比较多，问你有几种排序方式，和几种排序方式的区别。* Map HashMap 底层是哈希算法，针对键 LinkedHashMap 底层是链表，针对键 TreeMap 底层是二叉树算法，针对键 notes： 开发中用HashMap比较多 六、异常&amp;IO(文件类)123456789101112131415161718192021222324252627282930311.异常概述和分类 *概述 是java程序在运行过程中出现的错误 *分类 通过API可以查看Throwable 有两个子类error 和exception error 服务器宕机，数据库崩溃 Exception *RuntimeException 运行时异常2.异常(关于finally关键字的面试题) A.final , finally 和 finalize的区别 B.如果catch里面有return 语句请问finally的代码还会执行吗? 如果会是在return前还是后3.自定义异常 继承Exception 编译时异常 继承RuntimeException 运行时异常 4.异常的注意事项及使用异常处理 A:注意事项 a.子类重写父类的方法时,子类的方法必须抛出相同的异常或父类异常的子类. b.如果父类抛出多个异常,子类重写父类时,只能抛出相同的异常或者时他的子集,子集不能抛出父类没有的异常 c.如果被重写的方法没有异常抛出，那么子类的方法绝不可以抛出异常，如果子类方法内有异常发生，那么子类只能try，不能throws B:如何使用异常处理 原则：如果该功能的内部可以将问题处理，就用try ，如果处理不了，交由调用者处理，这里用throws 区别： *后续程序需要继续运行就try *后续程序不需要运行就throws *如果JDK没有提供对应的异常，需要自定义异常","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"01JavaSE入门基础总结","slug":"01JavaSE入门基础总结","date":"2016-10-20T13:00:18.000Z","updated":"2018-08-27T02:22:03.132Z","comments":true,"path":"2016/10/20/01JavaSE入门基础总结/","link":"","permalink":"htts://cocked.github.io/2016/10/20/01JavaSE入门基础总结/","excerpt":"","text":"一、String介绍(引用类型) 123456789101112131415161718192021222324252627282930313233343536373839404142434445461.java.lang.String字符串. 用&quot;&quot;括住的时字符串,都可以看做是实现此类的实例 类String中也有许多简单方法2.特点 1).字符串不变:字符串的值在创建后不能被更改 2).因为String对象不可改变.所有他们可以被共享 3).(底层是这么实现的)对String s1 赋值 &quot;abc&quot; 等效于char[] data = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]3.构造举例(面试可能会问，)// 无参构造String str = new String();// 通过字符数组构造char chars[] = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;String str2 = new String(chars);// 通过字节数组构造byte b[] = &#123;97,98,99&#125;;String str3 = new String(b);4.字符串的比较（面试的时候会问，结合String进行理解） 1. == 比较 1.对基本类型 这个东西 可以 比较基本类型 四类八种 （比较的是值是否相等） 2.对引用类型进行比较时， 则比较地址值 2.equals(String str) 内容相同 ，返回true 5.String 方法（1）获取equalsIgnoreCase(String str) 忽略大小写比较内容int length() 返回字符串长度String concat 将指定的字符串连接到该字符串的末尾char charAt(int index) 返回指定索引处的char值int indexOf(String str) 返回指定字符串第一次出现该字符串的位置(索引) 找到了就是对应的首次出现的索引，找不到就返回-1String substring (int beginIndex) 返回一个字符串，从beginIndex开始截取字符串到最后String substring (int beginIndex, int endIndex) 返回一个字符串，从beginIndex开始截取字符串到endIndex截取字符串。 含beg 不含 end 12345678910111213141516171819（2）转换1.String replace()ex: String str = &quot;abbccd&quot; String newstr = str.replace(&apos;b&apos;,&apos;*&apos;) System.out.println(newstr) a**ccd 此处将含有b的全部替换成*了 String newstr = str.replace(&quot;bb&quot;,&quot;*&quot;) 运行结果为a*ccd2.char [] chars = toCharArray()转成字符数组 3. byte[] getByte();使用平台默认的字符集将该String编码新的字节数组.4. String[] split(String regex) &quot;&quot;\\\\.&quot;表示.转义一下 以 regex对字符串进行分割 二、StringBuffer 123456789101.类介绍 ①线程安全的可变字符串序列，一个类似于String的字符串缓冲区，但是不能修改（就是不能通过加号+连接，String就可以） ②StringBuffer和String类的区别 String是一个可改变的字符序列 StringBuffer是一个可变的字符序列2.构造方法 StringBuffer() 构造一个没有字符的字符串缓冲区，初始容量为16个字符 StringBuffer(int capacity) 构造一个没有字符的字符串缓冲区和指定初始容量 StringBuffer(CharSequence seq) 构造一个字符串缓冲区,其中包含与指定的 CharSequence相同的字符。 StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 notes: 从jdk5开始,为该类补充了一个单个线程使用的等价类,即StringBuilder类,通常优先使用StringBuilder类,因为他支持所有相同操作,但是由于它不执行同步,所有速度更快3.增删,替换翻转,截取() StringBuffer sb = new StringBuffer(&quot;abcd&quot;); ①添加 sb.append(&quot;str12&quot;); //在末尾添加一个字符串 sb.insert(3,&quot;hhh&quot;); //在指定位置添加指定字符串 ②删除 sb.deleteCharAt(3); //删除指定1位置的字符 并返回本身 sb.delete(1,3); //左闭右开 ③清空缓冲区 sb.delete(0,sb.length()); ④替换 sb.replace(0,3,&quot;bai&quot;) // 包含头不包含尾 ⑤翻转 sb.reverse(); ⑥截取 sb.substring(int start) //从指定位置截取到末尾 sb.substring(int start,int end) //从指定位置开始到结束位置，包括开始位置，不包括结束位置 // 截取 返回值不再是StringBuffer而是String4.StringBuffer --&gt; String String --》 StringBuffer a.通过构造方法 StringBuffer stringBuffer = new StringBuffer(&quot;woai&quot;); System.out.println(stringBuffer); // 通过构造方法完成转换成String b.通过append()方法 StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;woai&quot;); System.out.println(stringBuffer); // 通过append()方法完成转换成String StringBuffer --》 String StringBuffer sb = new StringBuffer(&quot;woai1&quot;); a.通过构造方法 String s = new String(sb); // 通过构造方法 System.out.println(s); b.通过toString()方法 String string = sb.toString(); //通过toString()方法 System.out.println(&quot;string = &quot; + string); c.通过subString(0,length); String substring = sb.substring(0, sb.length()); System.out.println(substring); 5.数组 --&gt; 字符串 举例： int [] arr = &#123;1,2,3,&#125;; 输出结果: &quot;[1,2,3]&quot; 用StringBuff的功能实现： int[] arr = &#123;1, 2, 3&#125;; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; stringBuffer.append(arr[i]).append(&quot;]&quot;); // 使用这样的添加方式会减少垃圾的存在 &#125;else &#123; stringBuffer.append(arr[i]).append(&quot;,&quot;); &#125; &#125; System.out.println(stringBuffer);6.字符串翻转 通过StringBuffer进行翻转 7.StringBuffer和StringBuilder区别 StringBuffer是jdk1.0版本的，是线程安全的，效率低的 (对于用户访问量大的bat 保证其稳定性，对于金融要求，保证其稳定，其他都不存在) StringBuilder是jdk1.5版本的，是线程不安全的，效率高的 String和StringBuffer，StringBuilder的区别 String是一个不可变的字符序列 StringBuffer，StringBuilder是可变的字符序列8.String和StringBuffer作为参数传递 基本数据类型的值传递，不改变其值 引用数据类型的值传递，改变其值 // 因为传递的是内存地址， String s = &quot;heihei&quot;; System.out.println(s); change(s); System.out.println(s); // heihei 1System.out.println(&quot;------------------&quot;); 1234StringBuffer sb = new StringBuffer();sb.append(&quot;hhhhhh&quot;);change(sb);System.out.println(&quot;sb = &quot; + sb); // heiheihhhhhh 123456789109.数组-冒泡,选择,二分排序 (1)冒泡 // 数据元素：&#123;24,69,80,57,13&#125; 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处 (2)选择 (3)二分排序10.Arrays类11.Interger类12.String --&gt; int13.Interger面试题 ​三、StringBuffer的构造方法： 123456789101112131415161718192021222324252627282930* public StringBuffer():无参构造方法* public StringBuffer(int capacity) 指定容量的字符串缓冲区对象* public StringBuffer(String str) 指定字符串内容的字符串缓冲区对象StringBuffer sb = new StringBuffer()sb.append(&quot;&quot;)sb.insert(int offset , String str)// // 在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串本身// 在new的时候是在堆内存中创建了一个对象，底层是一个长度为16的字符数组，当调用添加方法时，不会再重新创建对象，在不断向原缓冲区添加zifusb.deleteCharAt(4) // 根据索引删除索引位置上对应的字符sb.detel(0,2) // 删除的时候包含头不包含尾sb.detel(0,sb.length()) // 情况缓冲区sb.replace(0,3,&quot;bai&quot;) // 替换 替换指定区域的字符sb.reverse() // 翻转sb.substring() // 截取sb.reverse() // 翻转String --&gt; StringBuffer //通过构造方法 //和 append 将 字符串 转换为 StringBuffer对象 StringBuffer sb = new StringBuffer(&quot;heima&quot;) StringBuffer --&gt; String // 通过构造方法 // 通过toString()方法 // 通过subString(0,length)StringBuffer和StrinBuilder的区别： 四、Arrays 1java.util.Arrays(操作数组的各种方法,如排序和搜索) 121.sort 排序 直接打印 无返回值2. 五、Math 1234java.lang.Math 类包含用于基本数学运算方法,如初等指数,对数,平方根和三角函数其所有方法为静态方法，并且不会创建对象，调用起来非常简单。1.abs 12345Math.sqrt()//计算平方根Math.cbrt()//计算立方根Math.pow(a, b)//计算a的b次方Math.max( , );//计算最大值Math.min( , );//计算最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364System.out.println(Math.sqrt(16)); //4.0 System.out.println(Math.cbrt(8)); //2.0System.out.println(Math.pow(3,2)); //9.0System.out.println(Math.max(2.3,4.5));//4.5System.out.println(Math.min(2.3,4.5));//2.3/** * abs求绝对值 */ System.out.println(Math.abs(-10.4)); //10.4 System.out.println(Math.abs(10.1)); //10.1 /** * ceil天花板的意思，就是返回大的值 */ System.out.println(Math.ceil(-10.1)); //-10.0 System.out.println(Math.ceil(10.7)); //11.0 System.out.println(Math.ceil(-0.7)); //-0.0 System.out.println(Math.ceil(0.0)); //0.0 System.out.println(Math.ceil(-0.0)); //-0.0 System.out.println(Math.ceil(-1.7)); //-1.0/** * floor地板的意思，就是返回小的值 */ System.out.println(Math.floor(-10.1)); //-11.0 System.out.println(Math.floor(10.7)); //10.0 System.out.println(Math.floor(-0.7)); //-1.0 System.out.println(Math.floor(0.0)); //0.0 System.out.println(Math.floor(-0.0)); //-0.0 /** * random 取得一个大于或者等于0.0小于不等于1.0的随机数 */ System.out.println(Math.random()); //小于1大于0的double类型的数System.out.println(Math.random()*2);//大于0小于1的double类型的数System.out.println(Math.random()*2+1);//大于1小于2的double类型的数/** * rint 四舍五入，返回double值 * 注意.5的时候会取偶数 异常的尴尬=。= */ System.out.println(Math.rint(10.1)); //10.0 System.out.println(Math.rint(10.7)); //11.0 System.out.println(Math.rint(11.5)); //12.0 System.out.println(Math.rint(10.5)); //10.0 System.out.println(Math.rint(10.51)); //11.0 System.out.println(Math.rint(-10.5)); //-10.0 System.out.println(Math.rint(-11.5)); //-12.0 System.out.println(Math.rint(-10.51)); //-11.0 System.out.println(Math.rint(-10.6)); //-11.0 System.out.println(Math.rint(-10.2)); //-10.0 /** * round 四舍五入，float时返回int值，double时返回long值 */ System.out.println(Math.round(10.1)); //10 System.out.println(Math.round(10.7)); //11 System.out.println(Math.round(10.5)); //11 System.out.println(Math.round(10.51)); //11 System.out.println(Math.round(-10.5)); //-10 System.out.println(Math.round(-10.51)); //-11 System.out.println(Math.round(-10.6)); //-11 System.out.println(Math.round(-10.2)); //-10 六、static(在方法区有一块固定的存储区域,由于优先于对象存在,所以可以被所有对象共享)​ 1234567891011121314在定义方法的时候你写main方法的类加static,写普通类的写方法的时候就不要加static1.static可以用来修饰成员变量和成员方法，被修饰的成员属于类，而不是单单属于某个对象，也就是说，既然属于类，就可以不靠创建对象来调用了进一步介绍： 修饰成员变量 当static修饰成员变量时，该变量称为类变量，该类的每个对象都共享同一个类变量的值，任何对象都可以更改 该变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作 类名.类变量 类名.静态方法名(参数); 1修饰成员方法 (静态方法可以访问静态变量,不能访问普通的变量) 12345类名.方法() 推荐对象名.方法名() 麻烦特点静态方法只能访问静态内容(成员变量,静态成员方法) ​​ 1234notes: 静态方法 可以直接访问 静态变量和 静态方法. 静态方法 不能直接访问 普通成员变量 或 成员方法,反之成员方法可以直接访问静态变量或静态方法 静态方法 不能使用this关键字 ​七、静态代码块(想在main方法之前执行,可以给静态成员变量赋值) 12345678910静态代码块：定义成员位置，使用static修饰代码块()位置:类方法外执行:随着类的加载而执行且执行一次,优先于main方法构造和构造方法执行格式: public class ClassName&#123; static&#123; // &#125; &#125; ​ JAVA中分为基本数据类型和引用数据类型区别一、基本数据类型： byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0 char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0 boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false 二、引用数据类型： 类、接口类型、数组类型、枚举类型、注解类型。 区别： 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 例如，有一个类Person,有属性name,age,带有参的构造方法， Person p = new Person(“zhangsan”,20); 在内存中的具体创建过程是： 1.首先在栈内存中位其p分配一块空间; 2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值””，0； 3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作； 4.调用构造方法，为两个属性赋值为”Tom”,20；（注意这个时候p与Person对象之间还没有建立联系）； 5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。 相关知识： 静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。 堆区： 一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错 栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限 文字常量区： 常量字符串就是放在这里的。 程序结束后由系统释放。","categories":[],"tags":[{"name":"javaSE","slug":"javaSE","permalink":"htts://cocked.github.io/tags/javaSE/"}]},{"title":"第一篇博客","slug":"第一篇博客","date":"2016-05-18T23:12:27.000Z","updated":"2018-08-27T02:28:31.098Z","comments":true,"path":"2016/05/19/第一篇博客/","link":"","permalink":"htts://cocked.github.io/2016/05/19/第一篇博客/","excerpt":"","text":"#第一篇博客​ ##费尽周折终于将自己的博客上线， ​ 在这里 ，在我对hexo熟悉之后，将会不定期的更新我的博客主要关于Java，以及java中遇到的问题，也有可能分享生活， ​ ##以后补充： ​ ##之前的博客： ​ 博客园：https://www.cnblogs.com/zhengyuan/ ​ CSDN：https://blog.csdn.net/A_Eric ​ GitHub：https://github.com/cocked ​ ##git上的博客页面参照大佬的： ​ 参照大佬的博客:https://github.com/iTimeTraveler/hexo-theme-hiker","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"htts://cocked.github.io/tags/blog/"}]}]}