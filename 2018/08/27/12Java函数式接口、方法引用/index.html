<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>12java函数式接口、方法引用 | Francis的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="javaSE" />
  
  
  
  
  <meta name="description" content="12.1  函数式接口12.1.1 概念1.函数式接口在Java中是指：有且仅有一个抽象方法的接口。 2.函数式接口，即适用于函数式编程场景的接口，而Java中的函数式编程体现就是Lambda，所有函数式接口就是可以适用于Lamnda使用的接口，只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。 3、语法糖的定义：是指使用更加方便，但是原理不变的代码语法，例如在遍历集">
<meta name="keywords" content="javaSE">
<meta property="og:type" content="article">
<meta property="og:title" content="12Java函数式接口、方法引用">
<meta property="og:url" content="htts://cocked.github.io/2018/08/27/12Java函数式接口、方法引用/index.html">
<meta property="og:site_name" content="Francis的个人博客">
<meta property="og:description" content="12.1  函数式接口12.1.1 概念1.函数式接口在Java中是指：有且仅有一个抽象方法的接口。 2.函数式接口，即适用于函数式编程场景的接口，而Java中的函数式编程体现就是Lambda，所有函数式接口就是可以适用于Lamnda使用的接口，只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。 3、语法糖的定义：是指使用更加方便，但是原理不变的代码语法，例如在遍历集">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-08-27T02:56:04.009Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="12Java函数式接口、方法引用">
<meta name="twitter:description" content="12.1  函数式接口12.1.1 概念1.函数式接口在Java中是指：有且仅有一个抽象方法的接口。 2.函数式接口，即适用于函数式编程场景的接口，而Java中的函数式编程体现就是Lambda，所有函数式接口就是可以适用于Lamnda使用的接口，只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。 3、语法糖的定义：是指使用更加方便，但是原理不变的代码语法，例如在遍历集">
  
    <link rel="alternate" href="/atom.xml" title="Francis的个人博客" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-12Java函数式接口、方法引用" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      12Java函数式接口、方法引用
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/08/27/12Java函数式接口、方法引用/" class="article-date">
	  <time datetime="2018-08-27T02:31:37.928Z" itemprop="datePublished">2018-08-27</time>
	</a>

      
      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="12-1-函数式接口"><a href="#12-1-函数式接口" class="headerlink" title="12.1  函数式接口"></a>12.1  函数式接口</h1><h2 id="12-1-1-概念"><a href="#12-1-1-概念" class="headerlink" title="12.1.1 概念"></a>12.1.1 概念</h2><p>1.函数式接口在Java中是指：有且仅有一个抽象方法的接口。</p>
<p>2.函数式接口，即适用于函数式编程场景的接口，而Java中的函数式编程体现就是Lambda，所有函数式接口就是可以适用于Lamnda使用的接口，只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。</p>
<p>3、语法糖的定义：是指使用更加方便，但是原理不变的代码语法，例如在遍历集合时使用的for-each语法，其实底层的实现原理 仍然是迭代器，这就是<strong>语法糖</strong>，从应用层讲， java中的Lambda可以被当做是匿名内部类的语法糖，但是二者原理上不同的</p>
<p>4.<strong>复习之前Lambda的使用要求，</strong></p>
<p><strong>使用条件1</strong>：必须拥有函数式接口，（java语言中已经提供了很多函数式接口）</p>
<p>使用条件2：调用的方法必须拥有函数式接口作为方法的参数，（Java语言已经提供了很多方法，这些方法的参数都是函数式接口）</p>
<h2 id="12-1-2-格式"><a href="#12-1-2-格式" class="headerlink" title="12.1.2 格式"></a>12.1.2 格式</h2><p>只要确保接口中有且仅有一个抽象方法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于接口当中抽象方法的public abstract是可以省略的，所以定义一个函数式接口很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-1-3-FunctionalInterface注解"><a href="#12-1-3-FunctionalInterface注解" class="headerlink" title="12.1.3 @FunctionalInterface注解"></a>12.1.3 @FunctionalInterface注解</h2><p>与@Override注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。该注解可用于一个接口的定义上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数式接口注解 : 该接口仅能拥有一个抽象方法</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法定义 :</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>notes：</strong>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样</p>
<h1 id="12-2-函数式编程"><a href="#12-2-函数式编程" class="headerlink" title="12.2  函数式编程"></a>12.2  函数式编程</h1><h2 id="12-2-1-Lambda-的延时执行"><a href="#12-2-1-Lambda-的延时执行" class="headerlink" title="12.2.1 Lambda 的延时执行"></a>12.2.1 Lambda 的延时执行</h2><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。</p>
<p><strong>性能浪费的日志案例</strong></p>
<p>一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"World"</span>;</span><br><span class="line">        String s3 = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        log(<span class="number">0</span>, s1 + s2 + s3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 :</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line">    说明 : 如果 level 不为 <span class="number">1</span>, 则没有任何输出结果.</span><br><span class="line">    说明 : 如果 level 为 <span class="number">1</span>, 输出结果如下 :</span><br><span class="line">    HelloWorldJava</span><br></pre></td></tr></table></figure>
<p><strong>notes</strong>：这段代码存在问题：无论级别是否满足要求，作为log方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p>
<p><strong>体验Lambda的优化写法</strong></p>
<p>使用Lambda必然需要一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function">String <span class="title">buildMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后对log方法进行改造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"World"</span>;</span><br><span class="line">        String s3 = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法 :</span></span><br><span class="line">        log(<span class="number">1</span>, () -&gt; s1 + s2 + s3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 :</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder messageBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            String result = messageBuilder.buildMsg();</span><br><span class="line">            System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果 :</span><br><span class="line">result = HelloWorldJava</span><br></pre></td></tr></table></figure>
<p><strong>noets：</strong>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。</p>
<p>扩展<strong>：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</strong></p>
<p><strong>除此之外Lambda还可作为参数和返回值</strong></p>
<h2 id="12-2-2-使用函数式接口作为参数"><a href="#12-2-2-使用函数式接口作为参数" class="headerlink" title="12.2.2 使用函数式接口作为参数"></a>12.2.2 使用函数式接口作为参数</h2><p> <strong>    例子：</strong>自定义一个函数是<strong>接口</strong>MyFunctionalInterface，里面有且仅有一个<strong>抽象方法v</strong>oid myMethod()。来说明使用函数式接口作为参数</p>
<pre><code>思路历程：

      **  Lambda表达式实现               **         

        **思考1**，接口MyFunctionalInterface中的抽象方法长什么样（有无参数，有无返回值），

        **思考2**，Lambda的表达式的各个部分是什么样的 （） -&gt; {} 

      ()  其中这里面放的是参数列表，一定要和函数式接口中的抽象放的参数列表保持一致

      {} 方法的实现题部分        一定要和函数式接口中的抽象方法的返回值保持一致

        开始写代码：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFunctionalInterfaceTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点 : 调用方法, 传递 Lambda 表达式作为函数式接口的实际参数</span></span><br><span class="line">        <span class="comment">// 思考 : MyFunctionalInterface 函数式接口中的抽象方法长什么样 ???   void myMethod();</span></span><br><span class="line">        <span class="comment">// () 小括号 : 函数式接口抽象方法的参数列表.</span></span><br><span class="line">        <span class="comment">// &#123;&#125; 大括号 : 函数式接口抽象方法的方法实现体.</span></span><br><span class="line">        <span class="comment">// Lambda 表达式的标准格式 :</span></span><br><span class="line">        doSomething(() -&gt; &#123; System.out.println(<span class="string">"Lambda 表达式被执行 ..."</span>); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lambda 表达式的省略格式 :</span></span><br><span class="line">        doSomething(() -&gt; System.out.println(<span class="string">"Lambda 表达式被执行 ..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法, 使用函数式接口作为方法的参数列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(MyFunctionalInterface inter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处为 Lambda 表达式代码的调用</span></span><br><span class="line">        inter.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Lambda 表达式书写的前提要求 :  (传递 Lambda 表达式作为方法的参数就是重要)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1. 必须要有 `函数式接口`. (自动推导)                         (Java提供)</span></span><br><span class="line"><span class="comment">    2. 必须有方法使用 `函数式接口` 作为方法的参数列表.            (Java提供)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请问 : 如何让编译器该接口是否为函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法 : 无参无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-2-3-使用函数式接口作为返回值"><a href="#12-2-3-使用函数式接口作为返回值" class="headerlink" title="12.2.3 使用函数式接口作为返回值"></a>12.2.3 使用函数式接口作为返回值</h2><p><strong>例子：</strong>自定义一个MySupplier函数式接口，无参有返回值，里面<strong>有且仅有一个</strong>方法Object getData();来说明函数式接口作为返回值</p>
<p> <strong>  思路历程：</strong></p>
<pre><code>1.函数式接口中的抽象方法是什么样子的（Object getData()） 其中 抽象方式是没有参数，但是是有返回值的，返回值类型是 Object，

 1. Lambda 的格式按照需求应该怎么写

       ()中不需要写任何参数列表

       {} 中有返回值 加return 书写要实现的方法。

        **开始写代码**
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySupplierTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="comment">// 思考 : 看一下 MySupplier 的抽象方法长什么样 ???        Object data();</span></span><br><span class="line">        printData(() -&gt; &#123; <span class="keyword">return</span> <span class="string">"Hello ShangHai, I Love you."</span>; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        MySupplier mySupplier = getDataFromLambda();</span><br><span class="line">        <span class="comment">// 请问 : 如何取出数据 ??? 调用函数式接口中的方法, 来获取数据</span></span><br><span class="line">        Object data = mySupplier.getData();</span><br><span class="line">        System.out.println(<span class="string">"data = "</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 : 将函数式接口作为方法的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printData</span><span class="params">(MySupplier mySupplier)</span> </span>&#123;</span><br><span class="line">        Object data = mySupplier.getData();</span><br><span class="line">        System.out.println(<span class="string">"data = "</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 : 将函数式接口作为方法的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySupplier <span class="title">getDataFromLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何实现 : 返回一个 Lambda 表达式       Object getData();</span></span><br><span class="line">        <span class="comment">// return () -&gt; &#123; return "你爱北京长城."; &#125;;</span></span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="string">"你爱北京长城."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MySupplier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法 : 无参, 有返回值</span></span><br><span class="line">    <span class="function">Object <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="12-3-方法引用"><a href="#12-3-方法引用" class="headerlink" title="12.3  方法引用"></a>12.3  方法引用</h1><pre><code> **概述** : 什么是方法引用呢 ??? 其实就是 Lambda 表达式的孪生兄弟. 也可以理解为引用一个已经实现了 Lambda 表达式相同功能的方法.

** 格式** : 对象::对象方法 System.out::println
</code></pre><h2 id="12-3-2-冗余的Lambda场景"><a href="#12-3-2-冗余的Lambda场景" class="headerlink" title="12.3.2 冗余的Lambda场景"></a>12.3.2 冗余的Lambda场景</h2><p>看一个简单的函数式接口以应用Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在Printable接口当中唯一的抽象方法print接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法 :</span></span><br><span class="line">        printString(<span class="string">"Hello beijing, 你好, 北京."</span>, s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 :</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(String str, Printable&lt;String&gt; printable)</span> </span>&#123;</span><br><span class="line">        printable.print(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">    Hello beijing, 你好, 北京.</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是System.out对象中的println(String)方法。既然Lambda希望做的事情就是调用println(String)方法，那何必自己手动调用呢？这时候引入了其孪生兄弟， 方法引用：</p>
<p><strong>    改进之后的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法 : Lambda 表达式</span></span><br><span class="line">        printString(<span class="string">"Hello beijing, 你好, 北京."</span>, s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法 : 方法引用 -&gt; 对象引用对象方法</span></span><br><span class="line">        PrintStream ps = System.out;</span><br><span class="line">        printString(<span class="string">"Hello beijing, 你好, 北京."</span>, ps::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法 : 简化格式</span></span><br><span class="line">        printString(<span class="string">"Hello beijing, 你好, 北京."</span>, System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 :</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(String str, Printable&lt;String&gt; printable)</span> </span>&#123;</span><br><span class="line">        printable.print(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果 :</span><br><span class="line">    Hello beijing, 你好, 北京.</span><br><span class="line">    Hello beijing, 你好, 北京.</span><br><span class="line">    Hello beijing, 你好, 北京.</span><br></pre></td></tr></table></figure>
<p><strong>notes：</strong></p>
<p>注意其中的双冒号::写法，这被称为“方法引用”，而双冒号是一种新的语法。**</p>
<h2 id="12-3-3-方法引用符"><a href="#12-3-3-方法引用符" class="headerlink" title="12.3.3 方法引用符"></a>12.3.3 方法引用符</h2><p>双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p>
<p>*语义分析**</p>
<p>例如上例中，System.out对象中有一个重载的println(String)方法恰好就是我们所需要的。那么对于printString方法的函数式接口参数，对比下面两种写法，完全等效：</p>
<p>Lambda表达式写法：s -&gt; System.out.println(s);</p>
<p>方法引用写法：System.out::println</p>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给System.out.println方法去处理。</p>
<p>第二种等效写法的语义是指：直接让System.out中的println方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<p>推导与省略**</p>
<p>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。</p>
<p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。</p>
<h2 id="12-3-4-通过对象名引用成员方法"><a href="#12-3-4-通过对象名引用成员方法" class="headerlink" title="12.3.4 通过对象名引用成员方法"></a>12.3.4 通过对象名引用成员方法</h2><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p>
<p>思路历程：</p>
<p>1.接口Printable 中的抽象方法 void print(T t)  有参数 未指定类型，无返回值 </p>
<p>printString(“Hello World. 你好, 世界!”, s -&gt; System.out.println(s));</p>
<p>2，上面传递的Lambda 表达式 （s -&gt; System.out,println(s) ）的实现效果与 Sysetm.out 对象的println 方法实现一致</p>
<p>​    既然效果一样，那么Lambda表达式可不可以不写了，直接引用别人的方法。</p>
<p>​    方法引用的条件：引用的方法必须与函数式中的抽象方法匹配，（参数类型和返回值需要保持一致）</p>
<p>​    // Printable : void print(T t); System.out 对象的 void println(String x);</p>
<p>​    // 引用语法 : 对象名::对象方法名</p>
<p>3.</p>
<p>// 简化格式 : System.out::println 对象名::对象方法</p>
<p>// 作用 : 已经有方法完成 Lambda 表达式需要实现的效果. 因此, 在程序中可以使用方法引用替代 Lambda 表达式.</p>
<p> 4.</p>
<p> // 方法 : 使用函数式接口作为参数 (这是 Lambda 表达式的传递基本)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectMethodRef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象方法 :</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String s = str.toUpperCase();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式接口仍然定义为</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当需要使用这个printUpperCase成员方法来替代Printable接口的Lambda的时候，已经具有了ObjectMethodRef类的对象实例，则可以通过对象名引用成员方法，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lambda 表达式实现 :</span></span><br><span class="line">        printString(<span class="string">"hello"</span>, s -&gt; System.out.println(s.toUpperCase()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象方法引用 :</span></span><br><span class="line">        ObjectMethodRef obj = <span class="keyword">new</span> ObjectMethodRef();</span><br><span class="line">        printString(<span class="string">"hello"</span>, obj::printUpperCase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(String str, Printable&lt;String&gt; printable)</span> </span>&#123;</span><br><span class="line">        printable.print(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果 :</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br></pre></td></tr></table></figure>
<h2 id="12-3-5-通过类名称引用静态方法"><a href="#12-3-5-通过类名称引用静态方法" class="headerlink" title="12.3.5 通过类名称引用静态方法"></a>12.3.5 通过类名称引用静态方法</h2><p>由于在java.lang.Math类中已经存在了静态方法abs，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法 :</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法 : Lambda 表达式</span></span><br><span class="line">        printCalculator(-<span class="number">88</span>, num -&gt; Math.abs(num));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法 : 静态方法引用</span></span><br><span class="line">        printCalculator(-<span class="number">88</span>, Math::abs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 :</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCalculator</span><span class="params">(<span class="keyword">int</span> num, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(num);</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果 :</span><br><span class="line">result = <span class="number">88</span></span><br><span class="line">result = <span class="number">88</span></span><br></pre></td></tr></table></figure>
<p><strong>notes：</strong></p>
<p>在这个例子中，下面两种写法是等效的：</p>
<p> Lambda表达式：n -&gt; Math.abs(n)</p>
<p>方法引用：Math::abs</p>
<h2 id="12-3-6-通过super引用成员方法"><a href="#12-3-6-通过super引用成员方法" class="headerlink" title="12.3.6 通过super引用成员方法"></a>12.3.6 通过super引用成员方法</h2><p>​    如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口</p>
<p><strong>notes：</strong></p>
<p> 在这个例子中，下面两种写法是等效的：</p>
<p>- Lambda表达式：() -&gt; super.sayHello()</p>
<p>方法引用：super::sayHello</p>
<h2 id="12-3-7-通过this引用成员方法"><a href="#12-3-7-通过this引用成员方法" class="headerlink" title="12.3.7 通过this引用成员方法"></a>12.3.7 通过this引用成员方法</h2><p>​    this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。首先是简单的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Richable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行为 : 变得快乐</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beHappy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结婚吧</span></span><br><span class="line">        merry(() -&gt; System.out.println(<span class="string">"买套房子."</span>));</span><br><span class="line"></span><br><span class="line">        merry(() -&gt; <span class="keyword">this</span>.buyCar());</span><br><span class="line"></span><br><span class="line">        merry(<span class="keyword">this</span>::changeWife);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行为 : 结婚 (需要变得有钱, 必须要买东西)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merry</span><span class="params">(Richable richable)</span> </span>&#123;</span><br><span class="line">        richable.buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行为 : 买套方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买套房子."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行为 : 买辆车子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buyCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买辆车子."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Husband husband = <span class="keyword">new</span> Husband();</span><br><span class="line">        husband.beHappy();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果 :</span><br><span class="line">买套房子.</span><br><span class="line">买辆车子.</span><br></pre></td></tr></table></figure>
<p>开心方法beHappy调用了结婚方法marry，后者的参数为函数式接口Richable：</p>
<p>在这个例子中，下面两种写法是等效的：</p>
<p>- Lambda表达式：() -&gt; this.buyCar()</p>
<p>- 方法引用：this::buyCar</p>
<h2 id="12-3-8-类的构造器引用"><a href="#12-3-8-类的构造器引用" class="headerlink" title="12.3.8 类的构造器引用"></a>12.3.8 类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用类名称::new的格式表示。首先是一个简单的Person类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，下面两种写法是等效的：</p>
<p>- Lambda表达式：name -&gt; new Person(name)</p>
<p>- 方法引用：Person::new</p>
<h2 id="12-3-9-数组的构造器引用"><a href="#12-3-9-数组的构造器引用" class="headerlink" title="12.3.9 数组的构造器引用"></a>12.3.9 数组的构造器引用</h2><p>数组也是Object的子类对象，所以同样具有构造器，只是语法稍有不同。</p>
<p>需要一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">int</span>[] buildArray(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = initIntArray(<span class="number">10</span>, len -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[len]);</span><br><span class="line">        System.out.println(<span class="string">"arr1.length = "</span> + arr1.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = initIntArray(<span class="number">10</span>, <span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(<span class="string">"arr2.length = "</span> + arr2.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个 int[] 数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] initIntArray(<span class="keyword">int</span> length, ArrayBuilder builder) &#123;</span><br><span class="line">       <span class="keyword">return</span> builder.buildArray(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果 :</span><br><span class="line">arr1.length = <span class="number">10</span></span><br><span class="line">arr2.length = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，下面两种写法是等效的：</p>
<p>- Lambda表达式：length -&gt; new int[length]</p>
<p>- 方法引用：int[]::new</p>
<h1 id="12-4-总结之-前瞻-Java语言的4大核心函数式接口"><a href="#12-4-总结之-前瞻-Java语言的4大核心函数式接口" class="headerlink" title="12.4 总结之 前瞻 Java语言的4大核心函数式接口"></a>12.4 总结之 前瞻 Java语言的4大核心函数式接口</h1><h2 id="12-4-1-总结"><a href="#12-4-1-总结" class="headerlink" title="12.4.1 总结"></a>12.4.1 总结</h2><p> <strong>第一步</strong>：定义函数式接口</p>
<p><strong> 第二步</strong>： 定义方法，将函数式接口作为方法的参数类型</p>
<p> <strong>总结</strong>：只要满足前两个步骤，我们就可以书写Lambda表达式了，</p>
<p><strong>   问</strong>：    在使用Lambda表达式传送传输时，思考哪两个东西？？</p>
<p><strong> 思考1</strong>：函数式接口中华抽象方法的参数列表</p>
<p><strong>  思考2</strong>：函数式接口中抽象方法的返回值类型</p>
<p> <strong>核心点</strong>：要求程序员对函数式接口中的抽象方法，参数类型和返回值类型，非常清晰的理解。因此没有这一层的理解，Lambda表达式的语法就无从书写了</p>
<p>   Lambda表达式的语法格式**：（抽象方法参数） -&gt;  { return  抽象方法的实现体 }</p>
<h2 id="12-4-2-4大函数式接口"><a href="#12-4-2-4大函数式接口" class="headerlink" title="12.4.2 4大函数式接口"></a>12.4.2 4大函数式接口</h2><p> Java 语言中提供了最重要的  “四大核心函数式接口”                    特有的抽象方法</p>
<table>
<thead>
<tr>
<th><strong>消费型接口：</strong></th>
<th>特点（有去无回）Consumer<t></t></th>
<th style="text-align:left">void accept（T  t）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>供给型接口</strong></td>
<td>特点 （无中生有）Supplier<t></t></td>
<td style="text-align:left">T  get();</td>
</tr>
<tr>
<td><strong>函数型接口</strong></td>
<td>特点（有去有回）Function&lt;T, R&gt;</td>
<td style="text-align:left">R apply (T  t)                                                                                     T -&gt; Type 参数类型  R -&gt; Result 返回值类型</td>
</tr>
<tr>
<td><strong>断言型接口</strong></td>
<td>特点（元芳，你怎么看）Predicate<t></t></td>
<td style="text-align:left">boolean  test （T  t）</td>
</tr>
</tbody>
</table>
<p><strong>说明：使用函数式接口作为方法的参数，这些API大部分都被定义到  StreamAPI  中</strong></p>
<pre><code>StreamAPI  主要操作对象为 “集合” 对象，不是  “读写”  对象
</code></pre><p>​    说明1：读写IO  主要是    “内存与硬盘”    实现数据交互</p>
<p>​    说明2：StreamAPI     主要是    ”内存与内存“        实现数据交互    （变量，数组，集合）</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: '',
  alipayImage: ''
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>Post author:  </strong>Francis</a>
          </li>
          <li class="post-copyright-link">
          <strong>Post link:  </strong>
          <a href="/2018/08/27/12Java函数式接口、方法引用/" target="_blank" title="12Java函数式接口、方法引用">htts://cocked.github.io/2018/08/27/12Java函数式接口、方法引用/</a>
          </li>
          <li class="post-copyright-license">
            <strong>Copyright Notice:   </strong>
            All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            unless stating additionally.
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/08/20/Jquery初探01/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Jquery初探</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#12-1-函数式接口"><span class="nav-number">1.</span> <span class="nav-text">12.1  函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-1-概念"><span class="nav-number">1.1.</span> <span class="nav-text">12.1.1 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-2-格式"><span class="nav-number">1.2.</span> <span class="nav-text">12.1.2 格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-3-FunctionalInterface注解"><span class="nav-number">1.3.</span> <span class="nav-text">12.1.3 @FunctionalInterface注解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-2-函数式编程"><span class="nav-number">2.</span> <span class="nav-text">12.2  函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-1-Lambda-的延时执行"><span class="nav-number">2.1.</span> <span class="nav-text">12.2.1 Lambda 的延时执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-2-使用函数式接口作为参数"><span class="nav-number">2.2.</span> <span class="nav-text">12.2.2 使用函数式接口作为参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-3-使用函数式接口作为返回值"><span class="nav-number">2.3.</span> <span class="nav-text">12.2.3 使用函数式接口作为返回值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-3-方法引用"><span class="nav-number">3.</span> <span class="nav-text">12.3  方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-2-冗余的Lambda场景"><span class="nav-number">3.1.</span> <span class="nav-text">12.3.2 冗余的Lambda场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-3-方法引用符"><span class="nav-number">3.2.</span> <span class="nav-text">12.3.3 方法引用符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-4-通过对象名引用成员方法"><span class="nav-number">3.3.</span> <span class="nav-text">12.3.4 通过对象名引用成员方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-5-通过类名称引用静态方法"><span class="nav-number">3.4.</span> <span class="nav-text">12.3.5 通过类名称引用静态方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-6-通过super引用成员方法"><span class="nav-number">3.5.</span> <span class="nav-text">12.3.6 通过super引用成员方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-7-通过this引用成员方法"><span class="nav-number">3.6.</span> <span class="nav-text">12.3.7 通过this引用成员方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-8-类的构造器引用"><span class="nav-number">3.7.</span> <span class="nav-text">12.3.8 类的构造器引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-9-数组的构造器引用"><span class="nav-number">3.8.</span> <span class="nav-text">12.3.9 数组的构造器引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-4-总结之-前瞻-Java语言的4大核心函数式接口"><span class="nav-number">4.</span> <span class="nav-text">12.4 总结之 前瞻 Java语言的4大核心函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-1-总结"><span class="nav-number">4.1.</span> <span class="nav-text">12.4.1 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-2-4大函数式接口"><span class="nav-number">4.2.</span> <span class="nav-text">12.4.2 4大函数式接口</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2016 - 2018 Francis的个人博客 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            Francis的个人博客
          </div>
          <div class="panel-body">
            Copyright © 2018 Francis All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>